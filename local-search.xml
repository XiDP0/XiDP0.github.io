<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小Pwn手杂谈(1.0.0)之不同输入函数之间的区别</title>
    <link href="/2024/11/19/%E5%B0%8FPwn%E6%89%8B%E6%9D%82%E8%B0%88%E4%B9%8B%E4%B8%8D%E5%90%8C%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/11/19/%E5%B0%8FPwn%E6%89%8B%E6%9D%82%E8%B0%88%E4%B9%8B%E4%B8%8D%E5%90%8C%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文涉及 <code>read函数</code> <code>fgets函数</code> <code>scanf函数</code> 以及 <code>gets函数</code> 获取字符串后内存的区别，以及在pwntools中使用 <code>sendline</code> 和 <code>send</code> 的区别。实验过程有些冗长，嫌麻烦的师傅可以直接查看下面的总结</p><p>实验目标</p><ol><li><code>read</code> <code>fgets</code> <code>scanf</code> 这种可以限定大小的输入，如果输入量小于&#x2F;等于&#x2F;大于它们的输入量分别会出现什么情况</li><li><code>scanf(&quot;%s&quot;，&amp;buf)</code>这种情况是否存在溢出</li><li><code>gets</code> 输入是怎么处理<code>\n</code>符号的</li></ol><p>下面是我实验用的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br>&#123;<br>    setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>    setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>    setvbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">char</span> bss[<span class="hljs-number">8</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    init();<br>    <span class="hljs-type">char</span> *ptr[<span class="hljs-number">13</span>];<br>  <br>    <span class="hljs-comment">// 初始化bss数组</span><br>    <span class="hljs-built_in">memset</span>(bss, <span class="hljs-number">0x22</span>, <span class="hljs-keyword">sizeof</span>(bss)*<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 利用循环申请12个0x30大小的堆块，并将对应地址存储在ptr这个指针数组里面</span><br>    <span class="hljs-comment">// 如果申请失败则直接退出程序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        ptr[i] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>        <span class="hljs-keyword">if</span> (!ptr[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不用在意，只是gdb调试时方便跳转的标记</span><br>    sleep(<span class="hljs-number">0.1</span>);<br>    <br>    <span class="hljs-comment">// 使用memset将堆块的内容设置为\x22,为了方便我们区分哪些是我们输入的东西</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(ptr[i], <span class="hljs-number">0x22</span>, <span class="hljs-number">0x30</span>);<br>    &#125;<br>    sleep(<span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// 这里free是因为free之后的堆块在pwndbg里面显示绿绿的，方便进行区分不同函数输入</span><br>    <span class="hljs-built_in">free</span>(ptr[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">free</span>(ptr[<span class="hljs-number">7</span>]);<br>    <span class="hljs-built_in">free</span>(ptr[<span class="hljs-number">11</span>]);<br>    sleep(<span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// step 1 测试read函数，限定输入大小为8字节，查看分别输入 a*6 a*8 a*10 后内存的样子</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read a*6\n&quot;</span>);<br>    read(<span class="hljs-number">0</span>, ptr[<span class="hljs-number">0</span>], <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF); <span class="hljs-comment">// 为了防止残留的\x0a影响后续的输入，这里采用了getchar来把多余的\x0a吃掉</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read a*8\n&quot;</span>);<br>    read(<span class="hljs-number">0</span>, ptr[<span class="hljs-number">1</span>], <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read a*10\n&quot;</span>);<br>    read(<span class="hljs-number">0</span>, ptr[<span class="hljs-number">2</span>], <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    sleep(<span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// step 2 测试fgets函数，限定输入大小为8字节，查看分别输入 a*6 a*8 a*10 后内存的样子</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fgets a*6\n&quot;</span>);<br>    fgets(ptr[<span class="hljs-number">4</span>], <span class="hljs-number">8</span>, <span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fgets a*8\n&quot;</span>);<br>    fgets(ptr[<span class="hljs-number">5</span>], <span class="hljs-number">8</span>, <span class="hljs-built_in">stdin</span>);    <br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fgets a*10\n&quot;</span>);<br>    fgets(ptr[<span class="hljs-number">6</span>], <span class="hljs-number">8</span>, <span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    sleep(<span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// step 3 测试scanf函数，限定输入的字符串大小为8字节，查看分别输入 a*6 a*8 a*10 后内存的样子</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;scanf a*6\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%8s&quot;</span>, ptr[<span class="hljs-number">8</span>]);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;scanf a*8\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%8s&quot;</span>, ptr[<span class="hljs-number">9</span>]);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;scanf a*10\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%8s&quot;</span>, ptr[<span class="hljs-number">10</span>]);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    sleep(<span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// step 4 测试gets函数输入之后是什么样子的，仅输入一次，输入6个字节的a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gets a*6\n&quot;</span>);<br>    gets(ptr[<span class="hljs-number">12</span>]);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    sleep(<span class="hljs-number">0.1</span>);<br><br><br>    <span class="hljs-comment">// 测试scanf(&quot;%s&quot;,bss)是否存在溢出</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,bss);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,bss);<br>    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; getchar() != EOF);<br>    sleep(<span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们开始测试:</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p><img src="/../picture/talk1.0.0/1.png"><br>开头在sleep上打断点，方便我们后续使用c快速跟进，查看到bss全局变量在 <code>0x555555558050</code> 这个位置上</p><p>来到第一个sleep所在的地方<br>查看bss段里面是什么，可以看到已经都变成22了，后面输入后改变我们就可以直观的看到<br><img src="/../picture/talk1.0.0/2.png"></p><p>来到第二个sleep所在的地方<br>查看堆中内存，可以看到已经都变成22了，后面输入后改变我们就可以直观的看到<br><img src="/../picture/talk1.0.0/3.png"></p><p>来到第三个sleep所在的地方<br>查看堆的情况<br><img src="/../picture/talk1.0.0/4.png"></p><h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p>继续跟进程序，让我们看看read，分别输入 <code>aaaaaa</code> <code>aaaaaaaa</code> <code>aaaaaaaaaa</code><br><img src="/../picture/talk1.0.0/5.png"><br>这里仔细的人会发现，<code>read a*6</code> 后面到 <code>read a*8</code> 中间除了输入还空了一行，这是因为包括 <code>\n</code><br>在内我们输入的全部东西都被读入了内存中，<code>getchar</code> 没有读取到<code>\n</code>所以我手动敲了一个回车来结束 <code>getchar</code></p><p>来到第四个sleep所在的地方<br>我们已经使用read输入了，下面我们来查看一下堆内存里面是什么<br><img src="/../picture/talk1.0.0/6.png"><br>可以看到输入六个a的话内存里面是 <code>六个a和一个回车符号</code><br>输入八个a的话内存里面是 <code>八个a，回车符号没有被读入</code><br>输入是十个a的话内存里面是 <code>十个a，回车符号没有被读入</code></p><p>虽然实验很简陋但是我们可以简单得出结论，read输入的话会读取指定的字节数，除非遇到<code>\x00</code>，不然输入其他东西都无法阻止read停止，直到读取完后放入指定的内存中，没读取到的部分则保持原样不动</p><h3 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h3><p>继续跟进程序，让我们看看fgets，再次分别输入 <code>aaaaaa</code> <code>aaaaaaaa</code> <code>aaaaaaaaaa</code><br><img src="/../picture/talk1.0.0/7.png"><br>查看对应的堆内存<br><img src="/../picture/talk1.0.0/8.png"><br>我们不难简单的得出结论，fgets和read不太一样，虽然我们设定了读取8个字节，他并不会老实读取8个字节，而是只读取7个，然后再主动添加一个<code>\x00</code>来作为输入的字符串的结尾</p><p>因此像read这样的输入函数，如果buf为8字节的字符串，用户输入8字节，而read傻傻的读取八字节，那么字符串结尾的<code>\x00</code>就会被省略掉，如果此时有一个 <code>buf2</code> 和 <code>buf</code> 的位置相邻，那么使用puts输出buf的时候就会连同buf2一起输出出来，因为buf失去了<code>\x00</code>，puts这类输出函数就没办法判断这个字符串什么时候结束，只能无脑输出，直到遇见<code>\x00</code></p><h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><p>继续跟进程序，让我们看看scanf,再次分别输入 <code>aaaaaa</code> <code>aaaaaaaa</code> <code>aaaaaaaaaa</code><br><img src="/../picture/talk1.0.0/9.png"><br>查看对应的堆内存<br><img src="/../picture/talk1.0.0/10.png"><br>可以发现我们的scanf函数非常的聪明，他不像fgets函数偷工减料，让他读取8字节他是真读取<br>并且同时他读取完八字节后，会再在后面加一个<code>\x00</code>来保持字符串的独立性</p><p>继续跟进程序，让我们看看gets,输入 <code>aaaaaa</code><br><img src="/../picture/talk1.0.0/11.png"><br>查看堆内存<br><img src="/../picture/talk1.0.0/12.png"></p><h3 id="scanf函数的溢出"><a href="#scanf函数的溢出" class="headerlink" title="scanf函数的溢出"></a>scanf函数的溢出</h3><p>最后来看看scanf(“%s”,bss)的溢出形式<br><img src="/../picture/talk1.0.0/13.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>read函数</code>:第三个参数是几就读取几个，一旦数量超过第三个参数后就直接忽略，就只读取到第三个参数所规定的数量为止，不会自动添加<code>\x00</code>,如果 <code>允许输入长度</code> <code>=</code> <code>字符串长度</code> 可能导致字符串失去结尾的<code>\x00</code></p><p><code>fgets函数</code>:读取的字节数为<code>第二个参数-1</code>,超出的部分会被忽略，会自动在最后添加<code>\x00</code></p><p><code>scanf(&quot;%?s&quot;, &amp;buf)</code>:读取?个字节,超出的部分会被忽略,然后在最末尾添加<code>\x00</code>。<code>scanf(&quot;%s&quot;, &amp;buf)</code>没有规定读取字节数，存在溢出</p><p><code>gets函数</code>:无脑读取，一直读取，直到用户输入回车才停止，输入的数据全部读取,但是最后会把读取到的回车(<code>\x0a</code>)变成<code>\x00</code></p><p>对于上面函数如何选择 <code>send</code> 和 <code>sendline</code></p><ol><li><p>对于read函数 <code>send</code> 和 <code>sendline</code> 都可以，但是<code>建议使用send</code>，不然屁股后面多个<code>\x0a</code>，有时候打入<code>/bin/sh</code>字符串的时候使用sendline没发现有个<code>\x0a</code>在屁股上一直打不通也是很痛苦的</p></li><li><p>对于 <code>fgets</code> <code>gets</code> <code>scanf</code> 这三个函数只能使用sendline</p></li></ol><p>什么?你问我上面的 <code>send</code> 和 <code>sendline</code> 是怎么总结出来的?<br>由于时间关系(懒得再做一遍了)，直接看ZikH26师傅的博客来总结了<a href="https://www.cnblogs.com/ZIKH26/articles/15855666.html">探究pwntools中sendline的回车所造成的影响（什么时候用sendline，什么时候用send） - ZikH26 - 博客园 (cnblogs.com)</a><br>(不要喷我啊，求求了我什么都会做的<code>Orz</code>)</p><p>最后感谢您的观看</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之pwn工具篇--pwntools库的基本使用</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8Bpwn%E5%B7%A5%E5%85%B7%E7%AF%87--pwntools%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8Bpwn%E5%B7%A5%E5%85%B7%E7%AF%87--pwntools%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="啥是pwntools"><a href="#啥是pwntools" class="headerlink" title="啥是pwntools?"></a>啥是pwntools?</h3><p><strong>Pwntools</strong> 是一个用于漏洞利用和二进制分析的 <code>Python 库</code>，广泛应用于安全研究、渗透测试和竞争性编程（如 CTF，Capture The Flag）中。它为用户提供了一套强大的工具和功能，以<code>简化与二进制文件的交互</code>、<code>网络通信</code>以及各种<code>常见任务的执行</code>。</p><p>简而言之，<code>pwntools</code>可以说是pwn手必备的工具，它帮助pwn手<code>连接远程服务器</code>，<code>发送信息</code>，<code>接收信息</code>，以及提供了很多工具来帮助pwn手快速攻克题目</p><h3 id="如何安装pwntools"><a href="#如何安装pwntools" class="headerlink" title="如何安装pwntools?"></a>如何安装pwntools?</h3><p>按照以下流程在python3中安装pwntools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; apt-get update<br>&gt;&gt;&gt; apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential<br>&gt;&gt;&gt; python3 -m pip install --upgrade pip<br>&gt;&gt;&gt; python3 -m pip install --upgrade pwntools<br></code></pre></td></tr></table></figure><h3 id="如何使用pwntools"><a href="#如何使用pwntools" class="headerlink" title="如何使用pwntools?"></a>如何使用pwntools?</h3><p>显然我们需要学会使用python,并在编写脚本的时候导入pwntools库</p><h4 id="导入pwntools"><a href="#导入pwntools" class="headerlink" title="导入pwntools:"></a>导入pwntools:</h4><p>这大概会是每一个pwn手的编写脚本时的第一句话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <span class="hljs-comment">#使用from来导入pwntools模块</span><br></code></pre></td></tr></table></figure><h4 id="设置基本信息"><a href="#设置基本信息" class="headerlink" title="设置基本信息:"></a>设置基本信息:</h4><p>在打靶机前需要按照靶机的类型设置好基本信息,因为<code>pwntools</code>中很多工具需要依靠<code>contest</code>来自动选择类型，比如<code>shellcraft(用于生成shellcode代码的工具)</code>等<br><code>os</code>是靶机的系统类型一般就是<code>linux系统</code><br><code>arch</code>是指题目的架构,我们可以使用<code>checksec</code>工具来查看具体的架构，一般是<code>AMD64</code>或<code>i386</code><br><code>log_level</code>是指日志输出等级，可以设置为<code>debug</code>或者直接不设置删掉也行，设置为debug在脚本运行的时候会输出我们具体发送了什么信息，靶机反馈了什么信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="连接远程靶机"><a href="#连接远程靶机" class="headerlink" title="连接远程靶机:"></a>连接远程靶机:</h4><p>在pwn(1.0.0)中曾经介绍过，我们启动靶机后会得到一个靶机地址，把靶机地址的前缀和端口分别输入在<code>remote</code>里面，<code>ip</code>用<code>&#39;&#39;</code>包裹起来用逗号隔开<code>端口</code>，这样就实现了远程连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">用于连接远程服务器，并把连接到的进程命名为p，后续的函数都围绕这个p进程展开<br>p = remote(<span class="hljs-string">&quot;ip&quot;</span>,port) <br>比如:p = remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">5555</span>)<br></code></pre></td></tr></table></figure><p>当然偶尔也有题目需要用ssh来连接靶机的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">通过使用ssh来连接靶机<br>p = ssh(host=<span class="hljs-string">&#x27;192.168.xx.xxx&#x27;</span>, user=<span class="hljs-string">&#x27;xidp&#x27;</span>, port=<span class="hljs-number">6666</span>, password=<span class="hljs-string">&#x27;88888888&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试:"></a>本地调试:</h4><p>在远程之前，我们可以在本地先进行一些测试,那么我们可以本地运行文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">本地调试程序,并且将进程命名为p<br>p = process(<span class="hljs-string">&quot;文件名&quot;</span>)<br>比如:p = process(<span class="hljs-string">&quot;./pwn&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息:"></a>发送信息:</h4><p>假设我们需要发送的是<code>payload</code>这个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">**************************************************<br>p.send(payload) <span class="hljs-comment"># 直接发送payload</span><br>**************************************************<br>p.sendline(payload) <span class="hljs-comment"># 发送payload，但是结尾会有一个\n</span><br>**************************************************<br>p.sendafter(<span class="hljs-string">&quot;string&quot;</span>, payload) <span class="hljs-comment"># 接收到 string (这里说的string可以替换成任何信息) 之后会发送payload，但是如果没有接收到string，那么就会导致脚本一直卡在这里不动</span><br>**************************************************<br>p.sendlineafer(<span class="hljs-string">&quot;string&quot;</span>, payload) <span class="hljs-comment"># 接收到 string 之后会发送payload 并且在payload最后添加\n</span><br></code></pre></td></tr></table></figure><p>一般常用的发送就这几种，此时可能会有一个疑问，<code>p.send</code> 和 <code>p.sendline</code> 就差一个<code>\n</code>有什么区别?<br>有区别，比如<code>gets()</code>和<code>scanf()</code>这类函数它们会以<code>\n</code>作为结束符号，如果我们没有发送<code>\n</code>,它们就会一直卡着等待输入，所以遇到这类输入函数就必须要用<code>p.sendline</code>来添加<code>\n</code>(当然如果我们手动在payload里面添加<code>\n</code>也OK)。遇到<code>read()</code>这类函数则使用<code>p.sendline</code>和<code>p.send</code>都可以.</p><p>那如果我们都使用<code>p.sendline</code>不就好了吗? NO，这并不好，比如我们遇到<code>read()</code>并且希望发送一些字符串比如<code>&quot;flag&quot;</code>,如果你用<code>p.send(&quot;flag&quot;)</code>那么没错你发送的是<code>flag</code>，计算机解析后是<code>\x67\x61\x6C\x66</code>，而如果你用的是<code>p.sendline(&quot;flag&quot;)</code>，则你发送的是<code>flag\n</code>,计算机解析后是<code>\x0a\x67\x61\x6C\x66</code>,这一点细节上的差距就可能导致我们的脚本无法打通，所以我们需要面对合适的函数使用合适的方法，后续我们将会继续讨论<code>read()、scanf()、fgets()和gets()</code>这类函数在输入的时候具体有什么区别</p><h4 id="接收信息"><a href="#接收信息" class="headerlink" title="接收信息:"></a>接收信息:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">**************************************************<br>p.recv(<span class="hljs-built_in">int</span>) 利用recv来接收返回的数据，并且可以控制接受到的字节数<br>比如:p.recv(<span class="hljs-number">7</span>) =&gt; 系统输出<span class="hljs-string">&#x27;hello world&#x27;</span> =&gt; 我们会接受到<span class="hljs-string">&#x27;hello w&#x27;</span> <br>**************************************************<br>p.recvline(<span class="hljs-string">&#x27;string&#x27;</span>) 设置一个标识符，接收标识符所在的那一行<br>比如:p.recvline(<span class="hljs-string">&#x27;O.o&#x27;</span>)<br><span class="hljs-comment">#系统输出:</span><br>Hello World <br>This <span class="hljs-keyword">is</span> a test. <br>O.o This <span class="hljs-keyword">is</span> the target line. <br>Goodbye.<br><span class="hljs-comment">#我们接收:</span><br>O.o This <span class="hljs-keyword">is</span> the target line. <br>**************************************************<br>p.recvlines(N) 接收 N 行输出<br>**************************************************<br>p.recvuntil(<span class="hljs-string">&#x27;string&#x27;</span>) 可以指定接收到某一字符串的时候停止 ,还有第二个参数 drop，drop=<span class="hljs-literal">True</span>(默认为false) 表示丢弃设定的停止符号<br>比如:p.recvuntil(<span class="hljs-string">&#x27;or&#x27;</span>) <br><span class="hljs-comment">#系统输出:</span><br>hello world <br><span class="hljs-comment">#我们接收:</span><br>hello wor  <br>比如:a = io.recvuntil(<span class="hljs-string">&#x27;]&#x27;</span>, drop=<span class="hljs-literal">True</span>)<br>就是一直获取到`]`符号出现就停止，并且不接收`]`符号<br>**************************************************<br></code></pre></td></tr></table></figure><h4 id="传递到终端"><a href="#传递到终端" class="headerlink" title="传递到终端:"></a>传递到终端:</h4><p>大概是每个脚本的最后一句话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">p.interactive()<br>接受信息并且在终端操作，程序拿到shell，然后就可以转接到linux终端上，让pwn手享受拿flag的乐趣<br></code></pre></td></tr></table></figure><h4 id="构造发送地址类型"><a href="#构造发送地址类型" class="headerlink" title="构造发送地址类型:"></a>构造发送地址类型:</h4><p><code>p64/p32/u64/u32</code>这类函数的作用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">**************************************************<br>p64(<span class="hljs-built_in">int</span>) <br>p64(<span class="hljs-number">0xfaceb00c</span>) =&gt; <span class="hljs-string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00\x00&#x27;</span><br>**************************************************<br>u64(<span class="hljs-built_in">str</span>) <br>u64(<span class="hljs-string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00&#x27;</span>) =&gt;<span class="hljs-number">0xfaceb00c</span><br>**************************************************<br>p32(<span class="hljs-built_in">int</span>)  <br>p32(<span class="hljs-number">0xfaceb00c</span>) =&gt; <span class="hljs-string">&#x27;\x0c\xb0\xce\xfa&#x27;</span><br>**************************************************<br>u32(<span class="hljs-built_in">str</span>) <br>u32(<span class="hljs-string">&#x27;\x0c\xb0\xce\xfa&#x27;</span>) =&gt; <span class="hljs-number">0xfaceb00c</span><br>**************************************************<br></code></pre></td></tr></table></figure><p><code>p64()</code>这种类型用于将消息变成对应的进制流（因为原本程序里面的数据都是已经编译过的，所以打入的数据也需要是编译过的,所以需要使用p64()这类工具）<br><code>u64()</code>这种类型<code>用于泄露地址</code>的时候将泄露的进制流变成对应的原本的样子，方便来辨认查找glibc版本</p><p>因为一般计算机都是小端程序，所以这两个函数都自带有将数据变成小端需要的样子，如果遇到大端程序可能需要额外注意</p><p> 除了<code>p32()</code>这种转化方式还有，<code>flat()</code>，它可以将多个数据结构（如字符串、整数等）连接在一起，并将它们转换为二进制数据。通常用于构建复杂的ROP链的<code>shellcode</code>。flat 函数会将数据扁平化，将它们按照顺序连接在一起，不做任何其他处理。在提供的代码中，<code>flat</code> 被用于构建一个包含多个元素的列表，然后将它们连接起来形成一个二进制数据。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = flat([<span class="hljs-number">0x12345678</span>, <span class="hljs-string">&#x27;AAAA&#x27;</span>, <span class="hljs-number">0xdeadbeef</span>], word_size=<span class="hljs-number">4</span>/<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure></p><h4 id="的汇编与反汇编"><a href="#的汇编与反汇编" class="headerlink" title="的汇编与反汇编:"></a>的汇编与反汇编:</h4><p>pwntools提供了两个工具:<br><code>asm</code>函数可以将汇编代码转为对应的二进制<br><code>disasm</code>函数则相反可以将二进制转化为汇编代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>asm(<span class="hljs-string">&#x27;mov eax, 0&#x27;</span>)   <span class="hljs-comment">#汇编</span><br><span class="hljs-string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>disasm(<span class="hljs-string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="hljs-comment">#反汇编</span><br><span class="hljs-string">&#x27;mov    eax,0xb&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="生成shllcode后门"><a href="#生成shllcode后门" class="headerlink" title="生成shllcode后门:"></a>生成shllcode后门:</h4><p><strong>pwnlib.shellcraft模块</strong>包含<strong>生成shell代码</strong>的函数。<br>在使用之前我们需要通过<strong>context设置架构</strong>，然后<strong>生成shellcode</strong>也就是生成后门</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>)<br><span class="hljs-comment"># 表示将当前执行上下文的体系结构设置为i386(这里的i386可以通过checksec来查看文件是什么架构的  </span><br>shellcode = asm(shellcraft.sh())<br><span class="hljs-comment"># asm()是把括号内的内容编译成机器码(只有机器码才可以执行)，一般用来打入后门。pwntools自带的后门函数，可以生成类似system(&#x27;/bin/sh/&#x27;)这样功能的汇编代码 </span><br><span class="hljs-comment"># 通常可以配合  .ljust() 来使用  </span><br>shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">b&#x27;A&#x27;</span>)  <br><span class="hljs-comment"># 这里的 .ljust() 是 Python 中字符串对象的方法，用于在字符串的右侧填充指定的字符，使字符串达到指定的长度。</span><br></code></pre></td></tr></table></figure><p>纯净版shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>shellcode = asm(shellcraft.sh())<br>shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">b&#x27;A&#x27;</span>)  <br></code></pre></td></tr></table></figure><p>当然也有专门的网站收集shellcode<br>shellcode的网址：<br> <a href="https://www.exploit-db.com/shellcodes/43550">https://www.exploit-db.com/shellcodes/43550</a><br>下面也提供一些已经编译好的shellcode:<br>64位linux的24Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode_x64 =<span class="hljs-string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span><br></code></pre></td></tr></table></figure><p>64位Linux的23Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode_x64 =<span class="hljs-string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span><br></code></pre></td></tr></table></figure><p>更多的时候根据题目的要求，我们需要自己手动编写shellcode来绕过一些检测，所以编写<code>shellcode</code>是后续必须要掌握的一种技巧</p><p>运行时调用gdb调试:<br>使用<code>gdb.attach</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gdb.attach(p, gdbscript=<span class="hljs-string">&quot;&quot;&quot; b main; commands; silent printf &quot;Breakpoint hit\n&quot;; continue; end &quot;&quot;&quot;</span>)<br>在需要进行调试的位置插入gdb.attach(p)即可在执行到的时候打开gdb进行调试<br>p是指定的需要调试的进程(必须要本地调试，否则会报错)<br>gdbscript是打开gdb后需要进行的操作，使用 ; 进行隔离<br></code></pre></td></tr></table></figure><p>一般<code>gdb.attach(p)</code>可以和<code>pause()</code>函数连用，可以确保在gdb完全打开之前脚本不运行<br><code>pause()</code>函数用于暂停脚本的运行，直到用户输入任意数据</p><h4 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块:"></a>ELF模块:</h4><p>我们可以通过这个模块来快速获取pwn文件的<code>got表地址</code>以及<code>plt表地址</code><br>用于获取<code>ELF文件的信息</code>，首先使用<code>ELF()</code>获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。<br>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址，和LibcSearcher库联动使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>elf.address <span class="hljs-comment"># 文件装载的基地址 =&gt; 0x400000</span><br><br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>] <span class="hljs-comment"># 获取函数地址 =&gt; 0x401680</span><br><br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>] <span class="hljs-comment"># 获取对应函数在GOT表的地址 =&gt; 0x60b070</span><br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>] <span class="hljs-comment"># 获取对应函数在PLT表的地址 =&gt; 0x401680</span><br></code></pre></td></tr></table></figure><p>参考文献:<br><a href="https://www.yuque.com/cyberangel/rg9gdm/uqazzg">PWN入门（1-1-5）-pwntools学习 (yuque.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之pwn工具篇--Pwndbg基础使用</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8Bpwn%E5%B7%A5%E5%85%B7%E7%AF%87--Pwndbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8Bpwn%E5%B7%A5%E5%85%B7%E7%AF%87--Pwndbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是pwndbg"><a href="#什么是pwndbg" class="headerlink" title="什么是pwndbg?"></a>什么是pwndbg?</h3><p>它是<code>gdb</code>的一个插件，增加了许多功能，来帮助pwn手可以快速寻找到所需要的信息，除了<code>pwndbg</code>之外还有<code>peda</code>、<code>gef</code>等工具可以用来协助进行调试。</p><h3 id="如何给pwndbg分屏"><a href="#如何给pwndbg分屏" class="headerlink" title="如何给pwndbg分屏?"></a>如何给pwndbg分屏?</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">vim ~/.gdbinit<br><span class="hljs-built_in">set</span> context-output /dev/pts/<span class="hljs-number">2</span> # 这里修改成<span class="hljs-number">2</span>，那么就会在第二个终端显示信息<br></code></pre></td></tr></table></figure><h3 id="pwndbg的基础操作"><a href="#pwndbg的基础操作" class="headerlink" title="pwndbg的基础操作:"></a>pwndbg的基础操作:</h3><p>启动调试:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gdb ./文件名<br>比如:gdb ./pwn<br></code></pre></td></tr></table></figure><p>如果我们已经成功安装了<code>pwndbg</code>，那么打开<code>gdb</code>之后会显示<code>pwndbg&gt;</code><br>这样的提示符号，否则是<code>gdb&gt;</code></p><p>基础操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c">**************************************************<br>pwndbg&gt; start <br># 开始运行，会停留在start函数上(start函数是main函数之前的一个函数) <br>**************************************************<br>pwndbg&gt; q <br># 退出调试<br>**************************************************<br>pwndbg&gt; r <br># 从头运行程序直到遇到断点,没有断点则会一直运行到结束<br>**************************************************<br>pwndbg&gt; c <br># 继续执行程序直到遇到断点，没有断点则会一直运行到结束<br>**************************************************<br>pwndbg&gt; n <br># 单步步过，n不会进入一个小函数<br>**************************************************<br>pwndbg&gt; ni <br># 常用，同n，但是是汇编层面的一步<br>**************************************************<br>pwndbg&gt; s <br># 步入，比如遇到一个call 什么什么函数，s会进入看看怎么个事 <br>**************************************************<br>pwndbg&gt; si <br># 常用，同s，但是是汇编层面的一步<br>**************************************************<br>pwndbg&gt; fini <br># 快速运行结束当前函数<br>**************************************************<br>pwndbg&gt; context <br># 重新打印页面信息<br>**************************************************<br>pwndbg&gt; b function_name<br># 比如: b read 在read函数上下断点，运行到read函数的时候就会停止<br>**************************************************<br>pwndbg&gt; b *(&amp;function_name+offset)<br># 比如: b *(&amp;read + <span class="hljs-number">10</span>) 在read函数+<span class="hljs-number">10</span>的地址上下断点，运行到这个地址的时候就会停止<br>**************************************************<br>pwndbg&gt; b *<span class="hljs-number">0xadd</span>r<br># 比如: b *<span class="hljs-number">0x408010</span> 那么程序运行到<span class="hljs-number">0x408010</span>这个地址的时候就会停止<br>**************************************************<br>pwndbg&gt; i b<br># 查看断点信息，哪些地方打了断点<br>**************************************************<br>pwndbg&gt; delete &lt;断点序号&gt;<br># 删除断点序号对应的断点,单独一个delete会删除所有断点<br>**************************************************<br>pwndbg&gt; i r<br># 查看所有寄存器中存储的数据<br>**************************************************<br>pwndbg&gt; i r &lt;registers&gt;<br># 查看具体某一个寄存器的值 比如: pwndbg&gt; i r rax<br>**************************************************<br>pwndbg&gt; <span class="hljs-built_in">stack</span> &lt;<span class="hljs-type">int</span>&gt;<br># 查看栈中的信息，具体数量填在<span class="hljs-built_in">stack</span>后面，比如: <span class="hljs-built_in">stack</span> <span class="hljs-number">50</span><br>**************************************************<br>pwndbg&gt; search &lt;<span class="hljs-built_in">string</span>&gt;<br># 在程序中查看字符串，可以查看自己输入的信息被存在什么地方了<br>**************************************************<br>pwndbg&gt; <span class="hljs-built_in">set</span> $&lt;rigister&gt; = &lt;<span class="hljs-type">int</span>&gt;<br># 使用<span class="hljs-built_in">set</span>来给寄存器设置自定义的值<br>**************************************************<br>pwndbg&gt; bt<br># 查看我们当前这个函数的上一个函数是什么<br>**************************************************<br>pwndbg&gt; vmmap<br># 查看程序各个段的位置以及权限等信息<br>**************************************************<br>pwndbg&gt; elf<br># 查看elf文件信息<br>**************************************************<br>pwndbg&gt; bins<br># 查看释放的堆块<br>**************************************************<br>pwndbg&gt; heap<br># 查看正在使用的堆块<br>**************************************************<br></code></pre></td></tr></table></figure><h3 id="x命令和p命令的使用"><a href="#x命令和p命令的使用" class="headerlink" title="x命令和p命令的使用:"></a>x命令和p命令的使用:</h3><h4 id="1-x-命令"><a href="#1-x-命令" class="headerlink" title="1. x 命令"></a>1. <code>x</code> 命令</h4><p><code>x</code> 命令用于查看内存中的数据。它可以显示指定地址或变量所占内存的内容。其基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x/[n][f][u] addr<br></code></pre></td></tr></table></figure><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>n</code>：可选，表示要显示的单元数量，默认为1。</li><li><code>f</code>：可选，表示显示的格式，常见格式包括：<ul><li><code>d</code>：十进制整数</li><li><code>x</code>：十六进制</li><li><code>o</code>：八进制</li><li><code>c</code>：字符</li><li><code>f</code>：浮点数</li></ul></li><li><code>u</code>：可选，表示数据单位，常见单位包括：<ul><li><code>b</code>：字节</li><li><code>h</code>：半字（2 字节）</li><li><code>w</code>：字（4 字节）</li><li><code>g</code>：巨字（8 字节）</li></ul></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ol><li><p><strong>查看内存地址的内容</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x/<span class="hljs-number">10</span>x <span class="hljs-number">0x7fffffffe000</span><br></code></pre></td></tr></table></figure><p>以上命令将以十六进制格式显示从 <code>0x7fffffffe000</code> 开始的10个字节的内容。</p></li><li><p><strong>查看变量的内容</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x/<span class="hljs-number">4</span>d my_array<br></code></pre></td></tr></table></figure><p>该命令将以十进制格式查看 <code>my_array</code> 数组的前4个元素。</p></li></ol><h4 id="2-p-命令"><a href="#2-p-命令" class="headerlink" title="2. p 命令"></a>2. <code>p</code> 命令</h4><p><code>p</code> 命令用于打印变量的值，通常用于查看变量的当前状态。其基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p [expression]<br></code></pre></td></tr></table></figure><h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>expression</code>：要打印的变量名或表达式。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><ol><li><p><strong>打印简单变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p my_variable<br></code></pre></td></tr></table></figure><p>该命令将输出 <code>my_variable</code> 的当前值。</p></li><li><p><strong>打印结构体成员</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p my_struct.member<br></code></pre></td></tr></table></figure><p>此命令将输出结构体 <code>my_struct</code> 中 <code>member</code> 的值。</p></li><li><p><strong>打印表达式的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p my_variable + <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>该命令将输出 <code>my_variable</code> 的值加上10的结果</p></li></ol><h4 id="3-常见用法示例"><a href="#3-常见用法示例" class="headerlink" title="3. 常见用法示例"></a>3. 常见用法示例</h4><p><strong>3.1 打印变量地址</strong></p><p>使用 <code>&amp;</code> 操作符可以打印变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p &amp;my_variable<br></code></pre></td></tr></table></figure><hr><p><strong>3.2 观察数组</strong></p><p>结合 <code>p</code> 和 <code>x</code> 命令，可以更好地观察数组内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x/<span class="hljs-number">10</span>d my_array p my_array[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><hr><p><strong>3.3 打印指针指向的值</strong></p><p>如果打印指针指向的内容，可以使用 <code>*</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p *my_pointer<br></code></pre></td></tr></table></figure><p>在 <code>gdb</code> 中是可以设置地址随机化开关，需要的时候可以关闭，来帮助我们调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; <span class="hljs-built_in">set</span> disable-randomization on# 开<br>pwndbg&gt; <span class="hljs-built_in">set</span> disable-randomization off# 关<br>pwndbg&gt; show disable-randomization# 查<br></code></pre></td></tr></table></figure><p>参考文献:<br><a href="https://www.cnblogs.com/ve1kcon/p/17812420.html">gdb调试入门指北 - ve1kcon - 博客园 (cnblogs.com)</a><br><a href="https://www.bilibili.com/video/BV1QW4y1c7Ux/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">pwn技术分享——pwndbg分屏显示设置_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之PWN入门(1.1.2)C程序调用过程与函数栈变化（32位 vs 64位）(Intel)</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.2)C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.2)C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/</url>
    
    <content type="html"><![CDATA[<p>本文使用Intel 的32位为例子进行举例。64位本质上和32位类似，主要区别在于函数参数的调用方式，文章结尾会简要提及。</p><p>重新回顾一下栈pop和push指令</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 将0x50的压入栈</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">0x50</span><br></code></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/1.png"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// 将<span class="hljs-built_in">esp</span>指向的数据放入指定的寄存器中<br><span class="hljs-keyword">pop</span> 寄存器名字<br>比如 ：<span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>执行之后<span class="hljs-built_in">eax</span>的值就变成了<span class="hljs-number">0x50</span><br></code></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/2.png"></p><h3 id="栈帧是什么"><a href="#栈帧是什么" class="headerlink" title="栈帧是什么?"></a>栈帧是什么?</h3><p><code>栈帧</code>，也就是stack frame，<code>其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 ebp 指向栈底，也就是基址指针；用 esp 指向栈顶</code>，也就是栈指针。下面是一个栈帧的示意图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> )</span> &#123;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> ) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/3.png"><br>我们来详细分析一下上面的这个图和那一小段代码</p><p>1.其实<code>main函数</code>只是我们作为程序员认为的程序的入口，实际上在<code>main函数</code>之前编译器还会添加很多函数比如<code>start函数</code>等等，所以<code>main函数</code>的栈帧之前还是有<code>栈帧</code>的</p><p>2.最开始进入到main函数中，还没有执行<code>func(参数1, 参数2 ,参数3 ) ;</code>这条代码的时候<br><img src="/../picture/pwn1.1.2/4.png"></p><p>3.<code>func(参数1, 参数2 ,参数3 ) ;</code> 这一条语句在汇编语言中会被翻译成为<code>call func</code><br>而在执行<code>call func</code>之前程序会执行一些<code>push指令</code>将func函数的<code>参数1,2,3</code>分别压入栈中<br>也就是<code>push 参数3</code>  <code>push 参数2</code>  <code>push 参数1</code> 这三条指令。执行完之后那么栈的内容会变成这样:<br><img src="/../picture/pwn1.1.2/5.png"></p><p>4.然后参数到位了就可以执行<code>call func</code>了。<br>而<code>call func</code>这个指令其实可以近似理解成<code>push eip + jmp func_addr</code>这两个指令的组合<br>如下图执行<code>call func</code>前后栈和<code>eip指针</code>的情况<br><img src="/../picture/pwn1.1.2/6.png"><br>当然图中的代码段是我自己猜测的，不够准确，因为本文的目的是介绍函数调用的过程，所以没有考虑过多只是希望尽可能简单的将整个过程讲解清楚。</p><p>5.我们已经知道了执行<code>call func</code>之后的<code>栈</code>和<code>eip</code>的位置<br>然后我们介绍一下每个函数开头的初始化<code>push ebp</code>和<code>mov ebp, esp</code><br>执行 <code>push ebp</code> 之后<br><img src="/../picture/pwn1.1.2/7.png"><br>执行 <code>mov ebp, esp</code> 之后<br><img src="/../picture/pwn1.1.2/8.png"><br>我们可以看到执行了<code>mov ebp, esp</code>之后<code>ebp指针</code>和<code>esp指针</code>指向了同一个地址，也就是<code>ebp 旧值</code> 所在的位置</p><p>6.在上一步中我们的<code>esp</code>和<code>ebp</code>处于同一个位置，然后我们需要执行<code>sub esp, 0x??</code>(这里打?是因为我不知道具体应该减去多少),这个<code>sub指令</code>在这里的作用是将<code>esp</code>向下移动，用于开出新函数所需要的栈帧，执行之后如下图:<br><img src="/../picture/pwn1.1.2/9.png"></p><p>7.最后我们直接来看func函数的最后一条<code>leave指令</code><br><code>leave指令</code>是<code>mov esp，ebp</code>和<code>pop ebp</code>的结合<br>我们来一条一条的看，先看 <code>mov esp, ebp</code> 执行之后的效果<br><img src="/../picture/pwn1.1.2/10.png"><br>这条指令会重新将<code>esp</code>和<code>ebp</code>移动到同一个位置<br>然后再来看 <code>pop ebp</code> 执行之后的效果<br><img src="/../picture/pwn1.1.2/11.png"><br>我们发现此时<code>ebp</code>回到<code>最初在main函数中它的位置</code>，而<code>esp</code>因为<code>pop</code>会向上移动一格位置，来到了<code>eip旧地址储存的位置</code>(这是后面会提到的栈溢出的关键部分)</p><p>8.紧接着我们就会执行<code>ret指令</code>，这个<code>ret指令</code>的作用相当于 <code>pop eip</code> 也就是将<code>esp</code>现在指向的值，赋值给<code>eip</code>，执行完这个语句之后，我们来看看eip在哪。如图:<br><img src="/../picture/pwn1.1.2/12.png"><br>我们可以看到，<code>栈</code>一切都回到了<code>call func</code> 这个指令执行之前，只有<code>eip</code>的位置改变了，仿佛它从没来过…</p><p>到此为止<code>32位程序</code>函数的调用以及栈的变化就结束了，可以得到一个结论就是<code>函数调用前后，栈内状况不变</code>。其实这非常好理解，因为在一个函数中调用另外一个函数当然不能影响原函数的运行，所以<code>栈</code>的设计做到了<code>用完就丢</code>。被调用函数结束后<code>esp</code>和<code>ebp</code>的位置都会回到<code>call</code>这个指令之前的状态，而<code>esp</code>和<code>ebp</code>之间的数据也都没有改变<br>上述结论在<code>64位</code>中同样适用，而<code>64位程序</code>和<code>32位程序</code>除了位数上不同，最大的不同就在于<code>64位程序</code>会优先将<code>被调用函数的参数</code>存放在寄存器中</p><p>这是32位函数调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> )</span> &#123;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> ) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../picture/pwn1.1.2/5.png"></p><p>而这是64位函数调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span>, 参数<span class="hljs-number">4</span>, 参数<span class="hljs-number">5</span> ,参数<span class="hljs-number">6</span>, 参数<span class="hljs-number">7</span>, 参数<span class="hljs-number">8</span>)</span> &#123;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span>, 参数<span class="hljs-number">4</span>, 参数<span class="hljs-number">5</span> ,参数<span class="hljs-number">6</span>, 参数<span class="hljs-number">7</span>, 参数<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在64位程序中，函数的参数会依次放入<code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code> <code>r8</code> <code>r9</code> 这六个寄存器中，只有把这六个寄存器塞满后，才会<code>从右到左</code>依次放入<code>栈</code>中，像上面的代码，<code>func函数</code>有<code>8个参数</code>，那么就如图所示:<br><img src="/../picture/pwn1.1.2/13.png"><br><code>注意:64位所用的是位数更多更大的RSP和RBP</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实程序本身的流程并不困难，只是初学者对汇编语言的了解较少所以难以理解，如果对于文章内容难以理解，不妨寻找一些汇编语言的教程较为系统的了解汇编语言也许会有所帮助</p><p>(制作图片用的是win11自带的画图工具，里面的字体大小不知道为什么调节不了，所以出现了字体很小的情况，<code>(。・＿・。)ﾉI’m sorry~</code>)</p><p>参考文献:<br><a href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） (yuque.com)</a><br><a href="https://segmentfault.com/a/1190000007977460">linux - C函数调用过程原理及函数栈帧分析 - 编程之道 - SegmentFault 思否</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之PWN入门(1.1.3)Linux基础操作和ELF文件保护</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.3)Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%92%8CELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.3)Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%92%8CELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<p>这里不讨论Linux的历史及其与Windows的比较。直接介绍一些简单基础的操作。<br>首先我们需要安装一个<code>Linux操作系统</code>(首先推荐<code>Ubuntu</code>),我们需要安装一个<code>VM虚拟机</code>，然后在里面搭建一个<code>Ubuntu的虚拟机</code></p><p>可以直接百度搜索，这里推荐一个文章<br><a href="https://blog.csdn.net/weixin_74195551/article/details/127288338?spm=1001.2014.3001.5506">安装虚拟机（VMware）保姆级教程（附安装包）_vmware虚拟机-CSDN博客</a><br>根据教程你可以成功安装Ubuntu虚拟机之后<br>第一件事情不是配置PWN环境，而是更换源<br><a href="https://blog.csdn.net/qq_35451572/article/details/79516563?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522C417D98E-60DB-4469-AA06-8C11B6684DE7%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=C417D98E-60DB-4469-AA06-8C11B6684DE7&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79516563-null-null.142%5Ev100%5Econtrol&utm_term=ubuntu%E6%8D%A2%E6%BA%90&spm=1018.2226.3001.4187">Ubuntu 更换国内源_ubuntu换源-CSDN博客</a><br>然后按照顺序安装<code>GCC --&gt; python3 --&gt; VMtools</code><br>然后进行PWN虚拟机的安装:<br><a href="https://hollk.blog.csdn.net/article/details/118188924?spm=1001.2014.3001.5502">https://hollk.blog.csdn.net/article/details/118188924?spm=1001.2014.3001.5502</a><br>PWN的大部分工具需要从github上下载，请确保你的网络能够顺利连接github，建议<code>科学上网</code>，否则下载成功与否只能看运气…</p><p>当然,如果你感觉很麻烦，我已经安装好了一个Ubuntu22的虚拟机，下面提供百度网盘链接:<br>通过网盘分享的文件：VM22XiDP_ovf<br>链接: <a href="https://pan.baidu.com/s/1NYJ7NywYab6LUC_kZgRxPQ?pwd=xidp">https://pan.baidu.com/s/1NYJ7NywYab6LUC_kZgRxPQ?pwd=xidp</a><br>提取码: xidp </p><p>虚拟机密码:<br><code>用户xidp</code> :密码  <code>xidpxidp..</code><br><code>用户root</code> :密码  <code>xidpxidp..</code></p><p>虚拟机可能存在bug，可以在<code>github</code>上向我留言,如果有需要添加的工具也可以留言:<a href="https://github.com/XiDP0/Pwn-Ubuntu22">XiDP0&#x2F;Pwn-Ubuntu22 (github.com)</a></p><ol><li><p><strong>查看当前目录</strong>：</p><ul><li><code>pwd</code>：打印当前工作目录路径。</li><li><img src="/../picture/pwn1.1.3/pwd.png"></li></ul></li><li><p><strong>列出目录内容</strong>：</p><ul><li><code>ls</code>：列出当前目录的文件和文件夹。</li><li><code>ls -l</code>：显示详细信息。</li><li><code>ls -a</code>：显示所有文件，包括隐藏文件。</li><li><img src="/../picture/pwn1.1.3/ls.png"></li></ul></li><li><p><strong>切换目录</strong>：</p><ul><li><code>cd 目录名</code>：进入指定目录。</li><li><code>cd ..</code>：返回上级目录。</li><li><img src="/../picture/pwn1.1.3/cd.png"></li></ul></li><li><p><strong>创建文件和目录</strong>：</p><ul><li><code>touch 文件名</code>：创建空文件。</li><li><code>mkdir 目录名</code>：创建新目录。</li></ul></li><li><p><strong>删除文件和目录</strong>：</p><ul><li><code>rm 文件名</code>：删除文件。</li><li><code>rm -r 目录名</code>：递归删除目录及其内容。</li></ul></li><li><p><strong>移动和重命名文件</strong>：</p><ul><li><code>mv 源文件 目标</code>：移动或重命名文件或目录。</li></ul></li><li><p><strong>复制文件和目录</strong>：</p><ul><li><code>cp 源文件 目标</code>：复制文件。</li><li><code>cp -r 源目录 目标</code>：递归复制目录。</li></ul></li><li><p><strong>查看文件内容</strong>：</p><ul><li><code>cat 文件名</code>：显示文件内容。</li><li><code>less 文件名</code>：分页查看文件内容，适合查看长文件。</li></ul></li><li><p><strong>编辑文件</strong>：</p><ul><li><code>nano 文件名</code> 或 <code>vim 文件名</code>：使用nano或vim编辑文件。</li></ul></li><li><p><strong>查找文件</strong>：</p><ul><li><code>find /路径 -name 文件名</code>：在指定路径下查找文件。</li></ul></li><li><p><strong>显示系统信息</strong>：</p><ul><li><code>uname -a</code>：显示系统信息。</li><li><code>top</code>：查看当前运行的进程和系统资源使用情况。</li></ul></li><li><p><strong>查看和管理进程</strong>：</p><ul><li><code>ps aux</code>：列出所有进程。</li><li><code>kill 进程ID</code>：终止指定进程。</li></ul></li><li><p><strong>清空当前页面</strong>：</p><ul><li><code>clear</code></li></ul></li><li><p><strong>获取管理员权限</strong>：</p><p>第一次登入的时候你会发现你没有设置root权限</p><ul><li><code>sudo +命令</code>：以超级用户权限执行命令。<code>sudo</code> 允许普通用户临时获取管理员权限来执行特定任务。</li><li><code>sudo root</code>：输入密码后成为高级用户(输入的密码是看不见的)。</li></ul></li><li><p><strong>输入文本内容</strong>：</p><ul><li><code>cat</code>：显示文件内容</li><li><img src="/../picture/pwn1.1.3/cat.png"></li></ul></li></ol><p>(为什么只放四个图? 因为我懒…)</p><p>接下来重点讲解ELF文件的保护有哪些:</p><h3 id="ELF文件保护"><a href="#ELF文件保护" class="headerlink" title="ELF文件保护"></a>ELF文件保护</h3><p>Linux ELF文件的保护主要有四种:<br>Canary<br>NX<br>PIE<br>RELRO<br>分别用于应付不同的漏洞,同时后面我们也会学习绕过它们的方法,下面让我们来分别了解它们的工作原理和起到的保护作用</p><h4 id="1-Canary"><a href="#1-Canary" class="headerlink" title="1.Canary"></a>1.Canary</h4><p><code>Canary</code>是金丝雀的意思。技术上表示最先的测试的意思。<br>这个来自以前挖煤的时候，矿工都会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以大家都用Canary来搞最先的测试。</p><p><code>Linux的Canary</code>指的是在<code>ebp/rbp旧值之前</code>添加的一串随机数(不超过机械字长)(也叫做cookie)，<code>当程序会在执行到此处的时候会检测Canary的值是否和刚开始的一样，如果出现缓冲区溢出攻击，覆盖到了Canary(也就是Canary的值发生了改变)，系统检测到Canary的值发生了变化，那么程序会立马崩溃，以防止被篡改的程序执行奇怪的东西</code></p><p>而<code>Canary</code>的末位一定是<code>\x00</code>。<code>\x00</code>是一个用于表示字符串结束的符号，也就是说类似<code>puts函数</code>这类函数输出字符串的时候遇到<code>\x00</code>就会停止继续输出(同样<code>strcpy函数</code>复制字符串的时候遇到<code>\x00</code>也会停止,后面会讲到这个<code>\x00</code>也有不同的用法可以绕过一些检测)。</p><p>之所以<code>Canary</code>的<code>末位</code>添加<code>\x00</code>是因为计算机往往是<code>小端程序</code>。比如:<br><code>Canary</code>是<code>0x1122334455667700</code>。<br>那么在计算机中储存的时候它是:<code>\x00\x77\x66\x55\x44\x33\x22\x11</code>这样储存的<br>那么<code>\x00</code>就在内存的开头了，当<code>Canary</code>前面有字符串需要输出的时候，一直到<code>Canary</code>的<code>\x00</code>就会停下。这使得<code>Canary</code>不会被输出，以此保护<code>Canary</code>不泄露(之后我们会讲到一种绕过<code>Canary</code>的方法就是尝试覆盖掉这个<code>\x00</code>让<code>Canary</code>被<code>puts</code>之类的函数输出)</p><p>GCC开启Canary和关闭Canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o test test.c <span class="hljs-comment">// 默认情况下，不开启Canary保护</span><br>gcc -fno-<span class="hljs-built_in">stack</span>-protector -o test test.c <span class="hljs-comment">//禁用栈保护</span><br>gcc -fstack-protector -o test test.c <span class="hljs-comment">//启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br>gcc -fstack-protector-all -o test test.c <span class="hljs-comment">//启用堆栈保护，为所有函数插入保护代码</span><br>-fno-<span class="hljs-built_in">stack</span>-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)<br></code></pre></td></tr></table></figure><p>Canary所在的位置和GCC编译器以及系统有关:<br>下面以Ubuntu系统举例:<br><img src="/../picture/pwn1.1.3/aaa.png"><br><code>注意</code>:前面的文章中我制作的图片都是使用<code>上面为高地址，下面为低地址</code>(因为初学者都相对自然的认为<code>上高下低</code>),但是此处我采用了<code>上低下高</code>。因为在后续我们做PWN题目的时候使用gdb调试,在gdb中查看<code>栈</code>，栈中的内容是<code>上低下高</code>的，图中所看到的情况也符合我们即将在gdb中看到的情况。所以为了让大家能够适应后续的gdb调试这里使用了<code>上低下高</code>，</p><p>所以总的来说,对于Ubuntu来说，32为程序的Canary一般在 <code>ebp - 0xc</code> 的地方(32位的一格是0x4，也就是在ebp的上面3格)。而 64位的Canary则是在 <code>rbp - 0x8</code> 的位置(64位的一格是0x8，也就是在ebp的上面1格，他们相邻)</p><h4 id="2-NX保护"><a href="#2-NX保护" class="headerlink" title="2.NX保护"></a>2.NX保护</h4><p><code>NX</code>即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行。</p><p>这个保护有什么用呢?<br>我们都知道程序分为<code>代码段</code>和<code>数据段</code>，代码段用于执行，数据段用于存储数据，那么我们可以在数据段写入一些代码吗?答案是可以的，但是程序执行什么由ip指针说了算，ip指哪就运行什么。那如果我们在数据段写入我们想要的代码，然后再想个办法把ip指针骗过来了呢?<br>这样就像银行卡里的数字自己可以改一样，非常逆天(后续我们会学到，这种逆天的攻击方法叫ret2shellcode,但是开启NX之后几乎就无效了)。<br>所以有了NX保护，它的任务就是让<code>数据段</code>坚决不能执行(在<code>Ubuntu20</code>版本之后，系统默认了数据段就是无法执行的，哪怕没有开启<code>NX</code>也不能执行数据段里面的东西)</p><p>GCC开启和关闭NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o test test.c <span class="hljs-comment">// 默认情况下，开启NX保护</span><br>gcc -z execstack -o test test.c <span class="hljs-comment">// 禁用NX保护</span><br>gcc -z noexecstack -o test test.c <span class="hljs-comment">// 开启NX保护</span><br>-z execstack / -z <span class="hljs-title function_">noexecstack</span> <span class="hljs-params">(关闭 / 开启)</span><br></code></pre></td></tr></table></figure><h4 id="3-PIE与ASLR"><a href="#3-PIE与ASLR" class="headerlink" title="3.PIE与ASLR"></a>3.PIE与ASLR</h4><p>从我个人认为PIE与ASLR是非常麻烦的保护,它们的作用是让<code>地址空间分布随机化</code></p><p><strong>ASLR（libc地址随机化）</strong><br><code>ASLR</code>（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置，从而增加了利用软件漏洞进行攻击的难度。 <code>开启不同等级会有不同的效果</code>：</p><ol><li><code>内存布局随机化</code>： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。 ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和 代码的位置。 </li><li><code>地址空间范围的随机化</code>： ASLR还会随机化进程的地址空间范围。在<code>传统的地址空间</code>中，栈、 堆、代码段和数据段通常会被<code>分配到固定的地址</code>范围中。ASLR会随机选择地址空间的起始位置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。 </li><li><code>随机偏移量</code>： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发现这些偏移量，才能准确地定位和利用漏洞。</li><li><code>堆和栈随机化</code>： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起 始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置， 使得攻击者无法轻易地覆盖返回地址或控制程序流程。</li></ol><p>和PIE不同，PIE用于随机化代码段和数据段，ASLR用于将libc库以及堆栈的地址随机化。而ASLR是Linux系统本身提供的保护机制。<br>Linux下的ASLR分为三个级别，0,1,2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">0</span>：就是关闭ASLR，没有随机化，堆栈地址每次都相同，并且libc.so的每次地址也都相同<br><span class="hljs-number">1</span>：就是普通ASLR，mmap基地址、栈基地址、.so加载地址都将被随机化，但是堆并没有被随机化<br><span class="hljs-number">2</span>：就是增强ASLR，比起<span class="hljs-number">1</span>增加了堆随机化<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 可以查看Linux系统里面ASLR的强度等级</span><br>cat /proc/sys/kernel/randomize_va_space<br><span class="hljs-comment">// 可以改变ASLR等级,可能会遇到权限问题</span><br>echo <span class="hljs-number">0</span> &gt; /proc/sys/kernel/randomize_va_space<br><span class="hljs-comment">// 如果遇到权限问题，可以su root之后再执行</span><br><span class="hljs-comment">// 或者尝试下面这两条指令</span><br>sudo -s echo <span class="hljs-number">0</span> &gt; /proc/sys/kernel/randomize_va_space<br>sudo bash -c <span class="hljs-string">&#x27;echo 0 &gt; /proc/sys/kernel/randomize_va_space&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>PIE</strong><br>PIE能够使得程序像共享库一样在主存的任何位置装载，在需要将程序编译成位置无关<br>开放后code与data会随着ASLR变化地址<br><code>IDA</code>以及<code>gdb</code>执行的时候就只能看到地址后面的<code>末尾三位数</code></p><p>GCC开启和关闭PIE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o test test.c <span class="hljs-comment">// 默认情况下，不开启PIE</span><br>gcc -fpie -pie -o test test.c <span class="hljs-comment">// 开启PIE，此时强度为1</span><br>gcc -fPIE -pie -o test test.c <span class="hljs-comment">// 开启PIE，此时为最高强度2</span><br>gcc -fpic -o test test.c <span class="hljs-comment">// 开启PIC，此时强度为1，不会开启PIE</span><br>gcc -fPIC -o test test.c <span class="hljs-comment">// 开启PIC，此时为最高强度2，不会开启PIE</span><br>-no-pie / -pie (关闭 / 开启)<br></code></pre></td></tr></table></figure><h4 id="4-RELRO"><a href="#4-RELRO" class="headerlink" title="4.RELRO"></a>4.RELRO</h4><p><code>Relocation Read-Only (RELRO)</code> 可以使程序某些部分成为只读的。<br>它分为两种：<code>Partial RELRO</code> 和 <code>Full RELRO</code>，即：部分RELRO 和 完全RELRO。</p><p><code>部分RELRO</code> 是 GCC 的默认设置，几乎所有的二进制文件都至少使用部分RELRO。这样仅仅只能防止全局变量上的缓冲区溢出从而覆盖 GOT。</p><p><code>完全RELRO</code> 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p><hr><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度应尽量减少可写的存储区域</p><p>RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial RELRO，就说明对<code>GOT表</code>具有<code>写权限</code></p><p>具体GOT和PLT表是什么，有什么用，将在ret2libc的前置章节中讲解</p><hr><blockquote><p>主要用来保护重定位表段对应数据区域，默认可写<br><code>Partial RELRO</code>：.got不可写，got.plt可写<br><code>Full RELRO</code>：.got和got.plt不可写<br>got.plt可以简称为got表</p></blockquote><p>GCC开启和关闭RELRO</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o test test.c <span class="hljs-comment">// 默认情况下，是Partial RELRO</span><br>gcc -z norelro -o test test.c <span class="hljs-comment">// 关闭，即No RELRO</span><br>gcc -z lazy -o test test.c <span class="hljs-comment">// 部分开启，即Partial RELRO</span><br>gcc -z now -o test test.c <span class="hljs-comment">// 全部开启</span><br>-z norelro / -z lazy / -z <span class="hljs-title function_">now</span> <span class="hljs-params">(关闭 / 部分开启 / 完全开启)</span><br></code></pre></td></tr></table></figure><h4 id="5-fortify"><a href="#5-fortify" class="headerlink" title="5.fortify"></a>5.fortify</h4><p><code>fortify</code>是轻微的检查，用于检查是否存在缓冲区溢出的错误。适用于程序采用大量的字符串或者内存操作函数，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;&gt;&gt; <span class="hljs-built_in">memcpy</span>():<br>描述：<span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *str1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *str2, <span class="hljs-type">size_t</span> n)</span><br>     从存储区str2复制n个字符到存储区str1<br>  参数：str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 <span class="hljs-type">void</span>* 指针<br>     str2 -- 指向要复制的数据源，类型强制转换为 <span class="hljs-type">void</span>* 指针<br>     n -- 要被复制的字节数<br>  返回值：该函数返回一个指向目标存储区 str1 的指针<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">memset</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">void</span> *<span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *str, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span><br>     复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符<br>  参数：str -- 指向要填充的内存块<br>     c -- 要被设置的值。该值以 <span class="hljs-type">int</span> 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式<br>     n -- 要被设置为该值的字节数<br>  返回值：该值返回一个指向存储区 str 的指针<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">strcpy</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">char</span> *<span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span><br>     把 src 所指向的字符串复制到 dest，容易出现溢出<br>  参数：dest -- 指向用于存储复制内容的目标数组<br>     src -- 要复制的字符串<br>  返回值：该函数返回一个指向最终的目标字符串 dest 的指针<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">stpcpy</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">stpcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest,<span class="hljs-type">char</span> *src)</span><br>     把src所指由<span class="hljs-literal">NULL</span>借宿的字符串复制到dest所指的数组中<br>  说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串返回指向dest结尾处字符（<span class="hljs-literal">NULL</span>）的指针 <br>  返回值：<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">strncpy</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">char</span> *<span class="hljs-title function_">strncpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span><br>     把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充<br>  参数：dest -- 指向用于存储复制内容的目标数组<br>     src -- 要复制的字符串<br>     n -- 要从源中复制的字符数<br>  返回值：该函数返回最终复制的字符串<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">strcat</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">char</span> *<span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span><br>     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾<br>  参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串<br>     src -- 指向要追加的字符串，该字符串不会覆盖目标字符串<br>  返回值：<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">strncat</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">char</span> *<span class="hljs-title function_">strncat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span><br>     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止<br>  参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符<br>     src -- 要追加的字符串<br>     n -- 要追加的最大字符数<br>  返回值：该函数返回一个指向最终的目标字符串 dest 的指针<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">sprintf</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-title function_">sprintf</span><span class="hljs-params">(format,arg1,arg2,arg++)</span><br>     arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推<br>  参数：format -- 必需。规定字符串以及如何格式化其中的变量<br>     arg1 -- 必需。规定插到 format 字符串中第一个 % 符号处的参<br>     arg2 -- 可选。规定插到 format 字符串中第二个 % 符号处的参数<br>     arg++ -- 可选。规定插到 format 字符串中第三、四等等 % 符号处的参数<br>  返回值：返回已格式化的字符串<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">snprintf</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">int</span> <span class="hljs-title function_">snprintf</span> <span class="hljs-params">( <span class="hljs-type">char</span> * str, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * format, ... )</span><br>     设将可变参数<span class="hljs-params">(...)</span>按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断<br>  参数：str -- 目标字符串<br>     size -- 拷贝字节数<span class="hljs-params">(Bytes)</span>如果格式化后的字符串长度大于 size<br>     format -- 格式化成字符串<br>  返回值：如果格式化后的字符串长度小于等于 size，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0。 如果格式化后的字符串长度大于 size，超过 size 的部分会被截断，只将其中的 <span class="hljs-params">(size<span class="hljs-number">-1</span>)</span> 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">vsprintf</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-title function_">vsprintf</span><span class="hljs-params">(format,argarray)</span> <br>     与 <span class="hljs-title function_">sprintf</span><span class="hljs-params">()</span> 不同，<span class="hljs-title function_">vsprintf</span><span class="hljs-params">()</span> 中的参数位于数组中。数组元素将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的<br>  参数：format -- 必需。规定字符串以及如何格式化其中的变量<br>     argarray -- 必需。带有参数的一个数组，这些参数会被插到 format 字符串中的 % 符号处<br>  返回值：以格式化字符串的形式返回数组值<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">vsnprintf</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">int</span> <span class="hljs-title function_">vsnprintf</span> <span class="hljs-params">(<span class="hljs-type">char</span> * s, <span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * format, va_list arg )</span><br>     将格式化数据从可变参数列表写入大小缓冲区<br>如果在<span class="hljs-built_in">printf</span>上使用格式，则使用相同的文本组成字符串，但使用由arg标识的变量参数列表中的元素而不是附加的函数参数，并将结果内容作为C字符串存储在s指向的缓冲区中 （以n为最大缓冲区容量来填充）。如果结果字符串的长度超过了n-1个字符，则剩余的字符将被丢弃并且不被存储，而是被计算为函数返回的值。在内部，函数从arg标识的列表中检索参数，就好像va_arg被使用了一样，因此arg的状态很可能被调用所改变。在任何情况下，arg都应该在调用之前的某个时刻由va_start初始化，并且在调用之后的某个时刻，预计会由va_end释放<br>  参数：s -- 指向存储结果C字符串的缓冲区的指针，缓冲区应至少有n个字符的大小<br>     n -- 在缓冲区中使用的最大字节数，生成的字符串的长度至多为n-1，为额外的终止空字符留下空，<span class="hljs-type">size_t</span>是一个无符号整数类型<br>     format -- 包含格式字符串的C字符串，其格式字符串与<span class="hljs-built_in">printf</span>中的格式相同<br>      arg -- 标识使用va_start初始化的变量参数列表的值<br>  返回值：如果n足够大，则会写入的字符数，不包括终止空字符。如果发生编码错误，则返回负数。注意，只有当这个返回值是非负值且小于n时，字符串才被完全写入<br>-----------------------------------------------------------------------<br>&gt;&gt;&gt; <span class="hljs-title function_">gets</span><span class="hljs-params">()</span>:<br>  描述：<span class="hljs-type">char</span> *<span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>     从标准输入 <span class="hljs-built_in">stdin</span> 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定<br>  参数：str -- 这是指向一个字符数组的指针，该数组存储了 C 字符串<br>  返回值：如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 <span class="hljs-literal">NULL</span> <br></code></pre></td></tr></table></figure><p>GCC开启和关闭fortify：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -D_FORTIFY_SOURCE=<span class="hljs-number">1</span>  仅仅只在编译时进行检查（尤其是<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>这种文件头）</span><br>gcc -D_FORTIFY_SOURCE=<span class="hljs-number">2</span>  程序执行时也会进行检查（如果检查到缓冲区溢出，就会终止程序）<br></code></pre></td></tr></table></figure><p>在-D_FORTIFY_SOURCE&#x3D;2时，通过对数组大小来判断替换strcpy、memcpy、memset等函数名，从而达到防止缓冲区溢出的作用</p><p>(最后这段直接复制了hollk师傅的博客内容)</p><p>到此我们讲完了ELF文件的常见保护。后续我们将从<code>ret2backdoor</code>开始讲解最最基础的PWN</p><p>参考文献:<br><a href="https://hollk.blog.csdn.net/article/details/105913071?spm=1001.2014.3001.5502">栈保护机制-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_44932880/article/details/104092620">linux elf保护机制_-no-pie-CSDN博客</a><br><a href="https://blog.csdn.net/RChaos/article/details/104344276">Pwn的常见保护介绍_pwn题打开nx保护有什么用吗-CSDN博客</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yfrste">PWN入门（1-1-3）-Linux ELF文件保护机制 (yuque.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之PWN入门(1.0.0)前言</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.0.0)%E5%89%8D%E8%A8%80/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.0.0)%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-PWN？"><a href="#什么是-PWN？" class="headerlink" title="什么是 PWN？"></a>什么是 PWN？</h3><p><code>PWN</code> 是黑客术语中的俚语，是指攻破设备或者系统。它的发音类似于<code>“砰”</code>，当然也有师傅把它叫作<code>“胖”</code>。PWN 的目标是获取系统的控制权或执行未经授权的操作。</p><h3 id="如何入门-PWN"><a href="#如何入门-PWN" class="headerlink" title="如何入门 PWN"></a>如何入门 PWN</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li><p><strong>C 语言</strong></p><ul><li><strong>学习内容</strong>：<ul><li>程序结构和基础语法</li><li>数据类型、分支语句（如 <code>if</code>、<code>switch</code>）和循环（如 <code>for</code>、<code>while</code>）</li><li>指针和结构体</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">浙江大学翁恺教你 C 语言程序设计</a></li><li><a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程 | 菜鸟教程</a></li></ul></li></ul></li><li><p><strong>Python 语言</strong></p><ul><li><strong>学习内容</strong>：<ul><li>程序结构和基础语法</li><li>循环（<code>for</code>、<code>while</code>）和异常处理（如 <code>try</code>）</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程 | 菜鸟教程</a></li><li><a href="https://www.bilibili.com/video/BV1944y1x7SW/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">超基础 Python 课程</a></li></ul></li></ul><p> <strong>建议</strong>：掌握 C 语言后，可以直接用文章进行 Python 的学习，进度会更快。 </p></li><li><p><strong>汇编语言</strong></p><ul><li><strong>常见类型</strong>：<ul><li><strong>x86 汇编</strong>：Intel 和 AMD 的处理器架构</li><li><strong>ARM 汇编</strong>：用于移动设备</li><li><strong>MIPS 汇编</strong>：用于嵌入式系统</li><li><strong>PowerPC 汇编</strong>：曾用于苹果计算机</li><li><strong>RISC-V 汇编</strong>：开源架构，逐渐获得关注</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.bilibili.com/video/BV1eG4y1S7R5/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">《汇编语言》速成指南</a></li><li><a href="https://www.bilibili.com/video/BV1Wu411B72F/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">通俗易懂的汇编语言（王爽老师的书）</a></li></ul></li></ul><p> <strong>基础要求</strong>：理解基本的汇编指令（如 <code>pop</code>、<code>push</code>、<code>jmp</code>）和程序流程即可。 </p></li><li><p><strong>ELF 相关知识</strong></p><ul><li><strong>学习内容</strong>：<ul><li>ELF 文件的组成部分</li><li>各部分的作用</li><li>常用的保护机制</li></ul></li><li><strong>学习资源</strong>：<br>  在后续文章中会有简单介绍</li></ul></li><li><p><strong>Linux 操作系统基础</strong></p><ul><li><strong>学习内容</strong>：<ul><li>基本的 Linux 命令（如 <code>cd</code>、<code>ls</code>、<code>cat</code>）</li><li>系统调用函数（如 <code>execve</code>）</li><li>glibc 库</li></ul></li><li><strong>学习资源</strong>：<br>  在后续文章中会有简单介绍</li></ul><p> <strong>基础要求</strong>：能够使用基本的 Linux 命令，了解系统调用函数和 glibc 库的基本知识。</p></li></ol><h4 id="工具和资源"><a href="#工具和资源" class="headerlink" title="工具和资源"></a>工具和资源</h4><ol><li><p><strong>虚拟机和操作系统</strong>：</p><ul><li><strong>建议</strong>：搭建一个 <code>Ubuntu</code> 虚拟机环境，以便调试和解决题目。</li><li>尽管大部分题目都使用Ubuntu环境，但这并不意味着你必须要使用 Ubuntu 作为你的主力操作系统 。你仍旧可以选择继续使用你喜欢的其他 Linux 发行版（如，Arch、Debian、openSUSE、Fedora、NixOS 等）然后使用 <code>Docker</code> 来模拟 <code>Ubuntu</code> 环境</li></ul></li><li><p><strong>工具</strong>：</p><ul><li><strong>IDA</strong>：逆向分析工具</li><li><strong>Python + pwntools</strong>：用于编写漏洞利用脚本</li><li><strong>gdb + pwndbg&#x2F;peda</strong>：用于调试二进制文件</li><li><strong>QEMU</strong>：有些题目需要它来模拟环境(对于基础入门并不是必须的工具)</li></ul><p> <strong>注意</strong>：入门阶段不需要配置复杂的环境，基础的调试和利用工具足够。</p></li></ol><h4 id="PWN-大致内容"><a href="#PWN-大致内容" class="headerlink" title="PWN 大致内容"></a>PWN 大致内容</h4><ul><li><strong>栈溢出与 ROP 链</strong>：理解栈溢出漏洞和如何利用返回-oriented programming（ROP）来绕过安全保护机制。</li><li><strong>格式化字符串</strong>：学习如何利用格式化字符串漏洞来进行攻击。</li><li><strong>整数安全</strong>：了解整数溢出等安全问题。</li><li><strong>堆漏洞利用</strong>：探索如何利用堆上的漏洞进行攻击。</li><li><strong>异架构</strong>：理解不同架构（如 x86、ARM）的特点和攻击方法。</li><li><strong>内核漏洞</strong>：深入研究内核漏洞 (可能这并不基础…)</li></ul><h3 id="做PWN题的大致流程"><a href="#做PWN题的大致流程" class="headerlink" title="做PWN题的大致流程"></a>做PWN题的大致流程</h3><p>这里使用buuctf中PWN板块的第二题<code>rip</code>为例子:<a href="https://buuoj.cn/challenges#rip">BUUCTF在线评测 (buuoj.cn)</a></p><h5 id="1-下载和启动靶机"><a href="#1-下载和启动靶机" class="headerlink" title="1. 下载和启动靶机"></a>1. 下载和启动靶机</h5><p>点开题目，里面会有一个可以下载的文件，以及<code>启动靶机</code>四个大字。如下图:<br><img src="/../picture/pwn1.0.0/1.png"></p><h5 id="2-将文件传入Linux虚拟机"><a href="#2-将文件传入Linux虚拟机" class="headerlink" title="2. 将文件传入Linux虚拟机"></a>2. 将文件传入Linux虚拟机</h5><p>打开Linux虚拟机,下载这个附件并将这个附件传入到Linux虚拟机中。此时我们可以看到这个附件叫<code>pwn1</code></p><h5 id="3-检查二进制文件的安全性和架构"><a href="#3-检查二进制文件的安全性和架构" class="headerlink" title="3. 检查二进制文件的安全性和架构"></a>3. 检查二进制文件的安全性和架构</h5><p>使用<code>checksec</code>工具(安装<code>pwntools</code>后就有了)去查看它的架构和位数以及保护开启的情况，这里因为是基础题所以什么保护都没有<br><img src="/../picture/pwn1.0.0/2.png"></p><h5 id="4-反编译和分析二进制文件"><a href="#4-反编译和分析二进制文件" class="headerlink" title="4. 反编译和分析二进制文件"></a>4. 反编译和分析二进制文件</h5><p>将文件拖动到IDA这类反编译工具中，对二进制文件进行反编译<br>下图中这个非常有魅力的女人头像的工具就是我们的IDA<br><img src="/../picture/pwn1.0.0/3.png"><br>刚刚我们通过<code>checksec</code>已经知道了<code>pwn1</code>他是64位的，那么就拖入64位的IDA中(其实如果你拖错了，IDA会提示你搞错了，所以<code>checksec</code>的主要功能是查看开启了什么保护)</p><p>拖入后会看到这个画面，直接<code>OK</code>就完事了<br><img src="/../picture/pwn1.0.0/4.png"><br>然后进入后，我们在左侧的Functions栏里面找到main函数并点击他<br><img src="/../picture/pwn1.0.0/5.png"><br>选中main函数后，按TAB键(一般在Q的左边)或者按F5键，此时就会显示<code>伪C语言代码</code><br><img src="/../picture/pwn1.0.0/6.png"></p><h5 id="5-理解代码和找出漏洞"><a href="#5-理解代码和找出漏洞" class="headerlink" title="5. 理解代码和找出漏洞"></a>5. 理解代码和找出漏洞</h5><p>看懂代码(需要学习C语言)，找出漏洞(需要学习相关的PWN知识),编写python脚本(需要学习python语言和使用pwntools等库)<br>pwntools的使用后续会进行介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#PWN1 exp</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-comment">#io = process(&#x27;./pwn1&#x27;) # 本地</span><br>io = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28735</span>)<br><br>payload = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">15</span><br>payload +=p64(<span class="hljs-number">0x401186</span>)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>这里我编写了python脚本，并将其命名为<code>exp.py</code></p><h5 id="6-创建靶机并运行脚本尝试攻击"><a href="#6-创建靶机并运行脚本尝试攻击" class="headerlink" title="6. 创建靶机并运行脚本尝试攻击"></a>6. 创建靶机并运行脚本尝试攻击</h5><ul><li>**使用<code>nc</code>**：用<code>nc</code>命令连接靶机（如<code>nc node5.buuoj.cn 28735</code>）进行测试。<ul><li><strong>测试脚本</strong>：将脚本中的地址和端口替换为靶机提供的实际地址和端口。</li><li><strong>检查结果</strong>：确认脚本是否能正确获取flag，解决<code>EOF</code>错误的问题。</li></ul></li></ul><p>点击<code>启动靶机</code><br><img src="/../picture/pwn1.0.0/7.png"><br>会得到一串nc地址，这个可以在Linux中使用<code>nc</code>工具进行连接<br><img src="/../picture/pwn1.0.0/8.png"><br>这里我们使用python脚本去攻击它的时候，需要将其放入python脚本中<br>比如:<code>io = remote(&#39;node5.buuoj.cn&#39;,28735)</code><br>我们尝试运行这个脚本<br><img src="/../picture/pwn1.0.0/9.png"><br>然后输入指令cat flag就可以拿到我们想要的东西了，复制flag去平台提交即可<br><img src="/../picture/pwn1.0.0/10.png"></p><p>如果没有打通的话会输出提示<br><code>[*] Got EOF while reading in interactive</code><br>表示连接断开了，此时你输入cat flag是没有用的<br><img src="/../picture/pwn1.0.0/11.png"></p><h3 id="刷题平台推荐"><a href="#刷题平台推荐" class="headerlink" title="刷题平台推荐"></a>刷题平台推荐</h3><p><a href="https://buuoj.cn/challenges">BUUCTF在线评测 (buuoj.cn)</a><br><a href="https://www.nssctf.cn/problem">题库 | NSSCTF</a><br><a href="https://pwn.college/fundamentals/program-misuse">pwn.college</a><br><a href="https://ctf.show/challenges#">ctf.show</a></p><p>其中<code>ctfshow</code>大部分题目是收费的，但是里面的题目较为系统化，从简单到困难，因此我个人比较推荐</p><p>学习PWN是非常漫长的过程，需要学习大量知识，以及进行大量的练习。许多难以理解的问题可能很长一段时间都无法得到解决，复杂的漏洞利用也常常想让人放弃。所以在文章的最后我想分享翁恺老师的一段话:<code>“计算机里的所有东西都是人做出来的，别人能想的出来的，我也一定能想的出来。在计算机里头没有任何黑魔法。所有的东西只是我现在还不知道而已，总有一天我会把所有细节所有内部的东西全都搞明白。”</code></p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><a href="https://ns.openctf.net/learn/pwn.html#elf-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">Pwn | 快速入门 - NewStar CTF</a></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/#peda">Environment - CTF Wiki (ctf-wiki.org)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之PWN入门(1.1.1)汇编语言基础与堆栈入门</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.1)%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A0%86%E6%A0%88%E5%85%A5%E9%97%A8/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.1)%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A0%86%E6%A0%88%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="啥是汇编语言-有啥用"><a href="#啥是汇编语言-有啥用" class="headerlink" title="啥是汇编语言?有啥用?"></a>啥是汇编语言?有啥用?</h3><p>深入了解计算机底层，我们会发现，计算机实际上只能执行一些非常基础的操作，但其速度却非常快。计算机的CPU只能执行机器码，即由一系列0和1组成的指令。不同的0和1组合会触发计算机中的不同电路，从而进行各种操作。由于这些0和1的组合很长，阅读起来不方便，因此通常以16进制形式显示。然而，即便如此，16进制的表示仍然难以理解。为了简化这一过程，汇编语言应运而生，它用更易读的符号来表示这些机器指令，从而使程序员能够更方便地编写和理解代码。</p><h3 id="啥是寄存器"><a href="#啥是寄存器" class="headerlink" title="啥是寄存器?"></a>啥是寄存器?</h3><p>计算机中的所有指令都是由CPU执行的。在计算机结构中，CPU和内存是分开的，而寄存器则位于CPU内部。CPU可以直接访问寄存器中的数据来执行各种指令操作。在程序执行过程中，数据通常从内存 –&gt; 缓存（cache）–&gt; 寄存器，只有到了寄存器中CPU才能对其进行处理。处理完成后，程序决定是否将寄存器中的数据写回内存，以更新内存中的内容。除了存储数据，寄存器还可以用于存储指令、地址、状态信息和其他控制数据。因此，寄存器在计算机中发挥着至关重要的作用，帮助提高处理速度和效率。<br>下图表介绍一些常用的寄存器<br><img src="/../picture/pwn1.1.1/2.png"></p><h3 id="什么是栈-什么是堆"><a href="#什么是栈-什么是堆" class="headerlink" title="什么是栈?什么是堆?"></a>什么是栈?什么是堆?</h3><p>先贴一张图用来理清楚堆和栈在程序中的位置<br><img src="/../picture/pwn1.1.1/1.png"></p><h5 id="栈的简单介绍"><a href="#栈的简单介绍" class="headerlink" title="栈的简单介绍"></a>栈的简单介绍</h5><p>在计算机程序运行时，系统会将可执行文件的<code>text段</code>（代码段）和<code>data段</code>（数据段）加载到内存中。在C语言等编程语言中，函数调用过程中需要<code>传递参数</code>并<code>创建局部变量</code>。如果这些数据都存储在<code>data段</code>或<code>bss段</code>中，会导致内存空间的浪费，并使得管理变得复杂。<br>为了高效管理函数的参数和局部变量，并在<code>函数调用结束后释放相关资源</code>，我们使用了<strong>栈</strong>。<strong>栈</strong>是一种<code>后进先出（LIFO）</code>的数据结构，它能够在函数调用时创建栈帧来存储函数的局部变量、参数、返回地址等信息。当函数调用结束时，栈帧会被自动销毁，从而释放内存，避免内存浪费。栈不仅节省内存，还确保了函数调用和返回过程的有序进行。</p><p><code>ESP</code>（栈指针）和 <code>EBP</code>（基址指针）之间的空间被称为<code>栈帧</code>。<code>栈帧</code>是一个函数调用的<code>栈上空间</code>，主要用于<code>存储函数的局部变量</code>、<code>参数</code>、<code>返回地址</code>以及<code>保存的寄存器状态</code>等信息。在每次函数调用时，都会为该函数分配一个新的栈帧，并在<code>函数执行完成后释放这个栈帧</code>。栈帧的结构通常如下：</p><ul><li>**栈顶 (由 <code>ESP</code> 指针指向)**：函数调用时，栈顶包含函数的局部变量和临时数据。</li><li>**栈底 (由 <code>EBP</code> 指针指向)**：栈底用于存储函数调用的参数和返回地址等。</li></ul><p><code>栈帧</code>的设计使得函数调用和返回变得高效，并且支持递归调用等复杂的函数调用模式。</p><h5 id="堆的简单介绍"><a href="#堆的简单介绍" class="headerlink" title="堆的简单介绍"></a>堆的简单介绍</h5><p>堆是用于存放进程运行中动态分配的内存段，其大小可以在运行时根据需求调整。调用<code>malloc</code>、<code>calloc</code>或<code>realloc</code>等函数时，会从堆上分配内存。释放内存时使用<code>free</code>函数，以便回收堆内存。堆内存的管理由程序员负责，不会自动释放，需要手动管理内存的分配和释放。</p><h5 id="浅浅总结一下"><a href="#浅浅总结一下" class="headerlink" title="浅浅总结一下:"></a>浅浅总结一下:</h5><p><code>栈</code>用于存放各个函数所需要使用的参数，比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">30</span>];  <span class="hljs-comment">// str是一个局部变量，存储在栈上</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%29s&quot;</span>, str);  <span class="hljs-comment">// 读取字符串到str中</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);  <span class="hljs-comment">// 输出str的内容</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>str</code>是一个局部数组，分配在栈上。</p><p><code>堆</code>则是用于存放用户的数据，并且由用户决定什么时候释放它。比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 100</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_heap</span><span class="hljs-params">(<span class="hljs-type">char</span> **heap_memory)</span> &#123;<br>    *heap_memory = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(BUFFER_SIZE * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-keyword">if</span> (*heap_memory == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory allocation failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory created.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">edit_heap</span><span class="hljs-params">(<span class="hljs-type">char</span> *heap_memory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (heap_memory == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory not created yet.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a string to store in heap memory: &quot;</span>);<br>    fgets(heap_memory, BUFFER_SIZE, <span class="hljs-built_in">stdin</span>);<br><br>    heap_memory[<span class="hljs-built_in">strcspn</span>(heap_memory, <span class="hljs-string">&quot;\n&quot;</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory updated.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_heap</span><span class="hljs-params">(<span class="hljs-type">char</span> *heap_memory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (heap_memory == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory not created yet.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(heap_memory);<br>    heap_memory = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory deleted.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *heap_memory = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> choice;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nMenu:\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. Create heap memory\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. Edit heap memory\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. Delete heap memory\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter your choice: &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;choice);<br>        getchar();  <br><br>        <span class="hljs-keyword">switch</span> (choice) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                create_heap(&amp;heap_memory);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                edit_heap(heap_memory);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                delete_heap(heap_memory);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-keyword">if</span> (heap_memory != <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-built_in">free</span>(heap_memory);  <br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Exiting program.\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid choice. Please try again.\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(这里例子可能举的有点复杂…但是之后遇到的<code>堆</code>的题目大多也是类似这样的，所以堆的难度会比<code>栈</code>大很多，知识量也多很多)<br>总之上面的代码就是一般堆的用法，不需要理解，只是作为展示，大致内容如下:<br>输入1，用户可以<code>申请一个堆的空间</code>。<br>输入2，用户可以<code>编辑所申请到的空间</code>。<br>输入3，用户可以<code>删除申请到的空间</code>。</p><h3 id="常用汇编指令与C语言对比"><a href="#常用汇编指令与C语言对比" class="headerlink" title="常用汇编指令与C语言对比"></a>常用汇编指令与C语言对比</h3><ol><li><p><strong>MOV</strong></p><ul><li><strong>功能</strong>：将数据从一个位置复制到另一个位置。</li><li><strong>汇编</strong>：<code>MOV AX, 1234h</code></li><li><strong>C语言</strong>：<code>AX = 0x1234;</code></li><li><strong>说明</strong>：<code>MOV</code> 是把数据从源位置复制到目标位置，类似于C语言中的赋值操作。<code>MOV</code> 不改变源数据，只是复制到目标位置。</li></ul></li><li><p><strong>ADD &#x2F; SUB</strong></p><ul><li><strong>功能</strong>：进行加法和减法运算。</li><li><strong>汇编</strong>：<code>ADD AX, BX</code>（<code>AX = AX + BX</code>）；<code>SUB CX, 5</code>（<code>CX = CX - 5</code>）</li><li><strong>C语言</strong>：<code>AX += BX;</code>（<code>AX = AX + BX</code>）；<code>CX -= 5;</code>（<code>CX = CX - 5</code>）</li><li><strong>说明</strong>：<code>ADD</code> 和 <code>SUB</code> 用于对寄存器或内存中的值进行加减操作，更新结果并设置标志寄存器的状态。</li></ul></li><li><p><strong>INC &#x2F; DEC</strong></p><ul><li><strong>功能</strong>：递增或递减操作数。</li><li><strong>汇编</strong>：<code>INC AX</code>（<code>AX = AX + 1</code>）；<code>DEC BX</code>（<code>BX = BX - 1</code>）</li><li><strong>C语言</strong>：<code>AX++;</code>（<code>AX = AX + 1</code>）；<code>BX--;</code>（<code>BX = BX - 1</code>）</li><li><strong>说明</strong>：<code>INC</code> 和 <code>DEC</code> 只能对寄存器或内存位置操作，不能对立即数操作。</li></ul></li><li><p><strong>CMP</strong></p><ul><li><strong>功能</strong>：比较两个值，并设置标志寄存器状态。</li><li><strong>汇编</strong>：<code>CMP AX, BX</code>（<code>if (AX == BX)</code>）</li><li><strong>C语言</strong>：<code>if (AX == BX)</code>（<code>AX</code> 和 <code>BX</code> 比较）</li><li><strong>说明</strong>：<code>CMP</code> 实际上是做了 <code>AX - BX</code> 的操作然后判断是否等于0，更新状态标志。</li></ul></li><li><p><strong>JMP</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的地址。</li><li><strong>汇编</strong>：<code>JMP start</code></li><li><strong>C语言</strong>：<code>goto start;</code></li><li><strong>说明</strong>：<code>JMP</code> 改变程序的执行流，跳转到标记为 <code>start</code> 的位置。</li></ul></li><li><p><strong>JE &#x2F; JNE &#x2F; JZ &#x2F; JNZ</strong></p><ul><li><strong>功能</strong>：根据条件跳转到指定地址。</li><li><strong>汇编</strong>：<code>JE equal</code>（<code>if (zero flag) goto equal;</code>）；<code>JNE not_equal</code>（<code>if (not equal) goto not_equal;</code>）</li><li><strong>C语言</strong>：<code>if (flag == 0) goto equal;</code>（<code>JE</code> 跳转条件为零标志）；<code>if (flag != 0) goto not_equal;</code>（<code>JNE</code> 跳转条件为非零）</li><li><strong>说明</strong>：这些指令依据先前比较操作的结果决定是否跳转。</li></ul></li><li><p><strong>CALL &#x2F; RET</strong></p><ul><li><strong>功能</strong>：调用和返回函数。</li><li><strong>汇编</strong>：<code>CALL myFunction</code>（调用函数）；<code>RET</code>（返回函数）</li><li><strong>C语言</strong>：<code>myFunction();</code>（调用函数）；<code>return;</code>（从函数返回）</li><li><strong>说明</strong>：<code>CALL</code> 会保存当前的返回地址，并跳转到目标函数；<code>RET</code> 从栈中恢复返回地址并跳转回。</li></ul></li><li><p><strong>PUSH &#x2F; POP</strong></p><ul><li><strong>功能</strong>：压入或弹出栈数据。</li><li><strong>汇编</strong>：<code>PUSH AX</code>（压入栈）；<code>POP BX</code>（从栈中弹出）</li><li><strong>C语言</strong>：<code>stack.push(AX);</code>（假设有栈操作的C语言函数）；<code>BX = stack.pop();</code>（假设有栈操作的C语言函数）</li><li><strong>说明</strong>：<code>PUSH</code> 和 <code>POP</code> 操作栈，<code>PUSH</code> 将数据压入栈顶，<code>POP</code> 从栈顶弹出数据。</li></ul></li><li><p><strong>NOP</strong></p><ul><li><strong>功能</strong>：空操作，不产生任何效果。</li><li><strong>汇编</strong>：<code>NOP</code></li><li><strong>C语言</strong>：没有直接的C语言对应，可以理解为一个空的操作(或者可以理解成C语言的注释符号)。</li><li><strong>说明</strong>：<code>NOP</code> 通常用于占位或调试，不会改变程序状态。</li></ul></li><li><p><strong>LEA</strong></p><ul><li><strong>功能</strong>：加载有效地址，将计算得到的地址赋给寄存器。</li><li><strong>汇编</strong>：<code>LEA AX, [BX+SI]</code></li><li><strong>C语言</strong>：<code>AX = &amp;array[BX + SI];</code>（假设 <code>array</code> 是一个数组）</li><li><strong>说明</strong>：<code>LEA</code> 计算一个地址并将其存入寄存器，类似于获取指针地址而不实际访问内存。</li></ul></li><li><p><strong>AND &#x2F; OR &#x2F; XOR &#x2F; NOT</strong></p><ul><li><strong>功能</strong>：按位操作。</li><li><strong>汇编</strong>：<code>AND AX, BX</code>（按位与）；<code>OR AX, BX</code>（按位或）；<code>XOR AX, BX</code>（按位异或）；<code>NOT AX</code>（按位取反）</li><li><strong>C语言</strong>：<code>AX = AX &amp; BX;</code>（按位与）；<code>AX = AX | BX;</code>（按位或）；<code>AX = AX ^ BX;</code>（按位异或）；<code>AX = ~AX;</code>（按位取反）</li><li><strong>说明</strong>：这些指令用于位级操作，<code>AND</code> 和 <code>OR</code> 用于逻辑运算，<code>XOR</code> 用于位翻转，<code>NOT</code> 对每一位取反。</li></ul></li></ol><p>这里重点介绍一下<code>PUSH</code> <code>POP</code> 这两个指令<br><code>PUSH</code>和<code>POP</code>是对<code>栈</code>进行操作的指令</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">我 是 栈 ↓<br>  ----<br> |<span class="hljs-string">  5 </span>|<span class="hljs-string">  &lt;- 栈底ebp:注意，我是栈底，我在高地址</span><br><span class="hljs-string">  ----</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  4 </span>|<br>  ----<br> |<span class="hljs-string">  3 </span>|<br>  ----<br> |<span class="hljs-string">  2 </span>|<br>  ----<br> |<span class="hljs-string">  1 </span>|<span class="hljs-string">  &lt;- 栈顶esp:注意，我是栈顶，我在低地址</span><br><span class="hljs-string">  ----</span><br><span class="hljs-string">假设这是栈最开始的样子</span><br><span class="hljs-string">假设：</span><br><span class="hljs-string">  eax = 6</span><br><span class="hljs-string">  ebx = 7</span><br></code></pre></td></tr></table></figure><p>我浅浅画了一个非常抽象的<code>栈</code>，但是这并不影响我们理解它。<br>当我们执行 <code>POP ebx</code> 这个指令后，那么就会让栈变成这个样子↓</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elm">我 是 栈 ↓<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">5</span> |  &lt;- 栈底ebp:我不动，与我无瓜<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">4</span> |<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">3</span> |<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">2</span> |  &lt;- 栈顶esp:执行完<span class="hljs-type">POP</span>后，我会向高地址移动，现在我指向<span class="hljs-number">2</span>了<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">1</span> |  &lt;-- <span class="hljs-number">1</span>没有消失，只是不在esp和ebp之间的栈帧了，这导致我们无法直接访问<br>  <span class="hljs-comment">----</span><br><br>  eax = <span class="hljs-number">6</span><br>  ebx = <span class="hljs-number">1</span> &lt;-- 注意注意，ebx变成<span class="hljs-number">1</span>了<br></code></pre></td></tr></table></figure><p>然后来看看<code>PUSH eax</code></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">我 是 栈 ↓<br>  ----<br> |<span class="hljs-string">  5 </span>|<span class="hljs-string">  &lt;- 栈底ebp:我还是不动，依旧与我无瓜</span><br><span class="hljs-string">  ----</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  4 </span>|<br>  ----<br> |<span class="hljs-string">  3 </span>|<br>  ----<br> |<span class="hljs-string">  2 </span>|<span class="hljs-string">  </span><br><span class="hljs-string">  ----</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  6 </span>|<span class="hljs-string">  &lt;- 栈顶esp:执行完PUSH后，我会向低地址地址移动，并且将eax的值，也就是6   </span><br><span class="hljs-string">  ----      放入栈当中，替换掉了1</span><br><span class="hljs-string">  </span><br><span class="hljs-string">  eax = 6</span><br><span class="hljs-string">  ebx = 1 </span><br></code></pre></td></tr></table></figure><h3 id="为什么函数调用需要用栈"><a href="#为什么函数调用需要用栈" class="headerlink" title="为什么函数调用需要用栈"></a>为什么函数调用需要用栈</h3><p>首先为什么<code>栈</code>是<code>后进先出(LIFO)</code>，这样的设计是因为程序的执行符合一种将复杂的大问题拆解成一个个小问题来解决的思想。<br>大问题的解决需要小问题的答案，而小问题得到答案之后就可以抛弃了。<br>比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// 如果需要使用标准输入输出函数</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> &#123;<br>    func1();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func3</span><span class="hljs-params">()</span> &#123;<br>    func2();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func3();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个程序的执行流程就是 <code>main --&gt; func1 --&gt; func2 --&gt; func3 --&gt; printf</code><br>那么栈的空间就是:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"> ---------------<br>|<span class="hljs-string"> main 的栈空间  </span>|<span class="hljs-string">  &lt;- 栈底 ebp(高地址)</span><br><span class="hljs-string"> ---------------</span><br><span class="hljs-string"></span>|<span class="hljs-string"> func1 的栈空间 </span>|<br> ---------------<br>|<span class="hljs-string"> func2 的栈空间 </span>|<br> ---------------<br>|<span class="hljs-string"> func3 的栈空间 </span>|<br> ---------------<br>|<span class="hljs-string"> printf 的栈空间</span>|<span class="hljs-string">  &lt;- 栈顶 esp(低地址)</span><br><span class="hljs-string"> ---------------</span><br></code></pre></td></tr></table></figure><p>我们得出规律，大问题函数程序总是最后消失<br>也就是<code>调用者</code>的生命周期总是长于<code>被调用者</code><br>这恰好符合了<code>栈</code>的<code>FILO</code>的特点。所以<code>栈</code>一定不是被随意设计的，而是一种完美符合计算机程序设计思想的一种数据结构</p><p>参考文献:<br><a href="https://www.cnblogs.com/tolin/p/14982094.html">什么是堆？什么是栈？他们之间有什么区别和联系？ - tolin - 博客园 (cnblogs.com)</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yom93l">PWN入门（1-1-2）-bss段、data段、text段、堆(heap)和栈(stack) (yuque.com)</a><br><a href="https://zhuanlan.zhihu.com/p/664901746">在x86架构中的寄存器 - 知乎 (zhihu.com)</a><br><a href="https://blog.csdn.net/qq_65596720/article/details/130743499">什么是栈，为什么函数式编程语言都离不开栈？_没有栈,都是跟栈有什么关系-CSDN博客</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） (yuque.com)</a><br><a href="https://segmentfault.com/a/1190000007977460">linux - C函数调用过程原理及函数栈帧分析 - 编程之道 - SegmentFault 思否</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟笔记之PWN入门(1.1.0)ELF 文件格式和程序段解析(简版)</title>
    <link href="/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.0)ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%A7%A3%E6%9E%90(%E7%AE%80%E7%89%88)/"/>
    <url>/2024/10/05/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.0)ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%A7%A3%E6%9E%90(%E7%AE%80%E7%89%88)/</url>
    
    <content type="html"><![CDATA[<p><strong>ELF (Executable and Linkable Format)</strong>: 是一种用于 <code>可执行文件</code>、<code>目标文件</code> 和 <code>库</code> 的文件格式，类似于 Windows 下的 <strong>PE</strong> 文件格式。</p><p>ELF 主要包括三种类型的文件：</p><ul><li><strong>可重定位文件 (relocatable)</strong>: 编译器和汇编器产生的 <code>.o</code> 文件，由 <strong>Linker</strong> 处理。</li><li><strong>可执行文件 (executable)</strong>: <strong>Linker</strong> 对 <code>.o</code> 文件进行处理后输出的文件，代表进程映像。</li><li><strong>共享对象文件 (shared object)</strong>: 动态库文件，通常是 <code>.so</code> 文件。</li></ul><p>ELF 文件包含多个段，每个段承担不同的作用。以下是一些入门级 PWN 可能需要用到的段（仅介绍这些基本段）：</p><ol><li><strong>.text</strong>: 用于保存程序中的代码片段。</li><li><strong>.data</strong>: 用于保存已经初始化的全局变量和局部变量。</li><li><strong>.bss</strong>: 用于保存未初始化的全局变量和局部变量。</li><li><strong>.plt</strong>: 用于链接和跳转到对应的 <strong>.got</strong> 表。</li><li><strong>.got.plt</strong>: 存储对应函数的真实地址的表。</li><li><strong>.rodata</strong>: 只读数据</li><li><strong>.init</strong>: 程序初始化和终止的代码</li></ol><p><img src="/../picture/pwn1.1.0/aaa.png"></p><p>ELF 文件中的段在程序执行前会被加载到内存中,然后在计算机内存中<br>一个程序可以认为由<code>bss段</code>、<code>data段</code>、<code>text段</code>三个部分组成的。<br><code>text段</code>和<code>data段</code>都存在可执行文件当中，程序执行时，系统从可执行文件中加载至内存<br>而<code>bss段</code>在可执行文件中只是一个符号用于占位，由系统根据其符号进行初始化</p><p>如何加载:<br><img src="/../picture/pwn1.1.0/ELF%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB2.png"></p><h3 id="text-段"><a href="#text-段" class="headerlink" title=".text 段"></a><strong>.text 段</strong></h3><ul><li><strong>代码段 (code segment)</strong>: 用来存放 <code>程序执行的代码</code>。</li><li>这个段的大小在程序执行之前就已经确定，因为编译好的程序代码量一般是固定的。</li><li>该段通常有读和执行权限，但一般禁止修改（当然，也有部分特殊架构允许修改代码段）。</li><li>在代码段中，可能也包含一些常数变量，例如字符串。</li></ul><h3 id="data-段"><a href="#data-段" class="headerlink" title=".data 段"></a><strong>.data 段</strong></h3><ul><li><strong>数据段 (data segment)</strong>: 用来存放已经 <code>初始化的全局变量</code>。</li><li>数据段属于静态内存分配，即被程序分配后大小不再改变。</li></ul><p><strong>例子</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> str[<span class="hljs-number">30</span>] = <span class="hljs-string">&quot;i_am_xidp_and_i_love_pwn&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，已经被赋值好的数据 <code>str</code> 会被放在 <strong>.data</strong> 段中。由于其大小是固定的，因此 <strong>.data</strong> 段中的数据也是固定大小的。</p><h3 id="bss-段"><a href="#bss-段" class="headerlink" title=".bss 段"></a><strong>.bss 段</strong></h3><ul><li><strong>bss 段 (bss segment)</strong>: 用于存放程序中未初始化的全局变量。</li><li>和 <strong>.data</strong> 段一样，属于静态内存分配。</li></ul><p><strong>例子</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> str[<span class="hljs-number">30</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>.bss</strong> 段本身不会占用 ELF 文件的实际大小，它在 ELF 等可执行文件中只是一个符号用于占位。程序执行时，会根据这个符号在计算机中分配相应的内存大小。</p><p><strong>数据区</strong>: <strong>.data</strong> 段和 <strong>.bss</strong> 段通常被称为数据区。</p><p>参考文献:<br><a href="https://www.cnblogs.com/QiQi-Robotics/p/15573352.html">Linux可执行文件格式-ELF结构详解 - 我叫平沢唯 - 博客园 (cnblogs.com)</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yom93l">PWN入门（1-1-2）-bss段、data段、text段、堆(heap)和栈(stack) (yuque.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
