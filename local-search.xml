<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.2)C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/"/>
    <url>/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.2)C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A0%88%E5%8F%98%E5%8C%96%EF%BC%8832%E4%BD%8D%20vs%2064%E4%BD%8D%EF%BC%89(Intel)/</url>
    
    <content type="html"><![CDATA[<p>本文使用Intel 的32位为例子进行举例。64位本质上和32位类似，主要区别在于函数参数的调用方式，文章结尾会简要提及。</p><p>重新回顾一下栈pop和push指令</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 将0x50的压入栈</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">0x50</span><br></code></pre></td></tr></table></figure><p>![[push0x50注释 1.png]]</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// 将<span class="hljs-built_in">esp</span>指向的数据放入指定的寄存器中<br><span class="hljs-keyword">pop</span> 寄存器名字<br>比如 ：<span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>执行之后<span class="hljs-built_in">eax</span>的值就变成了<span class="hljs-number">0x50</span><br></code></pre></td></tr></table></figure><p>![[pop寄存器注释.png]]</p><h3 id="栈帧是什么"><a href="#栈帧是什么" class="headerlink" title="栈帧是什么?"></a>栈帧是什么?</h3><p><code>栈帧</code>，也就是stack frame，<code>其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 ebp 指向栈底，也就是基址指针；用 esp 指向栈顶</code>，也就是栈指针。下面是一个栈帧的示意图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> )</span> &#123;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> ) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>![[函数调用顺序注释.png]]<br>我们来详细分析一下上面的这个图和那一小段代码</p><p>1.其实<code>main函数</code>只是我们作为程序员认为的程序的入口，实际上在<code>main函数</code>之前编译器还会添加很多函数比如<code>start函数</code>等等，所以<code>main函数</code>的栈帧之前还是有<code>栈帧</code>的</p><p>2.最开始进入到main函数中，还没有执行<code>func(参数1, 参数2 ,参数3 ) ;</code>这条代码的时候<br>![[参数调用1.png]]</p><p>3.<code>func(参数1, 参数2 ,参数3 ) ;</code> 这一条语句在汇编语言中会被翻译成为<code>call func</code><br>而在执行<code>call func</code>之前程序会执行一些<code>push指令</code>将func函数的<code>参数1,2,3</code>分别压入栈中<br>也就是<code>push 参数3</code>  <code>push 参数2</code>  <code>push 参数1</code> 这三条指令。执行完之后那么栈的内容会变成这样:<br>![[push放入参数.png]]</p><p>4.然后参数到位了就可以执行<code>call func</code>了。<br>而<code>call func</code>这个指令其实可以近似理解成<code>push eip + jmp func_addr</code>这两个指令的组合<br>如下图执行<code>call func</code>前后栈和<code>eip指针</code>的情况<br>![[call_func.png]]<br>当然图中的代码段是我自己猜测的，不够准确，因为本文的目的是介绍函数调用的过程，所以没有考虑过多只是希望尽可能简单的将整个过程讲解清楚。</p><p>5.我们已经知道了执行<code>call func</code>之后的<code>栈</code>和<code>eip</code>的位置<br>然后我们介绍一下每个函数开头的初始化<code>push ebp</code>和<code>mov ebp, esp</code><br>执行 <code>push ebp</code> 之后<br>![[push_ebp之后 1.png]]<br>执行 <code>mov ebp, esp</code> 之后<br>![[mov_ebp_esp 1.png]]<br>我们可以看到执行了<code>mov ebp, esp</code>之后<code>ebp指针</code>和<code>esp指针</code>指向了同一个地址，也就是<code>ebp 旧值</code> 所在的位置</p><p>6.在上一步中我们的<code>esp</code>和<code>ebp</code>处于同一个位置，然后我们需要执行<code>sub esp, 0x??</code>(这里打?是因为我不知道具体应该减去多少),这个<code>sub指令</code>在这里的作用是将<code>esp</code>向下移动，用于开出新函数所需要的栈帧，执行之后如下图:<br>![[sub_esp_0x 2.png]]</p><p>7.最后我们直接来看func函数的最后一条<code>leave指令</code><br><code>leave指令</code>是<code>mov esp，ebp</code>和<code>pop ebp</code>的结合<br>我们来一条一条的看，先看 <code>mov esp, ebp</code> 执行之后的效果<br>![[mov_esp_ebp 2.png]]<br>这条指令会重新将<code>esp</code>和<code>ebp</code>移动到同一个位置<br>然后再来看 <code>pop ebp</code> 执行之后的效果<br>![[pop_ebp.png]]<br>我们发现此时<code>ebp</code>回到<code>最初在main函数中它的位置</code>，而<code>esp</code>因为<code>pop</code>会向上移动一格位置，来到了<code>eip旧地址储存的位置</code>(这是后面会提到的栈溢出的关键部分)</p><p>8.紧接着我们就会执行<code>ret指令</code>，这个<code>ret指令</code>的作用相当于 <code>pop eip</code> 也就是将<code>esp</code>现在指向的值，赋值给<code>eip</code>，执行完这个语句之后，我们来看看eip在哪。如图:<br>![[ret之后.png]]<br>我们可以看到，<code>栈</code>一切都回到了<code>call func</code> 这个指令执行之前，只有<code>eip</code>的位置改变了，仿佛它从没来过…</p><p>到此为止<code>32位程序</code>函数的调用以及栈的变化就结束了，可以得到一个结论就是<code>函数调用前后，栈内状况不变</code>。其实这非常好理解，因为在一个函数中调用另外一个函数当然不能影响原函数的运行，所以<code>栈</code>的设计做到了<code>用完就丢</code>。被调用函数结束后<code>esp</code>和<code>ebp</code>的位置都会回到<code>call</code>这个指令之前的状态，而<code>esp</code>和<code>ebp</code>之间的数据也都没有改变<br>上述结论在<code>64位</code>中同样适用，而<code>64位程序</code>和<code>32位程序</code>除了位数上不同，最大的不同就在于<code>64位程序</code>会优先将<code>被调用函数的参数</code>存放在寄存器中</p><p>这是32位函数调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> )</span> &#123;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span> ) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>![[push放入参数.png]]</p><p>而这是64位函数调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是一段有问题的C语言代码，仅仅只是用作C语言函数调用流程的介绍，为了方便读者理解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span>, 参数<span class="hljs-number">4</span>, 参数<span class="hljs-number">5</span> ,参数<span class="hljs-number">6</span>, 参数<span class="hljs-number">7</span>, 参数<span class="hljs-number">8</span>)</span> &#123;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span> ,参数<span class="hljs-number">3</span>, 参数<span class="hljs-number">4</span>, 参数<span class="hljs-number">5</span> ,参数<span class="hljs-number">6</span>, 参数<span class="hljs-number">7</span>, 参数<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在64位程序中，函数的参数会依次放入<code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code> <code>r8</code> <code>r9</code> 这六个寄存器中，只有把这六个寄存器塞满后，才会<code>从右到左</code>依次放入<code>栈</code>中，像上面的代码，<code>func函数</code>有<code>8个参数</code>，那么就如图所示:<br>![[AETKIQTQPOVSB5_Q7)UY(XK.png]]<br><code>注意:64位所用的是位数更多更大的RSP和RBP</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实程序本身的流程并不困难，只是初学者对汇编语言的了解较少所以难以理解，如果对于文章内容难以理解，不妨寻找一些汇编语言的教程较为系统的了解汇编语言也许会有所帮助</p><p>(制作图片用的是win11自带的画图工具，里面的字体大小不知道为什么调节不了，所以出现了字体很小的情况，<code>(。・＿・。)ﾉI’m sorry~</code>)</p><p>参考文献:<br><a href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） (yuque.com)</a><br><a href="https://segmentfault.com/a/1190000007977460">linux - C函数调用过程原理及函数栈帧分析 - 编程之道 - SegmentFault 思否</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.1)%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A0%86%E6%A0%88%E5%85%A5%E9%97%A8/"/>
    <url>/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.1)%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A0%86%E6%A0%88%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="啥是汇编语言-有啥用"><a href="#啥是汇编语言-有啥用" class="headerlink" title="啥是汇编语言?有啥用?"></a>啥是汇编语言?有啥用?</h3><p>深入了解计算机底层，我们会发现，计算机实际上只能执行一些非常基础的操作，但其速度却非常快。计算机的CPU只能执行机器码，即由一系列0和1组成的指令。不同的0和1组合会触发计算机中的不同电路，从而进行各种操作。由于这些0和1的组合很长，阅读起来不方便，因此通常以16进制形式显示。然而，即便如此，16进制的表示仍然难以理解。为了简化这一过程，汇编语言应运而生，它用更易读的符号来表示这些机器指令，从而使程序员能够更方便地编写和理解代码。</p><h3 id="啥是寄存器"><a href="#啥是寄存器" class="headerlink" title="啥是寄存器?"></a>啥是寄存器?</h3><p>计算机中的所有指令都是由CPU执行的。在计算机结构中，CPU和内存是分开的，而寄存器则位于CPU内部。CPU可以直接访问寄存器中的数据来执行各种指令操作。在程序执行过程中，数据通常从内存 –&gt; 缓存（cache）–&gt; 寄存器，只有到了寄存器中CPU才能对其进行处理。处理完成后，程序决定是否将寄存器中的数据写回内存，以更新内存中的内容。除了存储数据，寄存器还可以用于存储指令、地址、状态信息和其他控制数据。因此，寄存器在计算机中发挥着至关重要的作用，帮助提高处理速度和效率。<br>下图表介绍一些常用的寄存器<br>![[H2CHFA)S%5OFNI}[VG__X2O.png]]</p><h3 id="什么是栈-什么是堆"><a href="#什么是栈-什么是堆" class="headerlink" title="什么是栈?什么是堆?"></a>什么是栈?什么是堆?</h3><p>先贴一张图用来理清楚堆和栈在程序中的位置<br>![[G81(Z12S[WJL)@{7H5~UBSI.png]]</p><h5 id="栈的简单介绍"><a href="#栈的简单介绍" class="headerlink" title="栈的简单介绍"></a>栈的简单介绍</h5><p>在计算机程序运行时，系统会将可执行文件的<code>text段</code>（代码段）和<code>data段</code>（数据段）加载到内存中。在C语言等编程语言中，函数调用过程中需要<code>传递参数</code>并<code>创建局部变量</code>。如果这些数据都存储在<code>data段</code>或<code>bss段</code>中，会导致内存空间的浪费，并使得管理变得复杂。<br>为了高效管理函数的参数和局部变量，并在<code>函数调用结束后释放相关资源</code>，我们使用了<strong>栈</strong>。<strong>栈</strong>是一种<code>后进先出（LIFO）</code>的数据结构，它能够在函数调用时创建栈帧来存储函数的局部变量、参数、返回地址等信息。当函数调用结束时，栈帧会被自动销毁，从而释放内存，避免内存浪费。栈不仅节省内存，还确保了函数调用和返回过程的有序进行。</p><p><code>ESP</code>（栈指针）和 <code>EBP</code>（基址指针）之间的空间被称为<code>栈帧</code>。<code>栈帧</code>是一个函数调用的<code>栈上空间</code>，主要用于<code>存储函数的局部变量</code>、<code>参数</code>、<code>返回地址</code>以及<code>保存的寄存器状态</code>等信息。在每次函数调用时，都会为该函数分配一个新的栈帧，并在<code>函数执行完成后释放这个栈帧</code>。栈帧的结构通常如下：</p><ul><li>**栈顶 (由 <code>ESP</code> 指针指向)**：函数调用时，栈顶包含函数的局部变量和临时数据。</li><li>**栈底 (由 <code>EBP</code> 指针指向)**：栈底用于存储函数调用的参数和返回地址等。</li></ul><p><code>栈帧</code>的设计使得函数调用和返回变得高效，并且支持递归调用等复杂的函数调用模式。</p><h5 id="堆的简单介绍"><a href="#堆的简单介绍" class="headerlink" title="堆的简单介绍"></a>堆的简单介绍</h5><p>堆是用于存放进程运行中动态分配的内存段，其大小可以在运行时根据需求调整。调用<code>malloc</code>、<code>calloc</code>或<code>realloc</code>等函数时，会从堆上分配内存。释放内存时使用<code>free</code>函数，以便回收堆内存。堆内存的管理由程序员负责，不会自动释放，需要手动管理内存的分配和释放。</p><h5 id="浅浅总结一下"><a href="#浅浅总结一下" class="headerlink" title="浅浅总结一下:"></a>浅浅总结一下:</h5><p><code>栈</code>用于存放各个函数所需要使用的参数，比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">30</span>];  <span class="hljs-comment">// str是一个局部变量，存储在栈上</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%29s&quot;</span>, str);  <span class="hljs-comment">// 读取字符串到str中</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);  <span class="hljs-comment">// 输出str的内容</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>str</code>是一个局部数组，分配在栈上。</p><p><code>堆</code>则是用于存放用户的数据，并且由用户决定什么时候释放它。比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 100</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_heap</span><span class="hljs-params">(<span class="hljs-type">char</span> **heap_memory)</span> &#123;<br>    *heap_memory = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(BUFFER_SIZE * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-keyword">if</span> (*heap_memory == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory allocation failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory created.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">edit_heap</span><span class="hljs-params">(<span class="hljs-type">char</span> *heap_memory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (heap_memory == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory not created yet.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a string to store in heap memory: &quot;</span>);<br>    fgets(heap_memory, BUFFER_SIZE, <span class="hljs-built_in">stdin</span>);<br><br>    heap_memory[<span class="hljs-built_in">strcspn</span>(heap_memory, <span class="hljs-string">&quot;\n&quot;</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory updated.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_heap</span><span class="hljs-params">(<span class="hljs-type">char</span> *heap_memory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (heap_memory == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory not created yet.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(heap_memory);<br>    heap_memory = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap memory deleted.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *heap_memory = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> choice;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nMenu:\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. Create heap memory\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. Edit heap memory\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. Delete heap memory\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter your choice: &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;choice);<br>        getchar();  <br><br>        <span class="hljs-keyword">switch</span> (choice) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                create_heap(&amp;heap_memory);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                edit_heap(heap_memory);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                delete_heap(heap_memory);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-keyword">if</span> (heap_memory != <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-built_in">free</span>(heap_memory);  <br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Exiting program.\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid choice. Please try again.\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(这里例子可能举的有点复杂…但是之后遇到的<code>堆</code>的题目大多也是类似这样的，所以堆的难度会比<code>栈</code>大很多，知识量也多很多)<br>总之上面的代码就是一般堆的用法，不需要理解，只是作为展示，大致内容如下:<br>输入1，用户可以<code>申请一个堆的空间</code>。<br>输入2，用户可以<code>编辑所申请到的空间</code>。<br>输入3，用户可以<code>删除申请到的空间</code>。</p><h3 id="常用汇编指令与C语言对比"><a href="#常用汇编指令与C语言对比" class="headerlink" title="常用汇编指令与C语言对比"></a>常用汇编指令与C语言对比</h3><ol><li><p><strong>MOV</strong></p><ul><li><strong>功能</strong>：将数据从一个位置复制到另一个位置。</li><li><strong>汇编</strong>：<code>MOV AX, 1234h</code></li><li><strong>C语言</strong>：<code>AX = 0x1234;</code></li><li><strong>说明</strong>：<code>MOV</code> 是把数据从源位置复制到目标位置，类似于C语言中的赋值操作。<code>MOV</code> 不改变源数据，只是复制到目标位置。</li></ul></li><li><p><strong>ADD &#x2F; SUB</strong></p><ul><li><strong>功能</strong>：进行加法和减法运算。</li><li><strong>汇编</strong>：<code>ADD AX, BX</code>（<code>AX = AX + BX</code>）；<code>SUB CX, 5</code>（<code>CX = CX - 5</code>）</li><li><strong>C语言</strong>：<code>AX += BX;</code>（<code>AX = AX + BX</code>）；<code>CX -= 5;</code>（<code>CX = CX - 5</code>）</li><li><strong>说明</strong>：<code>ADD</code> 和 <code>SUB</code> 用于对寄存器或内存中的值进行加减操作，更新结果并设置标志寄存器的状态。</li></ul></li><li><p><strong>INC &#x2F; DEC</strong></p><ul><li><strong>功能</strong>：递增或递减操作数。</li><li><strong>汇编</strong>：<code>INC AX</code>（<code>AX = AX + 1</code>）；<code>DEC BX</code>（<code>BX = BX - 1</code>）</li><li><strong>C语言</strong>：<code>AX++;</code>（<code>AX = AX + 1</code>）；<code>BX--;</code>（<code>BX = BX - 1</code>）</li><li><strong>说明</strong>：<code>INC</code> 和 <code>DEC</code> 只能对寄存器或内存位置操作，不能对立即数操作。</li></ul></li><li><p><strong>CMP</strong></p><ul><li><strong>功能</strong>：比较两个值，并设置标志寄存器状态。</li><li><strong>汇编</strong>：<code>CMP AX, BX</code>（<code>if (AX == BX)</code>）</li><li><strong>C语言</strong>：<code>if (AX == BX)</code>（<code>AX</code> 和 <code>BX</code> 比较）</li><li><strong>说明</strong>：<code>CMP</code> 实际上是做了 <code>AX - BX</code> 的操作然后判断是否等于0，更新状态标志。</li></ul></li><li><p><strong>JMP</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的地址。</li><li><strong>汇编</strong>：<code>JMP start</code></li><li><strong>C语言</strong>：<code>goto start;</code></li><li><strong>说明</strong>：<code>JMP</code> 改变程序的执行流，跳转到标记为 <code>start</code> 的位置。</li></ul></li><li><p><strong>JE &#x2F; JNE &#x2F; JZ &#x2F; JNZ</strong></p><ul><li><strong>功能</strong>：根据条件跳转到指定地址。</li><li><strong>汇编</strong>：<code>JE equal</code>（<code>if (zero flag) goto equal;</code>）；<code>JNE not_equal</code>（<code>if (not equal) goto not_equal;</code>）</li><li><strong>C语言</strong>：<code>if (flag == 0) goto equal;</code>（<code>JE</code> 跳转条件为零标志）；<code>if (flag != 0) goto not_equal;</code>（<code>JNE</code> 跳转条件为非零）</li><li><strong>说明</strong>：这些指令依据先前比较操作的结果决定是否跳转。</li></ul></li><li><p><strong>CALL &#x2F; RET</strong></p><ul><li><strong>功能</strong>：调用和返回函数。</li><li><strong>汇编</strong>：<code>CALL myFunction</code>（调用函数）；<code>RET</code>（返回函数）</li><li><strong>C语言</strong>：<code>myFunction();</code>（调用函数）；<code>return;</code>（从函数返回）</li><li><strong>说明</strong>：<code>CALL</code> 会保存当前的返回地址，并跳转到目标函数；<code>RET</code> 从栈中恢复返回地址并跳转回。</li></ul></li><li><p><strong>PUSH &#x2F; POP</strong></p><ul><li><strong>功能</strong>：压入或弹出栈数据。</li><li><strong>汇编</strong>：<code>PUSH AX</code>（压入栈）；<code>POP BX</code>（从栈中弹出）</li><li><strong>C语言</strong>：<code>stack.push(AX);</code>（假设有栈操作的C语言函数）；<code>BX = stack.pop();</code>（假设有栈操作的C语言函数）</li><li><strong>说明</strong>：<code>PUSH</code> 和 <code>POP</code> 操作栈，<code>PUSH</code> 将数据压入栈顶，<code>POP</code> 从栈顶弹出数据。</li></ul></li><li><p><strong>NOP</strong></p><ul><li><strong>功能</strong>：空操作，不产生任何效果。</li><li><strong>汇编</strong>：<code>NOP</code></li><li><strong>C语言</strong>：没有直接的C语言对应，可以理解为一个空的操作(或者可以理解成C语言的注释符号)。</li><li><strong>说明</strong>：<code>NOP</code> 通常用于占位或调试，不会改变程序状态。</li></ul></li><li><p><strong>LEA</strong></p><ul><li><strong>功能</strong>：加载有效地址，将计算得到的地址赋给寄存器。</li><li><strong>汇编</strong>：<code>LEA AX, [BX+SI]</code></li><li><strong>C语言</strong>：<code>AX = &amp;array[BX + SI];</code>（假设 <code>array</code> 是一个数组）</li><li><strong>说明</strong>：<code>LEA</code> 计算一个地址并将其存入寄存器，类似于获取指针地址而不实际访问内存。</li></ul></li><li><p><strong>AND &#x2F; OR &#x2F; XOR &#x2F; NOT</strong></p><ul><li><strong>功能</strong>：按位操作。</li><li><strong>汇编</strong>：<code>AND AX, BX</code>（按位与）；<code>OR AX, BX</code>（按位或）；<code>XOR AX, BX</code>（按位异或）；<code>NOT AX</code>（按位取反）</li><li><strong>C语言</strong>：<code>AX = AX &amp; BX;</code>（按位与）；<code>AX = AX | BX;</code>（按位或）；<code>AX = AX ^ BX;</code>（按位异或）；<code>AX = ~AX;</code>（按位取反）</li><li><strong>说明</strong>：这些指令用于位级操作，<code>AND</code> 和 <code>OR</code> 用于逻辑运算，<code>XOR</code> 用于位翻转，<code>NOT</code> 对每一位取反。</li></ul></li></ol><p>这里重点介绍一下<code>PUSH</code> <code>POP</code> 这两个指令<br><code>PUSH</code>和<code>POP</code>是对<code>栈</code>进行操作的指令</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">我 是 栈 ↓<br>  ----<br> |<span class="hljs-string">  5 </span>|<span class="hljs-string">  &lt;- 栈底ebp:注意，我是栈底，我在高地址</span><br><span class="hljs-string">  ----</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  4 </span>|<br>  ----<br> |<span class="hljs-string">  3 </span>|<br>  ----<br> |<span class="hljs-string">  2 </span>|<br>  ----<br> |<span class="hljs-string">  1 </span>|<span class="hljs-string">  &lt;- 栈顶esp:注意，我是栈顶，我在低地址</span><br><span class="hljs-string">  ----</span><br><span class="hljs-string">假设这是栈最开始的样子</span><br><span class="hljs-string">假设：</span><br><span class="hljs-string">  eax = 6</span><br><span class="hljs-string">  ebx = 7</span><br></code></pre></td></tr></table></figure><p>我浅浅画了一个非常抽象的<code>栈</code>，但是这并不影响我们理解它。<br>当我们执行 <code>POP ebx</code> 这个指令后，那么就会让栈变成这个样子↓</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elm">我 是 栈 ↓<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">5</span> |  &lt;- 栈底ebp:我不动，与我无瓜<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">4</span> |<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">3</span> |<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">2</span> |  &lt;- 栈顶esp:执行完<span class="hljs-type">POP</span>后，我会向高地址移动，现在我指向<span class="hljs-number">2</span>了<br>  <span class="hljs-comment">----</span><br> |  <span class="hljs-number">1</span> |  &lt;-- <span class="hljs-number">1</span>没有消失，只是不在esp和ebp之间的栈帧了，这导致我们无法直接访问<br>  <span class="hljs-comment">----</span><br><br>  eax = <span class="hljs-number">6</span><br>  ebx = <span class="hljs-number">1</span> &lt;-- 注意注意，ebx变成<span class="hljs-number">1</span>了<br></code></pre></td></tr></table></figure><p>然后来看看<code>PUSH eax</code></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">我 是 栈 ↓<br>  ----<br> |<span class="hljs-string">  5 </span>|<span class="hljs-string">  &lt;- 栈底ebp:我还是不动，依旧与我无瓜</span><br><span class="hljs-string">  ----</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  4 </span>|<br>  ----<br> |<span class="hljs-string">  3 </span>|<br>  ----<br> |<span class="hljs-string">  2 </span>|<span class="hljs-string">  </span><br><span class="hljs-string">  ----</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  6 </span>|<span class="hljs-string">  &lt;- 栈顶esp:执行完PUSH后，我会向低地址地址移动，并且将eax的值，也就是6   ----      放入栈当中，替换掉了1</span><br><span class="hljs-string">  </span><br><span class="hljs-string">  eax = 6</span><br><span class="hljs-string">  ebx = 1 </span><br></code></pre></td></tr></table></figure><h3 id="为什么函数调用需要用栈"><a href="#为什么函数调用需要用栈" class="headerlink" title="为什么函数调用需要用栈"></a>为什么函数调用需要用栈</h3><p>首先为什么<code>栈</code>是<code>后进先出(LIFO)</code>，这样的设计是因为程序的执行符合一种将复杂的大问题拆解成一个个小问题来解决的思想。<br>大问题的解决需要小问题的答案，而小问题得到答案之后就可以抛弃了。<br>比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// 如果需要使用标准输入输出函数</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> &#123;<br>    func1();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func3</span><span class="hljs-params">()</span> &#123;<br>    func2();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func3();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个程序的执行流程就是 <code>main --&gt; func1 --&gt; func2 --&gt; func3 --&gt; printf</code><br>那么栈的空间就是:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"> ---------------<br>|<span class="hljs-string"> main 的栈空间  </span>|<span class="hljs-string">  &lt;- 栈底 ebp(高地址)</span><br><span class="hljs-string"> ---------------</span><br><span class="hljs-string"></span>|<span class="hljs-string"> func1 的栈空间 </span>|<br> ---------------<br>|<span class="hljs-string"> func2 的栈空间 </span>|<br> ---------------<br>|<span class="hljs-string"> func3 的栈空间 </span>|<br> ---------------<br>|<span class="hljs-string"> printf 的栈空间</span>|<span class="hljs-string">  &lt;- 栈顶 esp(低地址)</span><br><span class="hljs-string"> ---------------</span><br></code></pre></td></tr></table></figure><p>我们得出规律，大问题函数程序总是最后消失<br>也就是<code>调用者</code>的生命周期总是长于<code>被调用者</code><br>这恰好符合了<code>栈</code>的<code>FILO</code>的特点。所以<code>栈</code>一定不是被随意设计的，而是一种完美符合计算机程序设计思想的一种数据结构</p><p>参考文献:<br><a href="https://www.cnblogs.com/tolin/p/14982094.html">什么是堆？什么是栈？他们之间有什么区别和联系？ - tolin - 博客园 (cnblogs.com)</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yom93l">PWN入门（1-1-2）-bss段、data段、text段、堆(heap)和栈(stack) (yuque.com)</a><br><a href="https://zhuanlan.zhihu.com/p/664901746">在x86架构中的寄存器 - 知乎 (zhihu.com)</a><br><a href="https://blog.csdn.net/qq_65596720/article/details/130743499">什么是栈，为什么函数式编程语言都离不开栈？_没有栈,都是跟栈有什么关系-CSDN博客</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） (yuque.com)</a><br><a href="https://segmentfault.com/a/1190000007977460">linux - C函数调用过程原理及函数栈帧分析 - 编程之道 - SegmentFault 思否</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.0)ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%A7%A3%E6%9E%90(%E7%AE%80%E7%89%88)/"/>
    <url>/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.1.0)ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%A7%A3%E6%9E%90(%E7%AE%80%E7%89%88)/</url>
    
    <content type="html"><![CDATA[<p><strong>ELF (Executable and Linkable Format)</strong>: 是一种用于 <code>可执行文件</code>、<code>目标文件</code> 和 <code>库</code> 的文件格式，类似于 Windows 下的 <strong>PE</strong> 文件格式。</p><p>ELF 主要包括三种类型的文件：</p><ul><li><strong>可重定位文件 (relocatable)</strong>: 编译器和汇编器产生的 <code>.o</code> 文件，由 <strong>Linker</strong> 处理。</li><li><strong>可执行文件 (executable)</strong>: <strong>Linker</strong> 对 <code>.o</code> 文件进行处理后输出的文件，代表进程映像。</li><li><strong>共享对象文件 (shared object)</strong>: 动态库文件，通常是 <code>.so</code> 文件。</li></ul><p>ELF 文件包含多个段，每个段承担不同的作用。以下是一些入门级 PWN 可能需要用到的段（仅介绍这些基本段）：</p><ol><li><strong>.text</strong>: 用于保存程序中的代码片段。</li><li><strong>.data</strong>: 用于保存已经初始化的全局变量和局部变量。</li><li><strong>.bss</strong>: 用于保存未初始化的全局变量和局部变量。</li><li><strong>.plt</strong>: 用于链接和跳转到对应的 <strong>.got</strong> 表。</li><li><strong>.got.plt</strong>: 存储对应函数的真实地址的表。</li><li>.rodata: 只读数据</li><li>.init: 程序初始化和终止的代码</li></ol><p>![[Pasted image 20240916112756.png]]</p><p>ELF 文件中的段在程序执行前会被加载到内存中,然后在计算机内存中<br>一个程序可以认为由<code>bss段</code>、<code>data段</code>、<code>text段</code>三个部分组成的。<br><code>text段</code>和<code>data段</code>都存在可执行文件当中，程序执行时，系统从可执行文件中加载至内存<br>而<code>bss段</code>在可执行文件中只是一个符号用于占位，由系统根据其符号进行初始化</p><p>如何加载:<br>![[ELF和程序的对应关系2.png]]</p><h3 id="text-段"><a href="#text-段" class="headerlink" title=".text 段"></a><strong>.text 段</strong></h3><ul><li><strong>代码段 (code segment)</strong>: 用来存放 <code>程序执行的代码</code>。</li><li>这个段的大小在程序执行之前就已经确定，因为编译好的程序代码量一般是固定的。</li><li>该段通常有读和执行权限，但一般禁止修改（当然，也有部分特殊架构允许修改代码段）。</li><li>在代码段中，可能也包含一些常数变量，例如字符串。</li></ul><h3 id="data-段"><a href="#data-段" class="headerlink" title=".data 段"></a><strong>.data 段</strong></h3><ul><li><strong>数据段 (data segment)</strong>: 用来存放已经 <code>初始化的全局变量</code>。</li><li>数据段属于静态内存分配，即被程序分配后大小不再改变。</li></ul><p><strong>例子</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> str[<span class="hljs-number">30</span>] = <span class="hljs-string">&quot;i_am_xidp_and_i_love_pwn&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，已经被赋值好的数据 <code>str</code> 会被放在 <strong>.data</strong> 段中。由于其大小是固定的，因此 <strong>.data</strong> 段中的数据也是固定大小的。</p><h3 id="bss-段"><a href="#bss-段" class="headerlink" title=".bss 段"></a><strong>.bss 段</strong></h3><ul><li><strong>bss 段 (bss segment)</strong>: 用于存放程序中未初始化的全局变量。</li><li>和 <strong>.data</strong> 段一样，属于静态内存分配。</li></ul><p><strong>例子</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> str[<span class="hljs-number">30</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>.bss</strong> 段本身不会占用 ELF 文件的实际大小，它在 ELF 等可执行文件中只是一个符号用于占位。程序执行时，会根据这个符号在计算机中分配相应的内存大小。</p><p><strong>数据区</strong>: <strong>.data</strong> 段和 <strong>.bss</strong> 段通常被称为数据区。</p><p>参考文献:<br><a href="https://www.cnblogs.com/QiQi-Robotics/p/15573352.html">Linux可执行文件格式-ELF结构详解 - 我叫平沢唯 - 博客园 (cnblogs.com)</a><br><a href="https://www.yuque.com/cyberangel/rg9gdm/yom93l">PWN入门（1-1-2）-bss段、data段、text段、堆(heap)和栈(stack) (yuque.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.0.0)%E5%89%8D%E8%A8%80/"/>
    <url>/2024/09/17/%E8%8F%9C%E9%B8%9F%E7%AC%94%E8%AE%B0%E4%B9%8BPWN%E5%85%A5%E9%97%A8(1.0.0)%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-PWN？"><a href="#什么是-PWN？" class="headerlink" title="什么是 PWN？"></a>什么是 PWN？</h3><p><code>PWN</code> 是黑客术语中的俚语，是指攻破设备或者系统。它的发音类似于<code>“砰”</code>，当然也有师傅把它叫作<code>“胖”</code>。PWN 的目标是获取系统的控制权或执行未经授权的操作。</p><h3 id="如何入门-PWN"><a href="#如何入门-PWN" class="headerlink" title="如何入门 PWN"></a>如何入门 PWN</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li><p><strong>C 语言</strong></p><ul><li><strong>学习内容</strong>：<ul><li>程序结构和基础语法</li><li>数据类型、分支语句（如 <code>if</code>、<code>switch</code>）和循环（如 <code>for</code>、<code>while</code>）</li><li>指针和结构体</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">浙江大学翁恺教你 C 语言程序设计</a></li><li><a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程 | 菜鸟教程</a></li></ul></li></ul></li><li><p><strong>Python 语言</strong></p><ul><li><strong>学习内容</strong>：<ul><li>程序结构和基础语法</li><li>循环（<code>for</code>、<code>while</code>）和异常处理（如 <code>try</code>）</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程 | 菜鸟教程</a></li><li><a href="https://www.bilibili.com/video/BV1944y1x7SW/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">超基础 Python 课程</a></li></ul></li></ul><p> <strong>建议</strong>：掌握 C 语言后，可以直接用文章进行 Python 的学习，进度会更快。 </p></li><li><p><strong>汇编语言</strong></p><ul><li><strong>常见类型</strong>：<ul><li><strong>x86 汇编</strong>：Intel 和 AMD 的处理器架构</li><li><strong>ARM 汇编</strong>：用于移动设备</li><li><strong>MIPS 汇编</strong>：用于嵌入式系统</li><li><strong>PowerPC 汇编</strong>：曾用于苹果计算机</li><li><strong>RISC-V 汇编</strong>：开源架构，逐渐获得关注</li></ul></li><li><strong>学习资源</strong>：<ul><li><a href="https://www.bilibili.com/video/BV1eG4y1S7R5/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">《汇编语言》速成指南</a></li><li><a href="https://www.bilibili.com/video/BV1Wu411B72F/?spm_id_from=333.337.search-card.all.click&vd_source=4276fc17276ff66d44a2713a1ca58c94">通俗易懂的汇编语言（王爽老师的书）</a></li></ul></li></ul><p> <strong>基础要求</strong>：理解基本的汇编指令（如 <code>pop</code>、<code>push</code>、<code>jmp</code>）和程序流程即可。 </p></li><li><p><strong>ELF 相关知识</strong></p><ul><li><strong>学习内容</strong>：<ul><li>ELF 文件的组成部分</li><li>各部分的作用</li><li>常用的保护机制</li></ul></li><li><strong>学习资源</strong>：<br>  在后续文章中会有简单介绍</li></ul></li><li><p><strong>Linux 操作系统基础</strong></p><ul><li><strong>学习内容</strong>：<ul><li>基本的 Linux 命令（如 <code>cd</code>、<code>ls</code>、<code>cat</code>）</li><li>系统调用函数（如 <code>execve</code>）</li><li>glibc 库</li></ul></li><li><strong>学习资源</strong>：<br>  在后续文章中会有简单介绍</li></ul><p> <strong>基础要求</strong>：能够使用基本的 Linux 命令，了解系统调用函数和 glibc 库的基本知识。</p></li></ol><h4 id="工具和资源"><a href="#工具和资源" class="headerlink" title="工具和资源"></a>工具和资源</h4><ol><li><p><strong>虚拟机和操作系统</strong>：</p><ul><li><strong>建议</strong>：搭建一个 <code>Ubuntu</code> 虚拟机环境，以便调试和解决题目。</li><li>尽管大部分题目都使用Ubuntu环境，但这并不意味着你必须要使用 Ubuntu 作为你的主力操作系统 。你仍旧可以选择继续使用你喜欢的其他 Linux 发行版（如，Arch、Debian、openSUSE、Fedora、NixOS 等）然后使用 <code>Docker</code> 来模拟 <code>Ubuntu</code> 环境</li></ul></li><li><p><strong>工具</strong>：</p><ul><li><strong>IDA</strong>：逆向分析工具</li><li><strong>Python + pwntools</strong>：用于编写漏洞利用脚本</li><li><strong>gdb + pwndbg&#x2F;peda</strong>：用于调试二进制文件</li><li><strong>QEMU</strong>：有些题目需要它来模拟环境(对于基础入门并不是必须的工具)</li></ul><p> <strong>注意</strong>：入门阶段不需要配置复杂的环境，基础的调试和利用工具足够。</p><pre><code class="hljs">                                                             ---CTF Wiki</code></pre></li></ol><h4 id="PWN-大致内容"><a href="#PWN-大致内容" class="headerlink" title="PWN 大致内容"></a>PWN 大致内容</h4><ul><li><strong>栈溢出与 ROP 链</strong>：理解栈溢出漏洞和如何利用返回-oriented programming（ROP）来绕过安全保护机制。</li><li><strong>格式化字符串</strong>：学习如何利用格式化字符串漏洞来进行攻击。</li><li><strong>整数安全</strong>：了解整数溢出等安全问题。</li><li><strong>堆漏洞利用</strong>：探索如何利用堆上的漏洞进行攻击。</li><li><strong>异架构</strong>：理解不同架构（如 x86、ARM）的特点和攻击方法。</li><li><strong>内核漏洞</strong>：深入研究内核漏洞 (可能这并不基础…)</li></ul><h3 id="做PWN题的大致流程"><a href="#做PWN题的大致流程" class="headerlink" title="做PWN题的大致流程"></a>做PWN题的大致流程</h3><p>这里使用buuctf中PWN板块的第二题<code>rip</code>为例子:<a href="https://buuoj.cn/challenges#rip">BUUCTF在线评测 (buuoj.cn)</a></p><h5 id="1-下载和启动靶机"><a href="#1-下载和启动靶机" class="headerlink" title="1. 下载和启动靶机"></a>1. 下载和启动靶机</h5><p>点开题目，里面会有一个可以下载的文件，以及<code>启动靶机</code>四个大字。如下图:<br>![[1.png]]</p><h5 id="2-将文件传入Linux虚拟机"><a href="#2-将文件传入Linux虚拟机" class="headerlink" title="2. 将文件传入Linux虚拟机"></a>2. 将文件传入Linux虚拟机</h5><p>打开Linux虚拟机,下载这个附件并将这个附件传入到Linux虚拟机中。此时我们可以看到这个附件叫<code>pwn1</code></p><h5 id="3-检查二进制文件的安全性和架构"><a href="#3-检查二进制文件的安全性和架构" class="headerlink" title="3. 检查二进制文件的安全性和架构"></a>3. 检查二进制文件的安全性和架构</h5><p>使用<code>checksec</code>工具(安装<code>pwntools</code>后就有了)去查看它的架构和位数以及保护开启的情况，这里因为是基础题所以什么保护都没有<br>![[2.png]]</p><h5 id="4-反编译和分析二进制文件"><a href="#4-反编译和分析二进制文件" class="headerlink" title="4. 反编译和分析二进制文件"></a>4. 反编译和分析二进制文件</h5><p>将文件拖动到IDA这类反编译工具中，对二进制文件进行反编译<br>下图中这个非常有魅力的女人头像的工具就是我们的IDA<br>![[3.png]]<br>刚刚我们通过<code>checksec</code>已经知道了<code>pwn1</code>他是64位的，那么就拖入64位的IDA中(其实如果你拖错了，IDA会提示你搞错了，所以<code>checksec</code>的主要功能是查看开启了什么保护)</p><p>拖入后会看到这个画面，直接<code>OK</code>就完事了<br>![[4.png]]<br>然后进入后，我们在左侧的Functions栏里面找到main函数并点击他<br>![[5.png]]<br>选中main函数后，按TAB键(一般在Q的左边)或者按F5键，此时就会显示<code>伪C语言代码</code><br>![[6.png]]</p><h5 id="5-理解代码和找出漏洞"><a href="#5-理解代码和找出漏洞" class="headerlink" title="5. 理解代码和找出漏洞"></a>5. 理解代码和找出漏洞</h5><p>看懂代码(需要学习C语言)，找出漏洞(需要学习相关的PWN知识),编写python脚本(需要学习python语言和使用pwntools等库)<br>pwntools的使用后续会进行介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#PWN1 exp</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-comment">#io = process(&#x27;./pwn1&#x27;) # 本地</span><br>io = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28735</span>)<br><br>payload = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">15</span><br>payload +=p64(<span class="hljs-number">0x401186</span>)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>这里我编写了python脚本，并将其命名为<code>exp.py</code></p><h5 id="6-创建靶机并运行脚本尝试攻击"><a href="#6-创建靶机并运行脚本尝试攻击" class="headerlink" title="6. 创建靶机并运行脚本尝试攻击"></a>6. 创建靶机并运行脚本尝试攻击</h5><ul><li>**使用<code>nc</code>**：用<code>nc</code>命令连接靶机（如<code>nc node5.buuoj.cn 28735</code>）进行测试。<ul><li><strong>测试脚本</strong>：将脚本中的地址和端口替换为靶机提供的实际地址和端口。</li><li><strong>检查结果</strong>：确认脚本是否能正确获取flag，解决<code>EOF</code>错误的问题。</li></ul></li></ul><p>点击<code>启动靶机</code><br>![[7.png]]<br>会得到一串nc地址，这个可以在Linux中使用<code>nc</code>工具进行连接<br>![[8.png]]<br>这里我们使用python脚本去攻击它的时候，需要将其放入python脚本中<br>比如:<code>io = remote(&#39;node5.buuoj.cn&#39;,28735)</code><br>我们尝试运行这个脚本<br>![[9.png]]<br>然后输入指令cat flag就可以拿到我们想要的东西了，复制flag去平台提交即可<br>![[10.png]]</p><p>如果没有打通的话会输出提示<br><code>[*] Got EOF while reading in interactive</code><br>表示连接断开了，此时你输入cat flag是没有用的<br>![[11.png]]</p><h3 id="刷题平台推荐"><a href="#刷题平台推荐" class="headerlink" title="刷题平台推荐"></a>刷题平台推荐</h3><p><a href="https://buuoj.cn/challenges">BUUCTF在线评测 (buuoj.cn)</a><br><a href="https://www.nssctf.cn/problem">题库 | NSSCTF</a><br><a href="https://pwn.college/fundamentals/program-misuse">pwn.college</a><br><a href="https://ctf.show/challenges#">ctf.show</a></p><p>其中<code>ctfshow</code>大部分题目是收费的，但是里面的题目较为系统化，从简单到困难，因此我个人比较推荐</p><p>学习PWN是非常漫长的过程，需要学习大量知识，以及进行大量的练习。许多难以理解的问题可能很长一段时间都无法得到解决，复杂的漏洞利用也常常想让人放弃。所以在文章的最后我想分享翁恺老师的一段话:<code>“计算机里的所有东西都是人做出来的，别人能想的出来的，我也一定能想的出来。在计算机里头没有任何黑魔法。所有的东西只是我现在还不知道而已，总有一天我会把所有细节所有内部的东西全都搞明白。”</code></p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><a href="https://ns.openctf.net/learn/pwn.html#elf-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">Pwn | 快速入门 - NewStar CTF</a></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/#peda">Environment - CTF Wiki (ctf-wiki.org)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>这是一篇测试文章</title>
    <link href="/2024/07/18/hello-world/"/>
    <url>/2024/07/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>本文用于测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
